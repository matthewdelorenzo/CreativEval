Extracted Text,Reward,Prompt Name,Prompt Text,GoldenSolFull,WholeModule,TrimmedModule
"
    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d); 
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d); 
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d); 
endmodule
"
"
  assign p1y = ~(p1a & p1b & p1c & p1d);
  assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

  assign p1y = ~(p1a & p1b & p1c & p1d);
  assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

  assign p1y = ~(p1a & p1b & p1c & p1d);
  assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
"
"
    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
"
"
    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
"
"
  assign p1y = ~(p1a & p1b & p1c & p1d);
  assign p2y = ~(p2a & p2b & p2c & p2d); 
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

  assign p1y = ~(p1a & p1b & p1c & p1d);
  assign p2y = ~(p2a & p2b & p2c & p2d); 
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

  assign p1y = ~(p1a & p1b & p1c & p1d);
  assign p2y = ~(p2a & p2b & p2c & p2d); 
endmodule
"
"
  // Implementing the functionality of the 7420 chip using two 4-input NAND gates
  assign p1y = ~(p1a & p1b & p1c & p1d);
  assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

  // Implementing the functionality of the 7420 chip using two 4-input NAND gates
  assign p1y = ~(p1a & p1b & p1c & p1d);
  assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

  // Implementing the functionality of the 7420 chip using two 4-input NAND gates
  assign p1y = ~(p1a & p1b & p1c & p1d);
  assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
"
"
    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
"
"
    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
"
"
    // Logic for the first 4-input NAND gate
    assign p1y = ~(p1a & p1b & p1c & p1d);
    
    // Logic for the second 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d);
    
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    // Logic for the first 4-input NAND gate
    assign p1y = ~(p1a & p1b & p1c & p1d);
    
    // Logic for the second 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d);
    
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    // Logic for the first 4-input NAND gate
    assign p1y = ~(p1a & p1b & p1c & p1d);
    
    // Logic for the second 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d);
    
endmodule
"
"
    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
",1.0,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate
    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate
endmodule
"
"
    wire and1_out, and2_out, and3_out, and4_out, or1_out, or2_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b & p2c & p2d;

    assign or1_out = and1_out | and2_out;
    assign or2_out = and3_out | and4_out;

    assign p1y = or1_out;
    assign p2y = or2_out;
    
endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out, or1_out, or2_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b & p2c & p2d;

    assign or1_out = and1_out | and2_out;
    assign or2_out = and3_out | and4_out;

    assign p1y = or1_out;
    assign p2y = or2_out;
    
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out, or1_out, or2_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b & p2c & p2d;

    assign or1_out = and1_out | and2_out;
    assign or2_out = and3_out | and4_out;

    assign p1y = or1_out;
    assign p2y = or2_out;
    
endmodule
"
"// Using assign statement to drive output wires directly

assign p1y = p1a & p1b & p1c & p1d & p1e & p1f;
assign p2y = p2a & p2b & p2c & p2d;

endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
// Using assign statement to drive output wires directly

assign p1y = p1a & p1b & p1c & p1d & p1e & p1f;
assign p2y = p2a & p2b & p2c & p2d;

endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
// Using assign statement to drive output wires directly

assign p1y = p1a & p1b & p1c & p1d & p1e & p1f;
assign p2y = p2a & p2b & p2c & p2d;

endmodule
"
"// Using assign statements to directly drive the output wires

assign p1y = (p1a & p1b & p1c & p1d) | (p1e & p1f);
assign p2y = (p2a & p2b & p2c & p2d); 

endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
// Using assign statements to directly drive the output wires

assign p1y = (p1a & p1b & p1c & p1d) | (p1e & p1f);
assign p2y = (p2a & p2b & p2c & p2d); 

endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
// Using assign statements to directly drive the output wires

assign p1y = (p1a & p1b & p1c & p1d) | (p1e & p1f);
assign p2y = (p2a & p2b & p2c & p2d); 

endmodule
"
"
    wire p1and1, p1and2, p1and3, p1and4, p1or1;

    assign p1and1 = p1a & p1b;
    assign p1and2 = p1c & p1d;
    assign p1and3 = p1e & p1f;
    assign p1and4 = p1and1 & p1and2;
    assign p1or1 = p1and3 | p1and4;

    assign p1y = p1or1;

    wire p2and1, p2and2, p2or1;

    assign p2and1 = p2a & p2b;
    assign p2and2 = p2c & p2d;
    assign p2or1 = p2and1 | p2and2;

    assign p2y = p2or1;
endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire p1and1, p1and2, p1and3, p1and4, p1or1;

    assign p1and1 = p1a & p1b;
    assign p1and2 = p1c & p1d;
    assign p1and3 = p1e & p1f;
    assign p1and4 = p1and1 & p1and2;
    assign p1or1 = p1and3 | p1and4;

    assign p1y = p1or1;

    wire p2and1, p2and2, p2or1;

    assign p2and1 = p2a & p2b;
    assign p2and2 = p2c & p2d;
    assign p2or1 = p2and1 | p2and2;

    assign p2y = p2or1;
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire p1and1, p1and2, p1and3, p1and4, p1or1;

    assign p1and1 = p1a & p1b;
    assign p1and2 = p1c & p1d;
    assign p1and3 = p1e & p1f;
    assign p1and4 = p1and1 & p1and2;
    assign p1or1 = p1and3 | p1and4;

    assign p1y = p1or1;

    wire p2and1, p2and2, p2or1;

    assign p2and1 = p2a & p2b;
    assign p2and2 = p2c & p2d;
    assign p2or1 = p2and1 | p2and2;

    assign p2y = p2or1;
endmodule
"
"
    wire p1_intermediate1, p1_intermediate2, p2_intermediate1, p2_intermediate2;

    assign p1_intermediate1 = p1a & p1b & p1c & p1d;
    assign p1_intermediate2 = p1e & p1f;
    assign p1y = p1_intermediate1 | p1_intermediate2;

    assign p2_intermediate1 = p2a & p2b & p2c;
    assign p2_intermediate2 = p2d;
    assign p2y = p2_intermediate1 | p2_intermediate2;
endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire p1_intermediate1, p1_intermediate2, p2_intermediate1, p2_intermediate2;

    assign p1_intermediate1 = p1a & p1b & p1c & p1d;
    assign p1_intermediate2 = p1e & p1f;
    assign p1y = p1_intermediate1 | p1_intermediate2;

    assign p2_intermediate1 = p2a & p2b & p2c;
    assign p2_intermediate2 = p2d;
    assign p2y = p2_intermediate1 | p2_intermediate2;
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire p1_intermediate1, p1_intermediate2, p2_intermediate1, p2_intermediate2;

    assign p1_intermediate1 = p1a & p1b & p1c & p1d;
    assign p1_intermediate2 = p1e & p1f;
    assign p1y = p1_intermediate1 | p1_intermediate2;

    assign p2_intermediate1 = p2a & p2b & p2c;
    assign p2_intermediate2 = p2d;
    assign p2y = p2_intermediate1 | p2_intermediate2;
endmodule
"
"
    wire and1_out, and2_out, and3_out, and4_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b & p2c & p2d;

    assign p1y = and1_out | and2_out;
    assign p2y = and3_out | and4_out;
endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b & p2c & p2d;

    assign p1y = and1_out | and2_out;
    assign p2y = and3_out | and4_out;
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b & p2c & p2d;

    assign p1y = and1_out | and2_out;
    assign p2y = and3_out | and4_out;
endmodule
"
"
    wire and1_out, and2_out, and3_out, and4_out, or1_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b & p2c & p2d;

    assign or1_out = and1_out | and2_out | and3_out | and4_out;

    assign p1y = or1_out;
    assign p2y = or1_out;
endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out, or1_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b & p2c & p2d;

    assign or1_out = and1_out | and2_out | and3_out | and4_out;

    assign p1y = or1_out;
    assign p2y = or1_out;
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out, or1_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b & p2c & p2d;

    assign or1_out = and1_out | and2_out | and3_out | and4_out;

    assign p1y = or1_out;
    assign p2y = or1_out;
endmodule
"
"
    wire w1, w2, w3, w4;

    assign w1 = p1a & p1b & p1c & p1d;
    assign w2 = p1e & p1f;
    assign w3 = p2a & p2b & p2c & p2d;
    assign w4 = w1 | w2;

    assign p1y = w4;
    assign p2y = w3;
endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire w1, w2, w3, w4;

    assign w1 = p1a & p1b & p1c & p1d;
    assign w2 = p1e & p1f;
    assign w3 = p2a & p2b & p2c & p2d;
    assign w4 = w1 | w2;

    assign p1y = w4;
    assign p2y = w3;
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire w1, w2, w3, w4;

    assign w1 = p1a & p1b & p1c & p1d;
    assign w2 = p1e & p1f;
    assign w3 = p2a & p2b & p2c & p2d;
    assign w4 = w1 | w2;

    assign p1y = w4;
    assign p2y = w3;
endmodule
"
"
    wire and1_out, and2_out, and3_out, and4_out, or1_out, or2_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1d & p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2c & p2d;

    assign or1_out = and1_out | and2_out;
    assign or2_out = and3_out | and4_out;

    assign p1y = or1_out;
    assign p2y = or2_out;

endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out, or1_out, or2_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1d & p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2c & p2d;

    assign or1_out = and1_out | and2_out;
    assign or2_out = and3_out | and4_out;

    assign p1y = or1_out;
    assign p2y = or2_out;

endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out, or1_out, or2_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1d & p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2c & p2d;

    assign or1_out = and1_out | and2_out;
    assign or2_out = and3_out | and4_out;

    assign p1y = or1_out;
    assign p2y = or2_out;

endmodule
"
"
    wire and1_out, and2_out, and3_out, and4_out, or1_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b;

    assign or1_out = and1_out | and2_out | and3_out | and4_out;

    assign p1y = and1_out | and2_out;
    assign p2y = or1_out;
endmodule
",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out, or1_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b;

    assign or1_out = and1_out | and2_out | and3_out | and4_out;

    assign p1y = and1_out | and2_out;
    assign p2y = or1_out;
endmodule
","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire and1_out, and2_out, and3_out, and4_out, or1_out;

    assign and1_out = p1a & p1b & p1c & p1d;
    assign and2_out = p1e & p1f;
    assign and3_out = p2a & p2b & p2c & p2d;
    assign and4_out = p2a & p2b;

    assign or1_out = and1_out | and2_out | and3_out | and4_out;

    assign p1y = and1_out | and2_out;
    assign p2y = or1_out;
endmodule
"
"
    // Internal signals
    reg [99:0] carry;
    reg [99:0] temp_sum;
    
    // Instantiate full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_gen
            full_adder full_adder_inst (
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(temp_sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate
    
    assign sum = temp_sum;
    assign cout = carry[100];
endmodule
",-1.0,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    // Internal signals
    reg [99:0] carry;
    reg [99:0] temp_sum;
    
    // Instantiate full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_gen
            full_adder full_adder_inst (
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(temp_sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate
    
    assign sum = temp_sum;
    assign cout = carry[100];
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    // Internal signals
    reg [99:0] carry;
    reg [99:0] temp_sum;
    
    // Instantiate full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_gen
            full_adder full_adder_inst (
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(temp_sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate
    
    assign sum = temp_sum;
    assign cout = carry[100];
endmodule
"
"
    wire [99:0] carry;
    wire [99:0] temp_sum;
  
    // Instantiate the first full adder
    full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(temp_sum[0]), .cout(carry[0]) );
  
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : gen_loop
            full_adder fa( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(temp_sum[i]), .cout(carry[i]) );
        end
    endgenerate
  
    assign sum = temp_sum;
    assign cout = carry[99];
  
endmodule
",-1.0,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] carry;
    wire [99:0] temp_sum;
  
    // Instantiate the first full adder
    full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(temp_sum[0]), .cout(carry[0]) );
  
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : gen_loop
            full_adder fa( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(temp_sum[i]), .cout(carry[i]) );
        end
    endgenerate
  
    assign sum = temp_sum;
    assign cout = carry[99];
  
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] carry;
    wire [99:0] temp_sum;
  
    // Instantiate the first full adder
    full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(temp_sum[0]), .cout(carry[0]) );
  
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : gen_loop
            full_adder fa( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(temp_sum[i]), .cout(carry[i]) );
        end
    endgenerate
  
    assign sum = temp_sum;
    assign cout = carry[99];
  
endmodule
"
"
    // Internal signals
    reg [99:0] carry;
    reg [99:0] s;
    
    // Adder logic
    always @(*) begin
        carry[0] = cin;
        for (int i = 0; i < 100; i = i + 1) begin
            if (i == 0) begin
                s[i] = a[i] ^ b[i] ^ cin;
            end else begin
                s[i] = a[i] ^ b[i] ^ carry[i-1];
            end
            carry[i] = (a[i] & b[i]) | (a[i] & carry[i-1]) | (b[i] & carry[i-1]);
        end
    end
    
    // Output signals
    assign sum = s;
    assign cout = carry[99];
    
endmodule
",-0.5,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    // Internal signals
    reg [99:0] carry;
    reg [99:0] s;
    
    // Adder logic
    always @(*) begin
        carry[0] = cin;
        for (int i = 0; i < 100; i = i + 1) begin
            if (i == 0) begin
                s[i] = a[i] ^ b[i] ^ cin;
            end else begin
                s[i] = a[i] ^ b[i] ^ carry[i-1];
            end
            carry[i] = (a[i] & b[i]) | (a[i] & carry[i-1]) | (b[i] & carry[i-1]);
        end
    end
    
    // Output signals
    assign sum = s;
    assign cout = carry[99];
    
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    // Internal signals
    reg [99:0] carry;
    reg [99:0] s;
    
    // Adder logic
    always @(*) begin
        carry[0] = cin;
        for (int i = 0; i < 100; i = i + 1) begin
            if (i == 0) begin
                s[i] = a[i] ^ b[i] ^ cin;
            end else begin
                s[i] = a[i] ^ b[i] ^ carry[i-1];
            end
            carry[i] = (a[i] & b[i]) | (a[i] & carry[i-1]) | (b[i] & carry[i-1]);
        end
    end
    
    // Output signals
    assign sum = s;
    assign cout = carry[99];
    
endmodule
"
"    wire [99:0] carry;
    
    // First full adder
    full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Remaining full adders
    genvar i;
    generate
        for (i = 1; i < 100; i=i+1) begin : gen_fa
            full_adder fa( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule
",-1.0,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    wire [99:0] carry;
    
    // First full adder
    full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Remaining full adders
    genvar i;
    generate
        for (i = 1; i < 100; i=i+1) begin : gen_fa
            full_adder fa( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    wire [99:0] carry;
    
    // First full adder
    full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Remaining full adders
    genvar i;
    generate
        for (i = 1; i < 100; i=i+1) begin : gen_fa
            full_adder fa( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule
"
"
    // Internal signals
    reg [99:0] carry;
    
    // Instantiate the first full adder
    full_adder FA0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : FA_loop
            full_adder FA( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    // Output carry out
    assign cout = carry[99];
    
endmodule
",-1.0,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    // Internal signals
    reg [99:0] carry;
    
    // Instantiate the first full adder
    full_adder FA0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : FA_loop
            full_adder FA( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    // Output carry out
    assign cout = carry[99];
    
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    // Internal signals
    reg [99:0] carry;
    
    // Instantiate the first full adder
    full_adder FA0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : FA_loop
            full_adder FA( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    // Output carry out
    assign cout = carry[99];
    
endmodule
"
"
    // Internal signals
    reg [99:0] carry;
    
    // Instantiate the first full adder
    full_adder FA0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : ADDER_LOOP
            full_adder FA( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    // Output carry out
    assign cout = carry[99];  
endmodule
",-1.0,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    // Internal signals
    reg [99:0] carry;
    
    // Instantiate the first full adder
    full_adder FA0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : ADDER_LOOP
            full_adder FA( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    // Output carry out
    assign cout = carry[99];  
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    // Internal signals
    reg [99:0] carry;
    
    // Instantiate the first full adder
    full_adder FA0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : ADDER_LOOP
            full_adder FA( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    // Output carry out
    assign cout = carry[99];  
endmodule
"
"    wire [99:0] carry;
    
    // instantiate the first full adder
    full_adder FA0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : gen_fa
            full_adder FA( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule
",-1.0,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    wire [99:0] carry;
    
    // instantiate the first full adder
    full_adder FA0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : gen_fa
            full_adder FA( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    wire [99:0] carry;
    
    // instantiate the first full adder
    full_adder FA0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : gen_fa
            full_adder FA( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule
"
"
    wire [99:0] carry;
    
    // Instantiate 100 full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : adder_loop
            full_adder full_adder_inst(
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate
    
    assign cout = carry[100];
endmodule
",-1.0,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] carry;
    
    // Instantiate 100 full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : adder_loop
            full_adder full_adder_inst(
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate
    
    assign cout = carry[100];
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] carry;
    
    // Instantiate 100 full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : adder_loop
            full_adder full_adder_inst(
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate
    
    assign cout = carry[100];
endmodule
"
"
    wire [99:0] carry;
    wire [99:0] temp_sum;
    
    assign carry[0] = cin;
    
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_gen
            full_adder fa(
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(temp_sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate
    
    assign sum = temp_sum;
    assign cout = carry[100];
    
endmodule
",-1.0,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] carry;
    wire [99:0] temp_sum;
    
    assign carry[0] = cin;
    
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_gen
            full_adder fa(
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(temp_sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate
    
    assign sum = temp_sum;
    assign cout = carry[100];
    
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] carry;
    wire [99:0] temp_sum;
    
    assign carry[0] = cin;
    
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_gen
            full_adder fa(
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(temp_sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate
    
    assign sum = temp_sum;
    assign cout = carry[100];
    
endmodule
"
"    wire [99:0] carry;
    
    // Instantiate the first full adder
    full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i+1) begin : gen_full_adder
            full_adder fa( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule
",-1.0,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    wire [99:0] carry;
    
    // Instantiate the first full adder
    full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i+1) begin : gen_full_adder
            full_adder fa( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    wire [99:0] carry;
    
    // Instantiate the first full adder
    full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]) );
    
    // Instantiate the rest of the full adders in a loop
    genvar i;
    generate
        for (i = 1; i < 100; i = i+1) begin : gen_full_adder
            full_adder fa( .a(a[i]), .b(b[i]), .cin(carry[i-1]), .sum(sum[i]), .cout(carry[i]) );
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule
"
"
    wire [99:0] c;
    wire [99:0] s;

    full_adder fa[99:0](
        .a(a),
        .b(b),
        .cin(cin),
        .cout(c),
        .sum(s)
    );

    assign cout = c;
    assign sum = s;
endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] c;
    wire [99:0] s;

    full_adder fa[99:0](
        .a(a),
        .b(b),
        .cin(cin),
        .cout(c),
        .sum(s)
    );

    assign cout = c;
    assign sum = s;
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] c;
    wire [99:0] s;

    full_adder fa[99:0](
        .a(a),
        .b(b),
        .cin(cin),
        .cout(c),
        .sum(s)
    );

    assign cout = c;
    assign sum = s;
endmodule
"
"
    wire [99:0] carry;
    wire [99:0] temp_sum;
    wire temp_cout;

    full_adder full_adder_inst[99:0](
        .a(a[99:0]),
        .b(b[99:0]),
        .cin(cin),
        .sum(temp_sum[99:0]),
        .cout({temp_cout, carry[98:0]})
    );

    assign sum = temp_sum;
    assign cout = {temp_cout, carry};
endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] carry;
    wire [99:0] temp_sum;
    wire temp_cout;

    full_adder full_adder_inst[99:0](
        .a(a[99:0]),
        .b(b[99:0]),
        .cin(cin),
        .sum(temp_sum[99:0]),
        .cout({temp_cout, carry[98:0]})
    );

    assign sum = temp_sum;
    assign cout = {temp_cout, carry};
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] carry;
    wire [99:0] temp_sum;
    wire temp_cout;

    full_adder full_adder_inst[99:0](
        .a(a[99:0]),
        .b(b[99:0]),
        .cin(cin),
        .sum(temp_sum[99:0]),
        .cout({temp_cout, carry[98:0]})
    );

    assign sum = temp_sum;
    assign cout = {temp_cout, carry};
endmodule
"
"// Define a full adder module
module full_adder(
    input a, b, cin,
    output sum, cout
);

    assign {cout, sum} = a + b + cin;

endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
// Define a full adder module
module full_adder(
    input a, b, cin,
    output sum, cout
);

    assign {cout, sum} = a + b + cin;

endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
// Define a full adder module
module full_adder(
    input a, b, cin,
    output sum, cout
);

    assign {cout, sum} = a + b + cin;

endmodule
"
"
    wire [99:0] c;
    wire [99:0] s;
    
    full_adder fa[99:0](.a(a), .b(b), .cin(cin), .cout(c), .sum(s));
    
    assign cout = c;
    assign sum = s;
    
endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] c;
    wire [99:0] s;
    
    full_adder fa[99:0](.a(a), .b(b), .cin(cin), .cout(c), .sum(s));
    
    assign cout = c;
    assign sum = s;
    
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] c;
    wire [99:0] s;
    
    full_adder fa[99:0](.a(a), .b(b), .cin(cin), .cout(c), .sum(s));
    
    assign cout = c;
    assign sum = s;
    
endmodule
"
"
    wire [99:0] carry;
    wire [99:0] temp_sum;

    full_adder full_adders[99:0](
        .a(a),
        .b(b),
        .cin(cin),
        .cout(carry),
        .sum(temp_sum)
    );

    assign cout[0] = carry[0];
    assign sum[0] = temp_sum[0];

    generate
        genvar i;
        for(i = 1; i < 100; i = i + 1) begin: adder_loop
            assign cout[i] = carry[i];
            assign sum[i] = temp_sum[i];
        end
    endgenerate

endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] carry;
    wire [99:0] temp_sum;

    full_adder full_adders[99:0](
        .a(a),
        .b(b),
        .cin(cin),
        .cout(carry),
        .sum(temp_sum)
    );

    assign cout[0] = carry[0];
    assign sum[0] = temp_sum[0];

    generate
        genvar i;
        for(i = 1; i < 100; i = i + 1) begin: adder_loop
            assign cout[i] = carry[i];
            assign sum[i] = temp_sum[i];
        end
    endgenerate

endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] carry;
    wire [99:0] temp_sum;

    full_adder full_adders[99:0](
        .a(a),
        .b(b),
        .cin(cin),
        .cout(carry),
        .sum(temp_sum)
    );

    assign cout[0] = carry[0];
    assign sum[0] = temp_sum[0];

    generate
        genvar i;
        for(i = 1; i < 100; i = i + 1) begin: adder_loop
            assign cout[i] = carry[i];
            assign sum[i] = temp_sum[i];
        end
    endgenerate

endmodule
"
"
  // Instantiate 100 full adders
  genvar i;
  generate
    for (i = 0; i < 100; i=i+1) begin : full_adder_inst
      full_adder full_adder_inst (
        .a(a[i]),
        .b(b[i]),
        .cin(cin),
        .cout(cout[i]),
        .sum(sum[i])
      );
    end
  endgenerate

endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

  // Instantiate 100 full adders
  genvar i;
  generate
    for (i = 0; i < 100; i=i+1) begin : full_adder_inst
      full_adder full_adder_inst (
        .a(a[i]),
        .b(b[i]),
        .cin(cin),
        .cout(cout[i]),
        .sum(sum[i])
      );
    end
  endgenerate

endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

  // Instantiate 100 full adders
  genvar i;
  generate
    for (i = 0; i < 100; i=i+1) begin : full_adder_inst
      full_adder full_adder_inst (
        .a(a[i]),
        .b(b[i]),
        .cin(cin),
        .cout(cout[i]),
        .sum(sum[i])
      );
    end
  endgenerate

endmodule
"
"
    wire [99:0] c;
    wire [99:0] s;

    full_adder fa[99:0](
        .a(a),
        .b(b),
        .cin(cin),
        .cout(c),
        .sum(s)
    );

    assign cout = c;
    assign sum = s;
endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] c;
    wire [99:0] s;

    full_adder fa[99:0](
        .a(a),
        .b(b),
        .cin(cin),
        .cout(c),
        .sum(s)
    );

    assign cout = c;
    assign sum = s;
endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] c;
    wire [99:0] s;

    full_adder fa[99:0](
        .a(a),
        .b(b),
        .cin(cin),
        .cout(c),
        .sum(s)
    );

    assign cout = c;
    assign sum = s;
endmodule
"
"
    // Instantiate 100 full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_inst
            full_adder full_adder_inst (
                .a(a[i]),
                .b(b[i]),
                .cin(cin),
                .cout(cout[i]),
                .sum(sum[i])
            );
        end
    endgenerate

endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    // Instantiate 100 full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_inst
            full_adder full_adder_inst (
                .a(a[i]),
                .b(b[i]),
                .cin(cin),
                .cout(cout[i]),
                .sum(sum[i])
            );
        end
    endgenerate

endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    // Instantiate 100 full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_inst
            full_adder full_adder_inst (
                .a(a[i]),
                .b(b[i]),
                .cin(cin),
                .cout(cout[i]),
                .sum(sum[i])
            );
        end
    endgenerate

endmodule
"
"
    // Instantiate 100 full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_inst
            full_adder full_adder_inst (
                .a(a[i]),
                .b(b[i]),
                .cin(cin),
                .cout(cout[i]),
                .sum(sum[i])
            );
        end
    endgenerate

endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    // Instantiate 100 full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_inst
            full_adder full_adder_inst (
                .a(a[i]),
                .b(b[i]),
                .cin(cin),
                .cout(cout[i]),
                .sum(sum[i])
            );
        end
    endgenerate

endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    // Instantiate 100 full adders
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : full_adder_inst
            full_adder full_adder_inst (
                .a(a[i]),
                .b(b[i]),
                .cin(cin),
                .cout(cout[i]),
                .sum(sum[i])
            );
        end
    endgenerate

endmodule
"
"
  // Instantiate 100 full adders
  genvar i;
  generate
    for (i = 0; i < 100; i = i + 1) begin : full_adder_inst
      full_adder full_adder_inst (
        .a(a[i]),
        .b(b[i]),
        .cin(cin),
        .cout(cout[i]),
        .sum(sum[i])
      );
    end
  endgenerate

endmodule
",-1.0,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

  // Instantiate 100 full adders
  genvar i;
  generate
    for (i = 0; i < 100; i = i + 1) begin : full_adder_inst
      full_adder full_adder_inst (
        .a(a[i]),
        .b(b[i]),
        .cin(cin),
        .cout(cout[i]),
        .sum(sum[i])
      );
    end
  endgenerate

endmodule
","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

  // Instantiate 100 full adders
  genvar i;
  generate
    for (i = 0; i < 100; i = i + 1) begin : full_adder_inst
      full_adder full_adder_inst (
        .a(a[i]),
        .b(b[i]),
        .cin(cin),
        .cout(cout[i]),
        .sum(sum[i])
      );
    end
  endgenerate

endmodule
"
"// Instantiate 3 full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate 3 full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate 3 full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
"
"// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
"
"// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .cout(cout[1]), .sum(sum[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .cout(cout[2]), .sum(sum[2])); 

endmodule
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .cout(cout[1]), .sum(sum[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .cout(cout[2]), .sum(sum[2])); 

endmodule
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .cout(cout[1]), .sum(sum[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .cout(cout[2]), .sum(sum[2])); 

endmodule
"
"// Instantiate three full adders
full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]) );
full_adder fa1( .a(a[1]), .b(b[1]), .cin(fa0.cout), .sum(sum[1]), .cout(cout[1]) );
full_adder fa2( .a(a[2]), .b(b[2]), .cin(fa1.cout), .sum(sum[2]), .cout(cout[2]) ); 

endmodule
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]) );
full_adder fa1( .a(a[1]), .b(b[1]), .cin(fa0.cout), .sum(sum[1]), .cout(cout[1]) );
full_adder fa2( .a(a[2]), .b(b[2]), .cin(fa1.cout), .sum(sum[2]), .cout(cout[2]) ); 

endmodule
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]) );
full_adder fa1( .a(a[1]), .b(b[1]), .cin(fa0.cout), .sum(sum[1]), .cout(cout[1]) );
full_adder fa2( .a(a[2]), .b(b[2]), .cin(fa1.cout), .sum(sum[2]), .cout(cout[2]) ); 

endmodule
"
"// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
"
"// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]));
"
"// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .cout(cout[1]), .sum(sum[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .cout(cout[2]), .sum(sum[2])); 

endmodule
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .cout(cout[1]), .sum(sum[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .cout(cout[2]), .sum(sum[2])); 

endmodule
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .cout(cout[1]), .sum(sum[1]));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .cout(cout[2]), .sum(sum[2])); 

endmodule
"
"// Instantiate 3 full adders
full_adder fa0(
    .a(a[0]),
    .b(b[0]),
    .cin(cin),
    .sum(sum[0]),
    .cout(cout[0])
);

full_adder fa1(
    .a(a[1]),
    .b(b[1]),
    .cin(fa0.cout),
    .sum(sum[1]),
    .cout(cout[1])
);

full_adder fa2(
    .a(a[2]),
    .b(b[2]),
    .cin(fa1.cout),
    .sum(sum[2]),
    .cout(cout[2])
); 

endmodule
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate 3 full adders
full_adder fa0(
    .a(a[0]),
    .b(b[0]),
    .cin(cin),
    .sum(sum[0]),
    .cout(cout[0])
);

full_adder fa1(
    .a(a[1]),
    .b(b[1]),
    .cin(fa0.cout),
    .sum(sum[1]),
    .cout(cout[1])
);

full_adder fa2(
    .a(a[2]),
    .b(b[2]),
    .cin(fa1.cout),
    .sum(sum[2]),
    .cout(cout[2])
); 

endmodule
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate 3 full adders
full_adder fa0(
    .a(a[0]),
    .b(b[0]),
    .cin(cin),
    .sum(sum[0]),
    .cout(cout[0])
);

full_adder fa1(
    .a(a[1]),
    .b(b[1]),
    .cin(fa0.cout),
    .sum(sum[1]),
    .cout(cout[1])
);

full_adder fa2(
    .a(a[2]),
    .b(b[2]),
    .cin(fa1.cout),
    .sum(sum[2]),
    .cout(cout[2])
); 

endmodule
"
"// Instantiate three full adders
full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]) );
full_adder fa1( .a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]) );
full_adder fa2( .a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]) ); 

endmodule
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]) );
full_adder fa1( .a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]) );
full_adder fa2( .a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]) ); 

endmodule
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(cout[0]) );
full_adder fa1( .a(a[1]), .b(b[1]), .cin(cout[0]), .sum(sum[1]), .cout(cout[1]) );
full_adder fa2( .a(a[2]), .b(b[2]), .cin(cout[1]), .sum(sum[2]), .cout(cout[2]) ); 

endmodule
"
"// Instantiate three full adders
full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]) );
full_adder fa1( .a(a[1]), .b(b[1]), .cin(fa0.cout), .cout(cout[1]), .sum(sum[1]) );
full_adder fa2( .a(a[2]), .b(b[2]), .cin(fa1.cout), .cout(cout[2]), .sum(sum[2]) );
",-1.0,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]) );
full_adder fa1( .a(a[1]), .b(b[1]), .cin(fa0.cout), .cout(cout[1]), .sum(sum[1]) );
full_adder fa2( .a(a[2]), .b(b[2]), .cin(fa1.cout), .cout(cout[2]), .sum(sum[2]) );
","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );


// Instantiate three full adders
full_adder fa0( .a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]) );
full_adder fa1( .a(a[1]), .b(b[1]), .cin(fa0.cout), .cout(cout[1]), .sum(sum[1]) );
full_adder fa2( .a(a[2]), .b(b[2]), .cin(fa1.cout), .cout(cout[2]), .sum(sum[2]) );
"
"// Using assign statement
assign out_assign = a & b;

// Using combinational always block
always @(*) begin
    out_alwaysblock = a & b;
end

endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

// Using assign statement
assign out_assign = a & b;

// Using combinational always block
always @(*) begin
    out_alwaysblock = a & b;
end

endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

// Using assign statement
assign out_assign = a & b;

// Using combinational always block
always @(*) begin
    out_alwaysblock = a & b;
end

endmodule
"
"    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @* begin
        out_alwaysblock = a & b;
    end
endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @* begin
        out_alwaysblock = a & b;
    end
endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @* begin
        out_alwaysblock = a & b;
    end
endmodule
"
"    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @*
    begin
        out_alwaysblock = a & b;
    end
endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @*
    begin
        out_alwaysblock = a & b;
    end
endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @*
    begin
        out_alwaysblock = a & b;
    end
endmodule
"
"    // Using assign statement
    assign out_assign = a & b;
    
    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;
    
    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;
    
    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
"
"    // Using assign statement
    assign out_assign = a & b;
    
    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;
    
    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;
    
    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
"
"    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
"
"    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
"
"    // Using assign statement
    assign out_assign = a & b;
    
    // Using combinational always block
    always @*
    begin
        out_alwaysblock = a & b;
    end
endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;
    
    // Using combinational always block
    always @*
    begin
        out_alwaysblock = a & b;
    end
endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;
    
    // Using combinational always block
    always @*
    begin
        out_alwaysblock = a & b;
    end
endmodule
"
"    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule
"
"    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @* begin
        out_alwaysblock = a & b;
    end
endmodule
",1.0,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @* begin
        out_alwaysblock = a & b;
    end
endmodule
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    // Using assign statement
    assign out_assign = a & b;

    // Using combinational always block
    always @* begin
        out_alwaysblock = a & b;
    end
endmodule
"
"// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @*
begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk)
begin
    out_always_ff <= a ^ b;
end

endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @*
begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk)
begin
    out_always_ff <= a ^ b;
end

endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @*
begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk)
begin
    out_always_ff <= a ^ b;
end

endmodule
"
"
    // Assign statement
    assign out_assign = a ^ b;

    // Combinational always block
    always @* begin
        out_always_comb = a ^ b;
    end

    // Clocked always block
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Assign statement
    assign out_assign = a ^ b;

    // Combinational always block
    always @* begin
        out_always_comb = a ^ b;
    end

    // Clocked always block
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Assign statement
    assign out_assign = a ^ b;

    // Combinational always block
    always @* begin
        out_always_comb = a ^ b;
    end

    // Clocked always block
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
endmodule
"
"
    // Assign statement
    assign out_assign = a ^ b;

    // Combinational always block
    always @* begin
        out_always_comb = a ^ b;
    end

    // Clocked always block
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Assign statement
    assign out_assign = a ^ b;

    // Combinational always block
    always @* begin
        out_always_comb = a ^ b;
    end

    // Clocked always block
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Assign statement
    assign out_assign = a ^ b;

    // Combinational always block
    always @* begin
        out_always_comb = a ^ b;
    end

    // Clocked always block
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
endmodule
"
"// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @*
begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk)
begin
    out_always_ff <= a ^ b;
end

endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @*
begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk)
begin
    out_always_ff <= a ^ b;
end

endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @*
begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk)
begin
    out_always_ff <= a ^ b;
end

endmodule
"
"
    // Using assign statement
    assign out_assign = a ^ b;
    
    // Using combinational always block
    always @*
    begin
        out_always_comb = a ^ b;
    end
    
    // Using clocked always block
    always @(posedge clk)
    begin
        out_always_ff <= a ^ b;
    end
endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Using assign statement
    assign out_assign = a ^ b;
    
    // Using combinational always block
    always @*
    begin
        out_always_comb = a ^ b;
    end
    
    // Using clocked always block
    always @(posedge clk)
    begin
        out_always_ff <= a ^ b;
    end
endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Using assign statement
    assign out_assign = a ^ b;
    
    // Using combinational always block
    always @*
    begin
        out_always_comb = a ^ b;
    end
    
    // Using clocked always block
    always @(posedge clk)
    begin
        out_always_ff <= a ^ b;
    end
endmodule
"
"
    // Using assign statement
    assign out_assign = a ^ b;

    // Using combinational always block
    always @*
    begin
        out_always_comb = a ^ b;
    end

    // Using clocked always block
    always @(posedge clk)
    begin
        out_always_ff <= a ^ b;
    end
endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Using assign statement
    assign out_assign = a ^ b;

    // Using combinational always block
    always @*
    begin
        out_always_comb = a ^ b;
    end

    // Using clocked always block
    always @(posedge clk)
    begin
        out_always_ff <= a ^ b;
    end
endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Using assign statement
    assign out_assign = a ^ b;

    // Using combinational always block
    always @*
    begin
        out_always_comb = a ^ b;
    end

    // Using clocked always block
    always @(posedge clk)
    begin
        out_always_ff <= a ^ b;
    end
endmodule
"
"// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @(*) begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk) begin
    out_always_ff <= a ^ b;
end

endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @(*) begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk) begin
    out_always_ff <= a ^ b;
end

endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @(*) begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk) begin
    out_always_ff <= a ^ b;
end

endmodule
"
"// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @*
begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk)
begin
    out_always_ff <= a ^ b;
end

endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @*
begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk)
begin
    out_always_ff <= a ^ b;
end

endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
// Using assign statement
assign out_assign = a ^ b;

// Using combinational always block
always @*
begin
    out_always_comb = a ^ b;
end

// Using clocked always block
always @(posedge clk)
begin
    out_always_ff <= a ^ b;
end

endmodule
"
"
    // Assign statement
    assign out_assign = a ^ b;

    // Combinational always block
    always @* begin
        out_always_comb = a ^ b;
    end

    // Clocked always block
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Assign statement
    assign out_assign = a ^ b;

    // Combinational always block
    always @* begin
        out_always_comb = a ^ b;
    end

    // Clocked always block
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    // Assign statement
    assign out_assign = a ^ b;

    // Combinational always block
    always @* begin
        out_always_comb = a ^ b;
    end

    // Clocked always block
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
endmodule
"
"    // Using assign statement
    assign out_assign = a ^ b;

    // Using combinational always block
    always @*
    begin
        out_always_comb = a ^ b;
    end

    // Using clocked always block
    always @(posedge clk)
    begin
        out_always_ff <= a ^ b;
    end
endmodule
",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    // Using assign statement
    assign out_assign = a ^ b;

    // Using combinational always block
    always @*
    begin
        out_always_comb = a ^ b;
    end

    // Using clocked always block
    always @(posedge clk)
    begin
        out_always_ff <= a ^ b;
    end
endmodule
","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    // Using assign statement
    assign out_assign = a ^ b;

    // Using combinational always block
    always @*
    begin
        out_always_comb = a ^ b;
    end

    // Using clocked always block
    always @(posedge clk)
    begin
        out_always_ff <= a ^ b;
    end
endmodule
"
"        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
"
"        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
"
"        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
"
"        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
endmodule
"
"        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
endmodule
"
"        case(sel)
            0: out = data0;
            1: out = data1;
            2: out = data2;
            3: out = data3;
            4: out = data4;
            5: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            0: out = data0;
            1: out = data1;
            2: out = data2;
            3: out = data3;
            4: out = data4;
            5: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            0: out = data0;
            1: out = data1;
            2: out = data2;
            3: out = data3;
            4: out = data4;
            5: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
"
"        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
endmodule
"
"        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
"
"        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
"
"        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
",1.0,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit

        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
            default: pos = 2'b00;
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
            default: pos = 2'b00;
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
            default: pos = 2'b00;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            4'b0000: pos = 2'b00; // input is zero
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b10;
            4'b0011: pos = 2'b11;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b11;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b00;
            4'b1001: pos = 2'b01;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b10;
            4'b1100: pos = 2'b01;
            4'b1101: pos = 2'b10;
            4'b1110: pos = 2'b10;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00; // input is zero
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b10;
            4'b0011: pos = 2'b11;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b11;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b00;
            4'b1001: pos = 2'b01;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b10;
            4'b1100: pos = 2'b01;
            4'b1101: pos = 2'b10;
            4'b1110: pos = 2'b10;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00; // input is zero
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b10;
            4'b0011: pos = 2'b11;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b11;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b00;
            4'b1001: pos = 2'b01;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b10;
            4'b1100: pos = 2'b01;
            4'b1101: pos = 2'b10;
            4'b1110: pos = 2'b10;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            4'h1: pos = 2'b00;
            4'h2: pos = 2'b01;
            4'h3: pos = 2'b10;
            4'h4: pos = 2'b11;
            4'h5: pos = 2'b00;
            4'h6: pos = 2'b00;
            4'h7: pos = 2'b00;
            4'h8: pos = 2'b00;
            4'h9: pos = 2'b00;
            4'ha: pos = 2'b00;
            4'hb: pos = 2'b00;
            4'hc: pos = 2'b00;
            4'hd: pos = 2'b00;
            4'he: pos = 2'b00;
            4'hf: pos = 2'b00;
            default: pos = 2'b00;
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'h1: pos = 2'b00;
            4'h2: pos = 2'b01;
            4'h3: pos = 2'b10;
            4'h4: pos = 2'b11;
            4'h5: pos = 2'b00;
            4'h6: pos = 2'b00;
            4'h7: pos = 2'b00;
            4'h8: pos = 2'b00;
            4'h9: pos = 2'b00;
            4'ha: pos = 2'b00;
            4'hb: pos = 2'b00;
            4'hc: pos = 2'b00;
            4'hd: pos = 2'b00;
            4'he: pos = 2'b00;
            4'hf: pos = 2'b00;
            default: pos = 2'b00;
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'h1: pos = 2'b00;
            4'h2: pos = 2'b01;
            4'h3: pos = 2'b10;
            4'h4: pos = 2'b11;
            4'h5: pos = 2'b00;
            4'h6: pos = 2'b00;
            4'h7: pos = 2'b00;
            4'h8: pos = 2'b00;
            4'h9: pos = 2'b00;
            4'ha: pos = 2'b00;
            4'hb: pos = 2'b00;
            4'hc: pos = 2'b00;
            4'hd: pos = 2'b00;
            4'he: pos = 2'b00;
            4'hf: pos = 2'b00;
            default: pos = 2'b00;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            4'h1: pos = 2'b00;
            4'h2: pos = 2'b01;
            4'h3: pos = 2'b10;
            4'h4: pos = 2'b11;
            4'h5: pos = 2'b00;
            4'h6: pos = 2'b00;
            4'h7: pos = 2'b00;
            4'h8: pos = 2'b00;
            4'h9: pos = 2'b00;
            4'ha: pos = 2'b00;
            4'hb: pos = 2'b00;
            4'hc: pos = 2'b00;
            4'hd: pos = 2'b00;
            4'he: pos = 2'b00;
            4'hf: pos = 2'b00;
            default: pos = 2'b00;
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'h1: pos = 2'b00;
            4'h2: pos = 2'b01;
            4'h3: pos = 2'b10;
            4'h4: pos = 2'b11;
            4'h5: pos = 2'b00;
            4'h6: pos = 2'b00;
            4'h7: pos = 2'b00;
            4'h8: pos = 2'b00;
            4'h9: pos = 2'b00;
            4'ha: pos = 2'b00;
            4'hb: pos = 2'b00;
            4'hc: pos = 2'b00;
            4'hd: pos = 2'b00;
            4'he: pos = 2'b00;
            4'hf: pos = 2'b00;
            default: pos = 2'b00;
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'h1: pos = 2'b00;
            4'h2: pos = 2'b01;
            4'h3: pos = 2'b10;
            4'h4: pos = 2'b11;
            4'h5: pos = 2'b00;
            4'h6: pos = 2'b00;
            4'h7: pos = 2'b00;
            4'h8: pos = 2'b00;
            4'h9: pos = 2'b00;
            4'ha: pos = 2'b00;
            4'hb: pos = 2'b00;
            4'hc: pos = 2'b00;
            4'hd: pos = 2'b00;
            4'he: pos = 2'b00;
            4'hf: pos = 2'b00;
            default: pos = 2'b00;
        endcase
    end
endmodule
"
"    always @(*) begin
        case(in)
            4'b0000: pos = 2'b00; // Input is zero, output is zero
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b10;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b11;
            4'b0101: pos = 2'b11;
            4'b0110: pos = 2'b11;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b00;
            4'b1001: pos = 2'b01;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b10;
            4'b1100: pos = 2'b11;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @(*) begin
        case(in)
            4'b0000: pos = 2'b00; // Input is zero, output is zero
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b10;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b11;
            4'b0101: pos = 2'b11;
            4'b0110: pos = 2'b11;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b00;
            4'b1001: pos = 2'b01;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b10;
            4'b1100: pos = 2'b11;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @(*) begin
        case(in)
            4'b0000: pos = 2'b00; // Input is zero, output is zero
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b10;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b11;
            4'b0101: pos = 2'b11;
            4'b0110: pos = 2'b11;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b00;
            4'b1001: pos = 2'b01;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b10;
            4'b1100: pos = 2'b11;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'b0000: pos = 2'b00;
            4'b0001: pos = 2'b01;
            4'b0010: pos = 2'b01;
            4'b0011: pos = 2'b10;
            4'b0100: pos = 2'b01;
            4'b0101: pos = 2'b10;
            4'b0110: pos = 2'b10;
            4'b0111: pos = 2'b11;
            4'b1000: pos = 2'b01;
            4'b1001: pos = 2'b10;
            4'b1010: pos = 2'b10;
            4'b1011: pos = 2'b11;
            4'b1100: pos = 2'b10;
            4'b1101: pos = 2'b11;
            4'b1110: pos = 2'b11;
            4'b1111: pos = 2'b11;
        endcase
    end
endmodule
"
"    always @(*) begin
        case(in)
            4'b0000: pos = 2'b00; // If input is 0000, output is 00
            4'b0001: pos = 2'b01; // If input is 0001, output is 01
            4'b0010: pos = 2'b01; // If input is 0010, output is 01
            4'b0011: pos = 2'b10; // If input is 0011, output is 10
            4'b0100: pos = 2'b01; // If input is 0100, output is 01
            4'b0101: pos = 2'b10; // If input is 0101, output is 10
            4'b0110: pos = 2'b10; // If input is 0110, output is 10
            4'b0111: pos = 2'b11; // If input is 0111, output is 11
            4'b1000: pos = 2'b01; // If input is 1000, output is 01
            4'b1001: pos = 2'b10; // If input is 1001, output is 10
            4'b1010: pos = 2'b10; // If input is 1010, output is 10
            4'b1011: pos = 2'b11; // If input is 1011, output is 11
            4'b1100: pos = 2'b10; // If input is 1100, output is 10
            4'b1101: pos = 2'b11; // If input is 1101, output is 11
            4'b1110: pos = 2'b11; // If input is 1110, output is 11
            4'b1111: pos = 2'b11; // If input is 1111, output is 11
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @(*) begin
        case(in)
            4'b0000: pos = 2'b00; // If input is 0000, output is 00
            4'b0001: pos = 2'b01; // If input is 0001, output is 01
            4'b0010: pos = 2'b01; // If input is 0010, output is 01
            4'b0011: pos = 2'b10; // If input is 0011, output is 10
            4'b0100: pos = 2'b01; // If input is 0100, output is 01
            4'b0101: pos = 2'b10; // If input is 0101, output is 10
            4'b0110: pos = 2'b10; // If input is 0110, output is 10
            4'b0111: pos = 2'b11; // If input is 0111, output is 11
            4'b1000: pos = 2'b01; // If input is 1000, output is 01
            4'b1001: pos = 2'b10; // If input is 1001, output is 10
            4'b1010: pos = 2'b10; // If input is 1010, output is 10
            4'b1011: pos = 2'b11; // If input is 1011, output is 11
            4'b1100: pos = 2'b10; // If input is 1100, output is 10
            4'b1101: pos = 2'b11; // If input is 1101, output is 11
            4'b1110: pos = 2'b11; // If input is 1110, output is 11
            4'b1111: pos = 2'b11; // If input is 1111, output is 11
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @(*) begin
        case(in)
            4'b0000: pos = 2'b00; // If input is 0000, output is 00
            4'b0001: pos = 2'b01; // If input is 0001, output is 01
            4'b0010: pos = 2'b01; // If input is 0010, output is 01
            4'b0011: pos = 2'b10; // If input is 0011, output is 10
            4'b0100: pos = 2'b01; // If input is 0100, output is 01
            4'b0101: pos = 2'b10; // If input is 0101, output is 10
            4'b0110: pos = 2'b10; // If input is 0110, output is 10
            4'b0111: pos = 2'b11; // If input is 0111, output is 11
            4'b1000: pos = 2'b01; // If input is 1000, output is 01
            4'b1001: pos = 2'b10; // If input is 1001, output is 10
            4'b1010: pos = 2'b10; // If input is 1010, output is 10
            4'b1011: pos = 2'b11; // If input is 1011, output is 11
            4'b1100: pos = 2'b10; // If input is 1100, output is 10
            4'b1101: pos = 2'b11; // If input is 1101, output is 11
            4'b1110: pos = 2'b11; // If input is 1110, output is 11
            4'b1111: pos = 2'b11; // If input is 1111, output is 11
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            4'h1: pos = 2'h1;
            4'h2: pos = 2'h2;
            4'h3: pos = 2'h3;
            4'h4: pos = 2'h4;
            4'h5: pos = 2'h1;
            4'h6: pos = 2'h2;
            4'h7: pos = 2'h3;
            4'h8: pos = 2'h4;
            4'h9: pos = 2'h1;
            4'ha: pos = 2'h2;
            4'hb: pos = 2'h3;
            4'hc: pos = 2'h4;
            4'hd: pos = 2'h1;
            4'he: pos = 2'h2;
            4'hf: pos = 2'h3;
            default: pos = 2'h0;
        endcase
    end
endmodule
",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'h1: pos = 2'h1;
            4'h2: pos = 2'h2;
            4'h3: pos = 2'h3;
            4'h4: pos = 2'h4;
            4'h5: pos = 2'h1;
            4'h6: pos = 2'h2;
            4'h7: pos = 2'h3;
            4'h8: pos = 2'h4;
            4'h9: pos = 2'h1;
            4'ha: pos = 2'h2;
            4'hb: pos = 2'h3;
            4'hc: pos = 2'h4;
            4'hd: pos = 2'h1;
            4'he: pos = 2'h2;
            4'hf: pos = 2'h3;
            default: pos = 2'h0;
        endcase
    end
endmodule
","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );


    always @* begin
        case(in)
            4'h1: pos = 2'h1;
            4'h2: pos = 2'h2;
            4'h3: pos = 2'h3;
            4'h4: pos = 2'h4;
            4'h5: pos = 2'h1;
            4'h6: pos = 2'h2;
            4'h7: pos = 2'h3;
            4'h8: pos = 2'h4;
            4'h9: pos = 2'h1;
            4'ha: pos = 2'h2;
            4'hb: pos = 2'h3;
            4'hc: pos = 2'h4;
            4'hd: pos = 2'h1;
            4'he: pos = 2'h2;
            4'hf: pos = 2'h3;
            default: pos = 2'h0;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
",-1.0,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
",-1.0,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
"
"    always @(*) begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
",-1.0,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @(*) begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @(*) begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
",-1.0,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
",-1.0,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
",-1.0,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
",-1.0,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
"
"
    always @* begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
endmodule
",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @* begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @* begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
endmodule
",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
endmodule
"
"    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
",-1.0,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        case(in)
            8'b00000001: pos = 3'b0;
            8'b00000010: pos = 3'b1;
            8'b00000100: pos = 3'b2;
            8'b00001000: pos = 3'b3;
            8'b00010000: pos = 3'b4;
            8'b00100000: pos = 3'b5;
            8'b01000000: pos = 3'b6;
            8'b10000000: pos = 3'b7;
            default: pos = 3'b0;
        endcase
    end
endmodule
"
"    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
"
"    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
"
"    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    // Using procedural if statement
    always @(*) begin
        if(sel_b1 && sel_b2) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    // Using procedural if statement
    always @(*) begin
        if(sel_b1 && sel_b2) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    // Using procedural if statement
    always @(*) begin
        if(sel_b1 && sel_b2) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule
"
"    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
"
"    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    
    always @* begin
        if (sel_b1 && sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    
    always @* begin
        if (sel_b1 && sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    
    always @* begin
        if (sel_b1 && sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
"
"
    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );


    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );


    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
"
"    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    // Using procedural if statement
    always @(*) begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    // Using procedural if statement
    always @(*) begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    // Using procedural if statement
    always @(*) begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
"
"    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
"
"    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    // Using procedural if statement
    always @* begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    // Using procedural if statement
    always @* begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;
    
    // Using procedural if statement
    always @* begin
        if(sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
"
"    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
",1.0,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );

    // Using assign statements
    assign out_assign = (sel_b1 & sel_b2) ? b : a;

    // Using procedural if statement
    always @* begin
        if (sel_b1 & sel_b2) begin
            out_always = b;
        end else begin
            out_always = a;
        end
    end
endmodule
"
"always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: // Anything else
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
    endcase
end

endmodule
",-1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: // Anything else
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: // Anything else
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
    endcase
end

endmodule
"
"always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
",1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
"
"always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: // Anything else
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
    endcase
end

endmodule
",-1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: // Anything else
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: // Anything else
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
    endcase
end

endmodule
"
"always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;

    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0; 
            down = 1'b0; 
            right = 1'b0; 
            up = 1'b0;
        end
    endcase
end

endmodule
",1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;

    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0; 
            down = 1'b0; 
            right = 1'b0; 
            up = 1'b0;
        end
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;

    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0; 
            down = 1'b0; 
            right = 1'b0; 
            up = 1'b0;
        end
    endcase
end

endmodule
"
"always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
",1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
"
"always @(*) begin
    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: // Anything else
    endcase
end

endmodule
",-1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: // Anything else
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: // Anything else
    endcase
end

endmodule
"
"always @(*) begin
    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
",1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
"
"always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
",1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;
    
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
"
"always @(*) begin
    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
",1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 

always @(*) begin
    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
"
"
always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;

    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
",1.0,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 


always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;

    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 


always @(*) begin
    up = 1'b0; 
    down = 1'b0; 
    left = 1'b0; 
    right = 1'b0;

    case (scancode)
        16'he06b: left = 1'b1;
        16'he072: down = 1'b1;
        16'he074: right = 1'b1;
        16'he075: up = 1'b1;
        default: begin
            left = 1'b0;
            down = 1'b0;
            right = 1'b0;
            up = 1'b0;
        end
    endcase
end

endmodule
"
"    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
"
"
    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );


    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );


    assign out = a & b;
endmodule
"
"    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
"
"    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
"
"
    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );


    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );


    assign out = a & b;
endmodule
"
"    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
"
"    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
"
"    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
"
"    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
"
"    assign out = a & b;
endmodule
",1.0,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = a & b;
endmodule
"
"
    wire [3:0] c0, c1, c2, c3;
    wire c4;
    wire [3:0] s0, s1, s2, s3;

    bcd_fadd adder0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(s0), .cout(c0));
    bcd_fadd adder1 (.a(a[7:4]), .b(b[7:4]), .cin(c0), .sum(s1), .cout(c1));
    bcd_fadd adder2 (.a(a[11:8]), .b(b[11:8]), .cin(c1), .sum(s2), .cout(c2));
    bcd_fadd adder3 (.a(a[15:12]), .b(b[15:12]), .cin(c2), .sum(s3), .cout(c3));

    assign sum = {s3, s2, s1, s0};
    assign cout = c3; 

endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c0, c1, c2, c3;
    wire c4;
    wire [3:0] s0, s1, s2, s3;

    bcd_fadd adder0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(s0), .cout(c0));
    bcd_fadd adder1 (.a(a[7:4]), .b(b[7:4]), .cin(c0), .sum(s1), .cout(c1));
    bcd_fadd adder2 (.a(a[11:8]), .b(b[11:8]), .cin(c1), .sum(s2), .cout(c2));
    bcd_fadd adder3 (.a(a[15:12]), .b(b[15:12]), .cin(c2), .sum(s3), .cout(c3));

    assign sum = {s3, s2, s1, s0};
    assign cout = c3; 

endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c0, c1, c2, c3;
    wire c4;
    wire [3:0] s0, s1, s2, s3;

    bcd_fadd adder0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(s0), .cout(c0));
    bcd_fadd adder1 (.a(a[7:4]), .b(b[7:4]), .cin(c0), .sum(s1), .cout(c1));
    bcd_fadd adder2 (.a(a[11:8]), .b(b[11:8]), .cin(c1), .sum(s2), .cout(c2));
    bcd_fadd adder3 (.a(a[15:12]), .b(b[15:12]), .cin(c2), .sum(s3), .cout(c3));

    assign sum = {s3, s2, s1, s0};
    assign cout = c3; 

endmodule
"
"
    wire [3:0] c;
    wire [3:0] s1, s2, s3, s4;
    wire c1, c2, c3;

    bcd_fadd bcd_adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1), .sum(s1));
    bcd_fadd bcd_adder2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd bcd_adder3 (.a(a[11:8]), .b(b[11:8]), .cin(c2), .cout(c3), .sum(s3));
    bcd_fadd bcd_adder4 (.a(a[15:12]), .b(b[15:12]), .cin(c3), .cout(cout), .sum(s4));

    assign sum = {s4, s3, s2, s1};
endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c;
    wire [3:0] s1, s2, s3, s4;
    wire c1, c2, c3;

    bcd_fadd bcd_adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1), .sum(s1));
    bcd_fadd bcd_adder2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd bcd_adder3 (.a(a[11:8]), .b(b[11:8]), .cin(c2), .cout(c3), .sum(s3));
    bcd_fadd bcd_adder4 (.a(a[15:12]), .b(b[15:12]), .cin(c3), .cout(cout), .sum(s4));

    assign sum = {s4, s3, s2, s1};
endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c;
    wire [3:0] s1, s2, s3, s4;
    wire c1, c2, c3;

    bcd_fadd bcd_adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1), .sum(s1));
    bcd_fadd bcd_adder2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd bcd_adder3 (.a(a[11:8]), .b(b[11:8]), .cin(c2), .cout(c3), .sum(s3));
    bcd_fadd bcd_adder4 (.a(a[15:12]), .b(b[15:12]), .cin(c3), .cout(cout), .sum(s4));

    assign sum = {s4, s3, s2, s1};
endmodule
"
"
    bcd_fadd u1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout[0]), .sum(sum[3:0]));
    bcd_fadd u2 (.a(a[7:4]), .b(b[7:4]), .cin(cout[0]), .cout(cout[1]), .sum(sum[7:4]));
    bcd_fadd u3 (.a(a[11:8]), .b(b[11:8]), .cin(cout[1]), .cout(cout[2]), .sum(sum[11:8]));
    bcd_fadd u4 (.a(a[15:12]), .b(b[15:12]), .cin(cout[2]), .cout(cout[3]), .sum(sum[15:12]));
endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    bcd_fadd u1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout[0]), .sum(sum[3:0]));
    bcd_fadd u2 (.a(a[7:4]), .b(b[7:4]), .cin(cout[0]), .cout(cout[1]), .sum(sum[7:4]));
    bcd_fadd u3 (.a(a[11:8]), .b(b[11:8]), .cin(cout[1]), .cout(cout[2]), .sum(sum[11:8]));
    bcd_fadd u4 (.a(a[15:12]), .b(b[15:12]), .cin(cout[2]), .cout(cout[3]), .sum(sum[15:12]));
endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    bcd_fadd u1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout[0]), .sum(sum[3:0]));
    bcd_fadd u2 (.a(a[7:4]), .b(b[7:4]), .cin(cout[0]), .cout(cout[1]), .sum(sum[7:4]));
    bcd_fadd u3 (.a(a[11:8]), .b(b[11:8]), .cin(cout[1]), .cout(cout[2]), .sum(sum[11:8]));
    bcd_fadd u4 (.a(a[15:12]), .b(b[15:12]), .cin(cout[2]), .cout(cout[3]), .sum(sum[15:12]));
endmodule
"
"
    wire [3:0] c0, c1, c2, c3;
    wire [3:0] s0, s1, s2, s3;

    bcd_fadd bcd_adder0(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c0), .sum(s0));
    bcd_fadd bcd_adder1(.a(a[7:4]), .b(b[7:4]), .cin(c0), .cout(c1), .sum(s1));
    bcd_fadd bcd_adder2(.a(a[11:8]), .b(b[11:8]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd bcd_adder3(.a(a[15:12]), .b(b[15:12]), .cin(c2), .cout(cout), .sum(s3));

    assign sum = {s3, s2, s1, s0};
endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c0, c1, c2, c3;
    wire [3:0] s0, s1, s2, s3;

    bcd_fadd bcd_adder0(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c0), .sum(s0));
    bcd_fadd bcd_adder1(.a(a[7:4]), .b(b[7:4]), .cin(c0), .cout(c1), .sum(s1));
    bcd_fadd bcd_adder2(.a(a[11:8]), .b(b[11:8]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd bcd_adder3(.a(a[15:12]), .b(b[15:12]), .cin(c2), .cout(cout), .sum(s3));

    assign sum = {s3, s2, s1, s0};
endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c0, c1, c2, c3;
    wire [3:0] s0, s1, s2, s3;

    bcd_fadd bcd_adder0(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c0), .sum(s0));
    bcd_fadd bcd_adder1(.a(a[7:4]), .b(b[7:4]), .cin(c0), .cout(c1), .sum(s1));
    bcd_fadd bcd_adder2(.a(a[11:8]), .b(b[11:8]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd bcd_adder3(.a(a[15:12]), .b(b[15:12]), .cin(c2), .cout(cout), .sum(s3));

    assign sum = {s3, s2, s1, s0};
endmodule
"
"
    wire [3:0] c0, c1, c2, c3;
    wire cout_temp;
    
    bcd_fadd u0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c0), .sum(sum[3:0]));
    bcd_fadd u1 (.a(a[7:4]), .b(b[7:4]), .cin(c0), .cout(c1), .sum(sum[7:4]));
    bcd_fadd u2 (.a(a[11:8]), .b(b[11:8]), .cin(c1), .cout(c2), .sum(sum[11:8]));
    bcd_fadd u3 (.a(a[15:12]), .b(b[15:12]), .cin(c2), .cout(cout_temp), .sum(sum[15:12]));
    
    assign cout = cout_temp;
    
endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c0, c1, c2, c3;
    wire cout_temp;
    
    bcd_fadd u0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c0), .sum(sum[3:0]));
    bcd_fadd u1 (.a(a[7:4]), .b(b[7:4]), .cin(c0), .cout(c1), .sum(sum[7:4]));
    bcd_fadd u2 (.a(a[11:8]), .b(b[11:8]), .cin(c1), .cout(c2), .sum(sum[11:8]));
    bcd_fadd u3 (.a(a[15:12]), .b(b[15:12]), .cin(c2), .cout(cout_temp), .sum(sum[15:12]));
    
    assign cout = cout_temp;
    
endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c0, c1, c2, c3;
    wire cout_temp;
    
    bcd_fadd u0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c0), .sum(sum[3:0]));
    bcd_fadd u1 (.a(a[7:4]), .b(b[7:4]), .cin(c0), .cout(c1), .sum(sum[7:4]));
    bcd_fadd u2 (.a(a[11:8]), .b(b[11:8]), .cin(c1), .cout(c2), .sum(sum[11:8]));
    bcd_fadd u3 (.a(a[15:12]), .b(b[15:12]), .cin(c2), .cout(cout_temp), .sum(sum[15:12]));
    
    assign cout = cout_temp;
    
endmodule
"
"
    wire [3:0] c0, c1, c2, c3;
    wire cout_1, cout_2, cout_3;
    
    bcd_fadd bcd_adder0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c0), .sum(sum[3:0]));
    bcd_fadd bcd_adder1 (.a(a[7:4]), .b(b[7:4]), .cin(c0), .cout(c1), .sum(sum[7:4]));
    bcd_fadd bcd_adder2 (.a(a[11:8]), .b(b[11:8]), .cin(c1), .cout(c2), .sum(sum[11:8]));
    bcd_fadd bcd_adder3 (.a(a[15:12]), .b(b[15:12]), .cin(c2), .cout(cout_3), .sum(sum[15:12]));
    
    assign cout = cout_3;
    
endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c0, c1, c2, c3;
    wire cout_1, cout_2, cout_3;
    
    bcd_fadd bcd_adder0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c0), .sum(sum[3:0]));
    bcd_fadd bcd_adder1 (.a(a[7:4]), .b(b[7:4]), .cin(c0), .cout(c1), .sum(sum[7:4]));
    bcd_fadd bcd_adder2 (.a(a[11:8]), .b(b[11:8]), .cin(c1), .cout(c2), .sum(sum[11:8]));
    bcd_fadd bcd_adder3 (.a(a[15:12]), .b(b[15:12]), .cin(c2), .cout(cout_3), .sum(sum[15:12]));
    
    assign cout = cout_3;
    
endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c0, c1, c2, c3;
    wire cout_1, cout_2, cout_3;
    
    bcd_fadd bcd_adder0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c0), .sum(sum[3:0]));
    bcd_fadd bcd_adder1 (.a(a[7:4]), .b(b[7:4]), .cin(c0), .cout(c1), .sum(sum[7:4]));
    bcd_fadd bcd_adder2 (.a(a[11:8]), .b(b[11:8]), .cin(c1), .cout(c2), .sum(sum[11:8]));
    bcd_fadd bcd_adder3 (.a(a[15:12]), .b(b[15:12]), .cin(c2), .cout(cout_3), .sum(sum[15:12]));
    
    assign cout = cout_3;
    
endmodule
"
"
    wire [3:0] c1, c2, c3, c4;
    wire [15:0] s1, s2, s3;
    
    bcd_fadd bcd1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1), .sum(s1));
    bcd_fadd bcd2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd bcd3 (.a(a[11:8]), .b(b[11:8]), .cin(c2), .cout(c3), .sum(s3));
    bcd_fadd bcd4 (.a(a[15:12]), .b(b[15:12]), .cin(c3), .cout(c4), .sum(sum));
    
    assign cout = c4;
    
endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c1, c2, c3, c4;
    wire [15:0] s1, s2, s3;
    
    bcd_fadd bcd1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1), .sum(s1));
    bcd_fadd bcd2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd bcd3 (.a(a[11:8]), .b(b[11:8]), .cin(c2), .cout(c3), .sum(s3));
    bcd_fadd bcd4 (.a(a[15:12]), .b(b[15:12]), .cin(c3), .cout(c4), .sum(sum));
    
    assign cout = c4;
    
endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c1, c2, c3, c4;
    wire [15:0] s1, s2, s3;
    
    bcd_fadd bcd1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1), .sum(s1));
    bcd_fadd bcd2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd bcd3 (.a(a[11:8]), .b(b[11:8]), .cin(c2), .cout(c3), .sum(s3));
    bcd_fadd bcd4 (.a(a[15:12]), .b(b[15:12]), .cin(c3), .cout(c4), .sum(sum));
    
    assign cout = c4;
    
endmodule
"
"
    wire [3:0] c1, c2, c3, c4;
    wire [3:0] s1, s2, s3, s4;

    bcd_fadd adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1), .sum(s1));
    bcd_fadd adder2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd adder3 (.a(a[11:8]), .b(b[11:8]), .cin(c2), .cout(c3), .sum(s3));
    bcd_fadd adder4 (.a(a[15:12]), .b(b[15:12]), .cin(c3), .cout(cout), .sum(s4));

    assign sum = {s4, s3, s2, s1};
endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c1, c2, c3, c4;
    wire [3:0] s1, s2, s3, s4;

    bcd_fadd adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1), .sum(s1));
    bcd_fadd adder2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd adder3 (.a(a[11:8]), .b(b[11:8]), .cin(c2), .cout(c3), .sum(s3));
    bcd_fadd adder4 (.a(a[15:12]), .b(b[15:12]), .cin(c3), .cout(cout), .sum(s4));

    assign sum = {s4, s3, s2, s1};
endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] c1, c2, c3, c4;
    wire [3:0] s1, s2, s3, s4;

    bcd_fadd adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1), .sum(s1));
    bcd_fadd adder2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .cout(c2), .sum(s2));
    bcd_fadd adder3 (.a(a[11:8]), .b(b[11:8]), .cin(c2), .cout(c3), .sum(s3));
    bcd_fadd adder4 (.a(a[15:12]), .b(b[15:12]), .cin(c3), .cout(cout), .sum(s4));

    assign sum = {s4, s3, s2, s1};
endmodule
"
"
    wire [3:0] carry;
    wire [3:0] s1, s2, s3;
    
    bcd_fadd bcd_adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(carry[0]), .sum(s1));
    bcd_fadd bcd_adder2 (.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .cout(carry[1]), .sum(s2));
    bcd_fadd bcd_adder3 (.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .cout(carry[2]), .sum(s3));
    bcd_fadd bcd_adder4 (.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .cout(cout), .sum(sum[3:0]));
    
    assign sum = {s3, s2, s1, s4};
endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] carry;
    wire [3:0] s1, s2, s3;
    
    bcd_fadd bcd_adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(carry[0]), .sum(s1));
    bcd_fadd bcd_adder2 (.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .cout(carry[1]), .sum(s2));
    bcd_fadd bcd_adder3 (.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .cout(carry[2]), .sum(s3));
    bcd_fadd bcd_adder4 (.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .cout(cout), .sum(sum[3:0]));
    
    assign sum = {s3, s2, s1, s4};
endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] carry;
    wire [3:0] s1, s2, s3;
    
    bcd_fadd bcd_adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(carry[0]), .sum(s1));
    bcd_fadd bcd_adder2 (.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .cout(carry[1]), .sum(s2));
    bcd_fadd bcd_adder3 (.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .cout(carry[2]), .sum(s3));
    bcd_fadd bcd_adder4 (.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .cout(cout), .sum(sum[3:0]));
    
    assign sum = {s3, s2, s1, s4};
endmodule
"
"
    wire [3:0] carry;
    wire [3:0] s1, s2, s3, s4;

    bcd_fadd bcd_adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(carry[0]), .sum(s1));
    bcd_fadd bcd_adder2 (.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .cout(carry[1]), .sum(s2));
    bcd_fadd bcd_adder3 (.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .cout(carry[2]), .sum(s3));
    bcd_fadd bcd_adder4 (.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .cout(cout), .sum(s4));

    assign sum = {s4, s3, s2, s1};
endmodule
",-1.0,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] carry;
    wire [3:0] s1, s2, s3, s4;

    bcd_fadd bcd_adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(carry[0]), .sum(s1));
    bcd_fadd bcd_adder2 (.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .cout(carry[1]), .sum(s2));
    bcd_fadd bcd_adder3 (.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .cout(carry[2]), .sum(s3));
    bcd_fadd bcd_adder4 (.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .cout(cout), .sum(s4));

    assign sum = {s4, s3, s2, s1};
endmodule
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );


    wire [3:0] carry;
    wire [3:0] s1, s2, s3, s4;

    bcd_fadd bcd_adder1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(carry[0]), .sum(s1));
    bcd_fadd bcd_adder2 (.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .cout(carry[1]), .sum(s2));
    bcd_fadd bcd_adder3 (.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .cout(carry[2]), .sum(s3));
    bcd_fadd bcd_adder4 (.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .cout(cout), .sum(s4));

    assign sum = {s4, s3, s2, s1};
endmodule
"
"module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    // Instantiate 100 copies of bcd_fadd
    genvar i;
    generate
        for(i = 0; i < 100; i = i + 1) begin : adder_instance
            bcd_fadd adder(
                .a(a[i*4 + 3:i*4]),
                .b(b[i*4 + 3:i*4]),
                .cin(cin),
                .cout(carry[i]),
                .sum(sum[i*4 + 3:i*4])
            );
        end
    endgenerate

    // Generate carry chain
    wire [99:0] carry;
    assign cout = carry[99];
endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    // Instantiate 100 copies of bcd_fadd
    genvar i;
    generate
        for(i = 0; i < 100; i = i + 1) begin : adder_instance
            bcd_fadd adder(
                .a(a[i*4 + 3:i*4]),
                .b(b[i*4 + 3:i*4]),
                .cin(cin),
                .cout(carry[i]),
                .sum(sum[i*4 + 3:i*4])
            );
        end
    endgenerate

    // Generate carry chain
    wire [99:0] carry;
    assign cout = carry[99];
endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    // Instantiate 100 copies of bcd_fadd
    genvar i;
    generate
        for(i = 0; i < 100; i = i + 1) begin : adder_instance
            bcd_fadd adder(
                .a(a[i*4 + 3:i*4]),
                .b(b[i*4 + 3:i*4]),
                .cin(cin),
                .cout(carry[i]),
                .sum(sum[i*4 + 3:i*4])
            );
        end
    endgenerate

    // Generate carry chain
    wire [99:0] carry;
    assign cout = carry[99];
endmodule
"
"module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] c; // Carry out from each bcd_fadd module
    wire [399:0] s; // Sum from each bcd_fadd module

    // Instantiate 100 bcd_fadd modules
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : adder_instance
            bcd_fadd bcd_adder (
                .a(a[i*4 + 3 : i*4]),
                .b(b[i*4 + 3 : i*4]),
                .cin(cin),
                .cout(c[i]),
                .sum(s[i*4 + 3 : i*4])
            );
        end
    endgenerate

    assign cout = c[99]; // Output carry out from the last bcd_fadd module
    assign sum = s; // Output sum from all bcd_fadd modules

endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] c; // Carry out from each bcd_fadd module
    wire [399:0] s; // Sum from each bcd_fadd module

    // Instantiate 100 bcd_fadd modules
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : adder_instance
            bcd_fadd bcd_adder (
                .a(a[i*4 + 3 : i*4]),
                .b(b[i*4 + 3 : i*4]),
                .cin(cin),
                .cout(c[i]),
                .sum(s[i*4 + 3 : i*4])
            );
        end
    endgenerate

    assign cout = c[99]; // Output carry out from the last bcd_fadd module
    assign sum = s; // Output sum from all bcd_fadd modules

endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] c; // Carry out from each bcd_fadd module
    wire [399:0] s; // Sum from each bcd_fadd module

    // Instantiate 100 bcd_fadd modules
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin : adder_instance
            bcd_fadd bcd_adder (
                .a(a[i*4 + 3 : i*4]),
                .b(b[i*4 + 3 : i*4]),
                .cin(cin),
                .cout(c[i]),
                .sum(s[i*4 + 3 : i*4])
            );
        end
    endgenerate

    assign cout = c[99]; // Output carry out from the last bcd_fadd module
    assign sum = s; // Output sum from all bcd_fadd modules

endmodule
"
"module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [399:0] carry;
    wire [399:0] temp_sum;
    
    bcd_fadd bcd_adders[99:0](
        .a(a[3:0]), 
        .b(b[3:0]), 
        .cin(cin), 
        .cout(carry[0]), 
        .sum(temp_sum[0])
    );
    
    generate
        genvar i;
        for (i = 1; i < 100; i = i + 1) begin : adder_loop
            bcd_fadd bcd_adders(
                .a(a[i*4 +: 4]), 
                .b(b[i*4 +: 4]), 
                .cin(carry[i-1]), 
                .cout(carry[i]), 
                .sum(temp_sum[i])
            );
        end
    endgenerate
    
    assign cout = carry[99];
    assign sum = temp_sum;
    
endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [399:0] carry;
    wire [399:0] temp_sum;
    
    bcd_fadd bcd_adders[99:0](
        .a(a[3:0]), 
        .b(b[3:0]), 
        .cin(cin), 
        .cout(carry[0]), 
        .sum(temp_sum[0])
    );
    
    generate
        genvar i;
        for (i = 1; i < 100; i = i + 1) begin : adder_loop
            bcd_fadd bcd_adders(
                .a(a[i*4 +: 4]), 
                .b(b[i*4 +: 4]), 
                .cin(carry[i-1]), 
                .cout(carry[i]), 
                .sum(temp_sum[i])
            );
        end
    endgenerate
    
    assign cout = carry[99];
    assign sum = temp_sum;
    
endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [399:0] carry;
    wire [399:0] temp_sum;
    
    bcd_fadd bcd_adders[99:0](
        .a(a[3:0]), 
        .b(b[3:0]), 
        .cin(cin), 
        .cout(carry[0]), 
        .sum(temp_sum[0])
    );
    
    generate
        genvar i;
        for (i = 1; i < 100; i = i + 1) begin : adder_loop
            bcd_fadd bcd_adders(
                .a(a[i*4 +: 4]), 
                .b(b[i*4 +: 4]), 
                .cin(carry[i-1]), 
                .cout(carry[i]), 
                .sum(temp_sum[i])
            );
        end
    endgenerate
    
    assign cout = carry[99];
    assign sum = temp_sum;
    
endmodule
"
"module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    genvar i;
    generate
        for(i = 0; i < 100; i = i + 1) begin
            bcd_fadd bcd_adder(
                .a(a[i*4 + 3 : i*4]),
                .b(b[i*4 + 3 : i*4]),
                .cin(cin),
                .cout(cout),
                .sum(sum[i*4 + 3 : i*4])
            );
        end
    endgenerate

endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    genvar i;
    generate
        for(i = 0; i < 100; i = i + 1) begin
            bcd_fadd bcd_adder(
                .a(a[i*4 + 3 : i*4]),
                .b(b[i*4 + 3 : i*4]),
                .cin(cin),
                .cout(cout),
                .sum(sum[i*4 + 3 : i*4])
            );
        end
    endgenerate

endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    genvar i;
    generate
        for(i = 0; i < 100; i = i + 1) begin
            bcd_fadd bcd_adder(
                .a(a[i*4 + 3 : i*4]),
                .b(b[i*4 + 3 : i*4]),
                .cin(cin),
                .cout(cout),
                .sum(sum[i*4 + 3 : i*4])
            );
        end
    endgenerate

endmodule
"
"module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [99:0] carry;
    wire [399:0] temp_sum;
    
    bcd_fadd bcd_adders[99](
        .a(a[3*idx +: 4]),
        .b(b[3*idx +: 4]),
        .cin(carry[idx]),
        .cout(carry[idx + 1]),
        .sum(temp_sum[3*idx +: 4])
    ) generate for (idx = 0; idx < 100; idx++);
    
    assign cout = carry[100];
    assign sum = temp_sum;
    
endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [99:0] carry;
    wire [399:0] temp_sum;
    
    bcd_fadd bcd_adders[99](
        .a(a[3*idx +: 4]),
        .b(b[3*idx +: 4]),
        .cin(carry[idx]),
        .cout(carry[idx + 1]),
        .sum(temp_sum[3*idx +: 4])
    ) generate for (idx = 0; idx < 100; idx++);
    
    assign cout = carry[100];
    assign sum = temp_sum;
    
endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [99:0] carry;
    wire [399:0] temp_sum;
    
    bcd_fadd bcd_adders[99](
        .a(a[3*idx +: 4]),
        .b(b[3*idx +: 4]),
        .cin(carry[idx]),
        .cout(carry[idx + 1]),
        .sum(temp_sum[3*idx +: 4])
    ) generate for (idx = 0; idx < 100; idx++);
    
    assign cout = carry[100];
    assign sum = temp_sum;
    
endmodule
"
"module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [399:0] carry;
    bcd_fadd bcd_adders[99](
        .a(a[3:0]), 
        .b(b[3:0]), 
        .cin(cin), 
        .cout(carry[0]), 
        .sum(sum[3:0])
    );
    
    generate
        genvar i;
        for(i = 1; i < 100; i = i + 1) begin : adder_loop
            bcd_fadd bcd_adders(
                .a(a[i*4 + 3 : i*4]), 
                .b(b[i*4 + 3 : i*4]), 
                .cin(carry[i-1]), 
                .cout(carry[i]), 
                .sum(sum[i*4 + 3 : i*4])
            );
        end
    endgenerate

    assign cout = carry[99];
    
endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [399:0] carry;
    bcd_fadd bcd_adders[99](
        .a(a[3:0]), 
        .b(b[3:0]), 
        .cin(cin), 
        .cout(carry[0]), 
        .sum(sum[3:0])
    );
    
    generate
        genvar i;
        for(i = 1; i < 100; i = i + 1) begin : adder_loop
            bcd_fadd bcd_adders(
                .a(a[i*4 + 3 : i*4]), 
                .b(b[i*4 + 3 : i*4]), 
                .cin(carry[i-1]), 
                .cout(carry[i]), 
                .sum(sum[i*4 + 3 : i*4])
            );
        end
    endgenerate

    assign cout = carry[99];
    
endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [399:0] carry;
    bcd_fadd bcd_adders[99](
        .a(a[3:0]), 
        .b(b[3:0]), 
        .cin(cin), 
        .cout(carry[0]), 
        .sum(sum[3:0])
    );
    
    generate
        genvar i;
        for(i = 1; i < 100; i = i + 1) begin : adder_loop
            bcd_fadd bcd_adders(
                .a(a[i*4 + 3 : i*4]), 
                .b(b[i*4 + 3 : i*4]), 
                .cin(carry[i-1]), 
                .cout(carry[i]), 
                .sum(sum[i*4 + 3 : i*4])
            );
        end
    endgenerate

    assign cout = carry[99];
    
endmodule
"
"module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    // Declare signals to store intermediate carry values
    reg [99:0] carry;
    
    // Instantiate 100 copies of bcd_fadd and connect them in a ripple-carry fashion
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin
            bcd_fadd bcd_adder (
                .a(a[i*4 +: 4]),
                .b(b[i*4 +: 4]),
                .cin(carry[i]),
                .cout(carry[i+1]),
                .sum(sum[i*4 +: 4])
            );
        end
    endgenerate
    
    // Connect carry-out of the last adder to the output carry
    assign cout = carry[100];
    
endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    // Declare signals to store intermediate carry values
    reg [99:0] carry;
    
    // Instantiate 100 copies of bcd_fadd and connect them in a ripple-carry fashion
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin
            bcd_fadd bcd_adder (
                .a(a[i*4 +: 4]),
                .b(b[i*4 +: 4]),
                .cin(carry[i]),
                .cout(carry[i+1]),
                .sum(sum[i*4 +: 4])
            );
        end
    endgenerate
    
    // Connect carry-out of the last adder to the output carry
    assign cout = carry[100];
    
endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    // Declare signals to store intermediate carry values
    reg [99:0] carry;
    
    // Instantiate 100 copies of bcd_fadd and connect them in a ripple-carry fashion
    genvar i;
    generate
        for (i = 0; i < 100; i = i + 1) begin
            bcd_fadd bcd_adder (
                .a(a[i*4 +: 4]),
                .b(b[i*4 +: 4]),
                .cin(carry[i]),
                .cout(carry[i+1]),
                .sum(sum[i*4 +: 4])
            );
        end
    endgenerate
    
    // Connect carry-out of the last adder to the output carry
    assign cout = carry[100];
    
endmodule
"
"module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] carry;
    wire [399:0] inter_sum;
    
    bcd_fadd bcd_adder [99:0](
        .a(a[3*100 +: 4]),
        .b(b[3*100 +: 4]),
        .cin(cin),
        .sum(inter_sum[3*100 +: 4]),
        .cout(carry[3*100])
    );
    
    generate
        genvar i;
        for(i=1; i<100; i=i+1) begin : adder_chain
            bcd_fadd bcd_adder(
                .a(a[i*4 +: 4]),
                .b(b[i*4 +: 4]),
                .cin(carry[(i-1)*4]),
                .sum(inter_sum[i*4 +: 4]),
                .cout(carry[i*4])
            );
        end
    endgenerate
    
    assign cout = carry[399];
    assign sum = inter_sum;
    
endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] carry;
    wire [399:0] inter_sum;
    
    bcd_fadd bcd_adder [99:0](
        .a(a[3*100 +: 4]),
        .b(b[3*100 +: 4]),
        .cin(cin),
        .sum(inter_sum[3*100 +: 4]),
        .cout(carry[3*100])
    );
    
    generate
        genvar i;
        for(i=1; i<100; i=i+1) begin : adder_chain
            bcd_fadd bcd_adder(
                .a(a[i*4 +: 4]),
                .b(b[i*4 +: 4]),
                .cin(carry[(i-1)*4]),
                .sum(inter_sum[i*4 +: 4]),
                .cout(carry[i*4])
            );
        end
    endgenerate
    
    assign cout = carry[399];
    assign sum = inter_sum;
    
endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] carry;
    wire [399:0] inter_sum;
    
    bcd_fadd bcd_adder [99:0](
        .a(a[3*100 +: 4]),
        .b(b[3*100 +: 4]),
        .cin(cin),
        .sum(inter_sum[3*100 +: 4]),
        .cout(carry[3*100])
    );
    
    generate
        genvar i;
        for(i=1; i<100; i=i+1) begin : adder_chain
            bcd_fadd bcd_adder(
                .a(a[i*4 +: 4]),
                .b(b[i*4 +: 4]),
                .cin(carry[(i-1)*4]),
                .sum(inter_sum[i*4 +: 4]),
                .cout(carry[i*4])
            );
        end
    endgenerate
    
    assign cout = carry[399];
    assign sum = inter_sum;
    
endmodule
"
"module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] c;
    wire [399:0] s;
    
    bcd_fadd bcd_adders[99:0](.a(a[3:0], a[7:4], ..., a[397:394]), 
                              .b(b[3:0], b[7:4], ..., b[397:394]), 
                              .cin(cin), 
                              .cout(c[0]), 
                              .sum(s[3:0], s[7:4], ..., s[397:394]));
    
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : adder_gen
            bcd_fadd bcd_adders(.a(a[4*i+3:4*i], a[4*i+7:4*i+4], ..., a[4*i+397:4*i+394]), 
                                .b(b[4*i+3:4*i], b[4*i+7:4*i+4], ..., b[4*i+397:4*i+394]), 
                                .cin(c[i-1]), 
                                .cout(c[i]), 
                                .sum(s[4*i+3:4*i], s[4*i+7:4*i+4], ..., s[4*i+397:4*i+394]));
        end
    endgenerate
    
    assign cout = c[99];
    assign sum = s;

endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] c;
    wire [399:0] s;
    
    bcd_fadd bcd_adders[99:0](.a(a[3:0], a[7:4], ..., a[397:394]), 
                              .b(b[3:0], b[7:4], ..., b[397:394]), 
                              .cin(cin), 
                              .cout(c[0]), 
                              .sum(s[3:0], s[7:4], ..., s[397:394]));
    
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : adder_gen
            bcd_fadd bcd_adders(.a(a[4*i+3:4*i], a[4*i+7:4*i+4], ..., a[4*i+397:4*i+394]), 
                                .b(b[4*i+3:4*i], b[4*i+7:4*i+4], ..., b[4*i+397:4*i+394]), 
                                .cin(c[i-1]), 
                                .cout(c[i]), 
                                .sum(s[4*i+3:4*i], s[4*i+7:4*i+4], ..., s[4*i+397:4*i+394]));
        end
    endgenerate
    
    assign cout = c[99];
    assign sum = s;

endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] c;
    wire [399:0] s;
    
    bcd_fadd bcd_adders[99:0](.a(a[3:0], a[7:4], ..., a[397:394]), 
                              .b(b[3:0], b[7:4], ..., b[397:394]), 
                              .cin(cin), 
                              .cout(c[0]), 
                              .sum(s[3:0], s[7:4], ..., s[397:394]));
    
    genvar i;
    generate
        for (i = 1; i < 100; i = i + 1) begin : adder_gen
            bcd_fadd bcd_adders(.a(a[4*i+3:4*i], a[4*i+7:4*i+4], ..., a[4*i+397:4*i+394]), 
                                .b(b[4*i+3:4*i], b[4*i+7:4*i+4], ..., b[4*i+397:4*i+394]), 
                                .cin(c[i-1]), 
                                .cout(c[i]), 
                                .sum(s[4*i+3:4*i], s[4*i+7:4*i+4], ..., s[4*i+397:4*i+394]));
        end
    endgenerate
    
    assign cout = c[99];
    assign sum = s;

endmodule
"
"module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum
);

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum
);

// Instantiate 100 copies of bcd_fadd
genvar i;
generate
    for (i = 0; i < 100; i = i + 1) begin
        bcd_fadd bcd_inst (
            .a(a[i*4 + 3:i*4]),
            .b(b[i*4 + 3:i*4]),
            .cin(cin),
            .cout(cout[i]),
            .sum(sum[i*4 + 3:i*4])
        );
    end
endgenerate

endmodule
",-1.0,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum
);

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum
);

// Instantiate 100 copies of bcd_fadd
genvar i;
generate
    for (i = 0; i < 100; i = i + 1) begin
        bcd_fadd bcd_inst (
            .a(a[i*4 + 3:i*4]),
            .b(b[i*4 + 3:i*4]),
            .cin(cin),
            .cout(cout[i]),
            .sum(sum[i*4 + 3:i*4])
        );
    end
endgenerate

endmodule
","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum
);

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum
);

// Instantiate 100 copies of bcd_fadd
genvar i;
generate
    for (i = 0; i < 100; i = i + 1) begin
        bcd_fadd bcd_inst (
            .a(a[i*4 + 3:i*4]),
            .b(b[i*4 + 3:i*4]),
            .cin(cin),
            .cout(cout[i]),
            .sum(sum[i*4 + 3:i*4])
        );
    end
endgenerate

endmodule
"
"
    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
"
"
    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
"
"
    wire [7:0] min1, min2, min3;
    
    assign min1 = (a < b) ? a : b;
    assign min2 = (c < d) ? c : d;
    assign min3 = (min1 < min2) ? min1 : min2;
    
    assign min = min3;
    
endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min1, min2, min3;
    
    assign min1 = (a < b) ? a : b;
    assign min2 = (c < d) ? c : d;
    assign min3 = (min1 < min2) ? min1 : min2;
    
    assign min = min3;
    
endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min1, min2, min3;
    
    assign min1 = (a < b) ? a : b;
    assign min2 = (c < d) ? c : d;
    assign min3 = (min1 < min2) ? min1 : min2;
    
    assign min = min3;
    
endmodule
"
"
    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
"
"
    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
"
"
    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
"
"
    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
"
"
    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
"
"
    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min_ab, min_cd, min;

    assign min_ab = (a < b) ? a : b;
    assign min_cd = (c < d) ? c : d;
    assign min = (min_ab < min_cd) ? min_ab : min_cd;

endmodule
"
"
    wire [7:0] min1, min2, min3;
    
    assign min1 = (a < b) ? a : b;
    assign min2 = (c < d) ? c : d;
    assign min3 = (min1 < min2) ? min1 : min2;
    
    assign min = min3;
    
endmodule
",1.0,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min1, min2, min3;
    
    assign min1 = (a < b) ? a : b;
    assign min2 = (c < d) ? c : d;
    assign min3 = (min1 < min2) ? min1 : min2;
    
    assign min = min3;
    
endmodule
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;


    wire [7:0] min1, min2, min3;
    
    assign min1 = (a < b) ? a : b;
    assign min2 = (c < d) ? c : d;
    assign min3 = (min1 < min2) ? min1 : min2;
    
    assign min = min3;
    
endmodule
"
"    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [3:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [3:0] seconds_tens;
    reg [3:0] seconds_ones;
    
    reg [1:0] pm;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            pm <= 0;
            hours_tens <= 1;
            hours_ones <= 2;
            minutes_tens <= 0;
            minutes_ones <= 0;
            seconds_tens <= 0;
            seconds_ones <= 0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 10) begin
                seconds_ones <= 0;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 6) begin
                    seconds_tens <= 0;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 10) begin
                        minutes_ones <= 0;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 6) begin
                            minutes_tens <= 0;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 10) begin
                                hours_ones <= 0;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 1 && hours_ones == 3) begin
                                    hours_tens <= 0;
                                    hours_ones <= 1;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
",-1.0,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [3:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [3:0] seconds_tens;
    reg [3:0] seconds_ones;
    
    reg [1:0] pm;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            pm <= 0;
            hours_tens <= 1;
            hours_ones <= 2;
            minutes_tens <= 0;
            minutes_ones <= 0;
            seconds_tens <= 0;
            seconds_ones <= 0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 10) begin
                seconds_ones <= 0;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 6) begin
                    seconds_tens <= 0;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 10) begin
                        minutes_ones <= 0;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 6) begin
                            minutes_tens <= 0;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 10) begin
                                hours_ones <= 0;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 1 && hours_ones == 3) begin
                                    hours_tens <= 0;
                                    hours_ones <= 1;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [3:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [3:0] seconds_tens;
    reg [3:0] seconds_ones;
    
    reg [1:0] pm;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            pm <= 0;
            hours_tens <= 1;
            hours_ones <= 2;
            minutes_tens <= 0;
            minutes_ones <= 0;
            seconds_tens <= 0;
            seconds_ones <= 0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 10) begin
                seconds_ones <= 0;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 6) begin
                    seconds_tens <= 0;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 10) begin
                        minutes_ones <= 0;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 6) begin
                            minutes_tens <= 0;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 10) begin
                                hours_ones <= 0;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 1 && hours_ones == 3) begin
                                    hours_tens <= 0;
                                    hours_ones <= 1;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
"
"
    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            if (hours_tens == 4'b0001 && hours_ones == 4'b0001 && minutes_tens == 4'b0000 && minutes_ones == 4'b0000 && seconds_tens == 4'b0000 && seconds_ones == 4'b0000) begin
                pm <= ~pm;
            end
            
            if (seconds_ones == 4'b1001) begin
                seconds_ones <= 4'b0000;
                if (seconds_tens == 4'b0000) begin
                    seconds_tens <= 4'b0001;
                    if (minutes_ones == 4'b1001) begin
                        minutes_ones <= 4'b0000;
                        if (minutes_tens == 4'b0000) begin
                            minutes_tens <= 4'b0001;
                            if (hours_ones == 4'b1001) begin
                                hours_ones <= 4'b0000;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                else
                                    hours_tens <= hours_tens + 1;
                                end
                            else
                                hours_ones <= hours_ones + 1;
                            end
                        else
                            minutes_tens <= minutes_tens + 1;
                        end
                    else
                        minutes_ones <= minutes_ones + 1;
                    end
                else
                    seconds_tens <= seconds_tens + 1;
                end
            else
                seconds_ones <= seconds_ones + 1;
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
",-1.0,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);


    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            if (hours_tens == 4'b0001 && hours_ones == 4'b0001 && minutes_tens == 4'b0000 && minutes_ones == 4'b0000 && seconds_tens == 4'b0000 && seconds_ones == 4'b0000) begin
                pm <= ~pm;
            end
            
            if (seconds_ones == 4'b1001) begin
                seconds_ones <= 4'b0000;
                if (seconds_tens == 4'b0000) begin
                    seconds_tens <= 4'b0001;
                    if (minutes_ones == 4'b1001) begin
                        minutes_ones <= 4'b0000;
                        if (minutes_tens == 4'b0000) begin
                            minutes_tens <= 4'b0001;
                            if (hours_ones == 4'b1001) begin
                                hours_ones <= 4'b0000;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                else
                                    hours_tens <= hours_tens + 1;
                                end
                            else
                                hours_ones <= hours_ones + 1;
                            end
                        else
                            minutes_tens <= minutes_tens + 1;
                        end
                    else
                        minutes_ones <= minutes_ones + 1;
                    end
                else
                    seconds_tens <= seconds_tens + 1;
                end
            else
                seconds_ones <= seconds_ones + 1;
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);


    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            if (hours_tens == 4'b0001 && hours_ones == 4'b0001 && minutes_tens == 4'b0000 && minutes_ones == 4'b0000 && seconds_tens == 4'b0000 && seconds_ones == 4'b0000) begin
                pm <= ~pm;
            end
            
            if (seconds_ones == 4'b1001) begin
                seconds_ones <= 4'b0000;
                if (seconds_tens == 4'b0000) begin
                    seconds_tens <= 4'b0001;
                    if (minutes_ones == 4'b1001) begin
                        minutes_ones <= 4'b0000;
                        if (minutes_tens == 4'b0000) begin
                            minutes_tens <= 4'b0001;
                            if (hours_ones == 4'b1001) begin
                                hours_ones <= 4'b0000;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                else
                                    hours_tens <= hours_tens + 1;
                                end
                            else
                                hours_ones <= hours_ones + 1;
                            end
                        else
                            minutes_tens <= minutes_tens + 1;
                        end
                    else
                        minutes_ones <= minutes_ones + 1;
                    end
                else
                    seconds_tens <= seconds_tens + 1;
                end
            else
                seconds_ones <= seconds_ones + 1;
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
"
"    reg [7:0] hh_reg, mm_reg, ss_reg;
    reg pm_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            hh_reg <= 8'b0001; // 12
            mm_reg <= 8'b0000; // 00
            ss_reg <= 8'b0000; // 00
            pm_reg <= 1'b0; // AM
        end else if (ena) begin
            ss_reg <= ss_reg + 1;
            if (ss_reg == 8'b0110) begin // 59 seconds
                ss_reg <= 8'b0000; // 00 seconds
                mm_reg <= mm_reg + 1;
                if (mm_reg == 8'b0110) begin // 59 minutes
                    mm_reg <= 8'b0000; // 00 minutes
                    hh_reg <= hh_reg + 1;
                    if (hh_reg == 8'b1100) begin // 12 hours
                        hh_reg <= 8'b0001; // 01 hours
                        pm_reg <= ~pm_reg; // toggle AM/PM
                    end else if (hh_reg == 8'b1010) begin // 10 hours
                        hh_reg <= 8'b0001; // 11 hours
                    end
                end
            end
        end
    end
    
    assign pm = pm_reg;
    assign hh = hh_reg;
    assign mm = mm_reg;
    assign ss = ss_reg;
    
endmodule
",-0.5,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [7:0] hh_reg, mm_reg, ss_reg;
    reg pm_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            hh_reg <= 8'b0001; // 12
            mm_reg <= 8'b0000; // 00
            ss_reg <= 8'b0000; // 00
            pm_reg <= 1'b0; // AM
        end else if (ena) begin
            ss_reg <= ss_reg + 1;
            if (ss_reg == 8'b0110) begin // 59 seconds
                ss_reg <= 8'b0000; // 00 seconds
                mm_reg <= mm_reg + 1;
                if (mm_reg == 8'b0110) begin // 59 minutes
                    mm_reg <= 8'b0000; // 00 minutes
                    hh_reg <= hh_reg + 1;
                    if (hh_reg == 8'b1100) begin // 12 hours
                        hh_reg <= 8'b0001; // 01 hours
                        pm_reg <= ~pm_reg; // toggle AM/PM
                    end else if (hh_reg == 8'b1010) begin // 10 hours
                        hh_reg <= 8'b0001; // 11 hours
                    end
                end
            end
        end
    end
    
    assign pm = pm_reg;
    assign hh = hh_reg;
    assign mm = mm_reg;
    assign ss = ss_reg;
    
endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [7:0] hh_reg, mm_reg, ss_reg;
    reg pm_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            hh_reg <= 8'b0001; // 12
            mm_reg <= 8'b0000; // 00
            ss_reg <= 8'b0000; // 00
            pm_reg <= 1'b0; // AM
        end else if (ena) begin
            ss_reg <= ss_reg + 1;
            if (ss_reg == 8'b0110) begin // 59 seconds
                ss_reg <= 8'b0000; // 00 seconds
                mm_reg <= mm_reg + 1;
                if (mm_reg == 8'b0110) begin // 59 minutes
                    mm_reg <= 8'b0000; // 00 minutes
                    hh_reg <= hh_reg + 1;
                    if (hh_reg == 8'b1100) begin // 12 hours
                        hh_reg <= 8'b0001; // 01 hours
                        pm_reg <= ~pm_reg; // toggle AM/PM
                    end else if (hh_reg == 8'b1010) begin // 10 hours
                        hh_reg <= 8'b0001; // 11 hours
                    end
                end
            end
        end
    end
    
    assign pm = pm_reg;
    assign hh = hh_reg;
    assign mm = mm_reg;
    assign ss = ss_reg;
    
endmodule
"
"    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if(reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if(ena) begin
            seconds_ones <= (seconds_ones == 4'b1001) ? 4'b0000 : seconds_ones + 1;
            if(seconds_ones == 4'b0000) begin
                seconds_tens <= (seconds_tens == 4'b0101) ? 4'b0000 : seconds_tens + 1;
                if(seconds_tens == 4'b0000) begin
                    minutes_ones <= (minutes_ones == 4'b1001) ? 4'b0000 : minutes_ones + 1;
                    if(minutes_ones == 4'b0000) begin
                        minutes_tens <= (minutes_tens == 4'b0101) ? 4'b0000 : minutes_tens + 1;
                        if(minutes_tens == 4'b0000) begin
                            hours_ones <= (hours_ones == 4'b1001) ? 4'b0000 : hours_ones + 1;
                            if(hours_ones == 4'b0000) begin
                                hours_tens <= (hours_tens == 4'b0001) ? 4'b0000 : hours_tens + 1;
                                pm <= (hours_tens == 4'b0001) ? ~pm : pm;
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
",-0.5,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if(reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if(ena) begin
            seconds_ones <= (seconds_ones == 4'b1001) ? 4'b0000 : seconds_ones + 1;
            if(seconds_ones == 4'b0000) begin
                seconds_tens <= (seconds_tens == 4'b0101) ? 4'b0000 : seconds_tens + 1;
                if(seconds_tens == 4'b0000) begin
                    minutes_ones <= (minutes_ones == 4'b1001) ? 4'b0000 : minutes_ones + 1;
                    if(minutes_ones == 4'b0000) begin
                        minutes_tens <= (minutes_tens == 4'b0101) ? 4'b0000 : minutes_tens + 1;
                        if(minutes_tens == 4'b0000) begin
                            hours_ones <= (hours_ones == 4'b1001) ? 4'b0000 : hours_ones + 1;
                            if(hours_ones == 4'b0000) begin
                                hours_tens <= (hours_tens == 4'b0001) ? 4'b0000 : hours_tens + 1;
                                pm <= (hours_tens == 4'b0001) ? ~pm : pm;
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if(reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if(ena) begin
            seconds_ones <= (seconds_ones == 4'b1001) ? 4'b0000 : seconds_ones + 1;
            if(seconds_ones == 4'b0000) begin
                seconds_tens <= (seconds_tens == 4'b0101) ? 4'b0000 : seconds_tens + 1;
                if(seconds_tens == 4'b0000) begin
                    minutes_ones <= (minutes_ones == 4'b1001) ? 4'b0000 : minutes_ones + 1;
                    if(minutes_ones == 4'b0000) begin
                        minutes_tens <= (minutes_tens == 4'b0101) ? 4'b0000 : minutes_tens + 1;
                        if(minutes_tens == 4'b0000) begin
                            hours_ones <= (hours_ones == 4'b1001) ? 4'b0000 : hours_ones + 1;
                            if(hours_ones == 4'b0000) begin
                                hours_tens <= (hours_tens == 4'b0001) ? 4'b0000 : hours_tens + 1;
                                pm <= (hours_tens == 4'b0001) ? ~pm : pm;
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
"
"
    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if(reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else begin
            if(ena) begin
                if(seconds_tens == 4'b0101 && seconds_ones == 4'b1001) begin
                    seconds_tens <= 4'b0000;
                    seconds_ones <= 4'b0000;
                    if(minutes_tens == 4'b0101 && minutes_ones == 4'b1001) begin
                        minutes_tens <= 4'b0000;
                        minutes_ones <= 4'b0000;
                        if(hours_tens == 4'b0001 && hours_ones == 4'b0001) begin
                            hours_tens <= 4'b0000;
                            hours_ones <= 4'b0000;
                            pm <= ~pm;
                        end else if(hours_ones == 4'b1001) begin
                            hours_tens <= hours_tens + 1;
                            hours_ones <= 4'b0000;
                        end else begin
                            hours_ones <= hours_ones + 1;
                        end
                    end else if(minutes_ones == 4'b1001) begin
                        minutes_tens <= minutes_tens + 1;
                        minutes_ones <= 4'b0000;
                    end else begin
                        minutes_ones <= minutes_ones + 1;
                    end
                end else if(seconds_ones == 4'b1001) begin
                    seconds_tens <= seconds_tens + 1;
                    seconds_ones <= 4'b0000;
                end else begin
                    seconds_ones <= seconds_ones + 1;
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;

endmodule
",-1.0,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);


    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if(reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else begin
            if(ena) begin
                if(seconds_tens == 4'b0101 && seconds_ones == 4'b1001) begin
                    seconds_tens <= 4'b0000;
                    seconds_ones <= 4'b0000;
                    if(minutes_tens == 4'b0101 && minutes_ones == 4'b1001) begin
                        minutes_tens <= 4'b0000;
                        minutes_ones <= 4'b0000;
                        if(hours_tens == 4'b0001 && hours_ones == 4'b0001) begin
                            hours_tens <= 4'b0000;
                            hours_ones <= 4'b0000;
                            pm <= ~pm;
                        end else if(hours_ones == 4'b1001) begin
                            hours_tens <= hours_tens + 1;
                            hours_ones <= 4'b0000;
                        end else begin
                            hours_ones <= hours_ones + 1;
                        end
                    end else if(minutes_ones == 4'b1001) begin
                        minutes_tens <= minutes_tens + 1;
                        minutes_ones <= 4'b0000;
                    end else begin
                        minutes_ones <= minutes_ones + 1;
                    end
                end else if(seconds_ones == 4'b1001) begin
                    seconds_tens <= seconds_tens + 1;
                    seconds_ones <= 4'b0000;
                end else begin
                    seconds_ones <= seconds_ones + 1;
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;

endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);


    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if(reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else begin
            if(ena) begin
                if(seconds_tens == 4'b0101 && seconds_ones == 4'b1001) begin
                    seconds_tens <= 4'b0000;
                    seconds_ones <= 4'b0000;
                    if(minutes_tens == 4'b0101 && minutes_ones == 4'b1001) begin
                        minutes_tens <= 4'b0000;
                        minutes_ones <= 4'b0000;
                        if(hours_tens == 4'b0001 && hours_ones == 4'b0001) begin
                            hours_tens <= 4'b0000;
                            hours_ones <= 4'b0000;
                            pm <= ~pm;
                        end else if(hours_ones == 4'b1001) begin
                            hours_tens <= hours_tens + 1;
                            hours_ones <= 4'b0000;
                        end else begin
                            hours_ones <= hours_ones + 1;
                        end
                    end else if(minutes_ones == 4'b1001) begin
                        minutes_tens <= minutes_tens + 1;
                        minutes_ones <= 4'b0000;
                    end else begin
                        minutes_ones <= minutes_ones + 1;
                    end
                end else if(seconds_ones == 4'b1001) begin
                    seconds_tens <= seconds_tens + 1;
                    seconds_ones <= 4'b0000;
                end else begin
                    seconds_ones <= seconds_ones + 1;
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;

endmodule
"
"
    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [5:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [5:0] seconds_tens;
    reg [3:0] seconds_ones;
    reg pm;
    
    always @(posedge clk) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 6'b000000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 6'b000000;
            seconds_ones <= 4'b0000;
            pm <= 0;
        end else if (ena) begin
            if (seconds_tens == 6'b010110 && seconds_ones == 4'b1001 && minutes_ones == 4'b1001 && hours_ones == 4'b1001) begin
                hours_tens <= 4'b0000;
                hours_ones <= 4'b0000;
                minutes_tens <= 6'b000000;
                minutes_ones <= 4'b0000;
                seconds_tens <= 6'b000000;
                seconds_ones <= 4'b0000;
                pm <= ~pm;
            end else begin
                seconds_ones <= seconds_ones + 1;
                if (seconds_ones == 4'b1010) begin
                    seconds_ones <= 4'b0000;
                    seconds_tens <= seconds_tens + 1;
                end
                if (seconds_tens == 6'b0110) begin
                    seconds_tens <= 6'b000000;
                    minutes_ones <= minutes_ones + 1;
                end
                if (minutes_ones == 4'b1010) begin
                    minutes_ones <= 4'b0000;
                    minutes_tens <= minutes_tens + 1;
                end
                if (minutes_tens == 6'b0110) begin
                    minutes_tens <= 6'b000000;
                    hours_ones <= hours_ones + 1;
                end
                if (hours_ones == 4'b1010) begin
                    hours_ones <= 4'b0000;
                    hours_tens <= hours_tens + 1;
                end
                if (hours_tens == 4'b0001 && hours_ones == 4'b0000) begin
                    hours_tens <= 4'b0000;
                    hours_ones <= 4'b0001;
                end
            end
        end
    end
    
    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;
endmodule
",-1.0,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);


    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [5:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [5:0] seconds_tens;
    reg [3:0] seconds_ones;
    reg pm;
    
    always @(posedge clk) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 6'b000000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 6'b000000;
            seconds_ones <= 4'b0000;
            pm <= 0;
        end else if (ena) begin
            if (seconds_tens == 6'b010110 && seconds_ones == 4'b1001 && minutes_ones == 4'b1001 && hours_ones == 4'b1001) begin
                hours_tens <= 4'b0000;
                hours_ones <= 4'b0000;
                minutes_tens <= 6'b000000;
                minutes_ones <= 4'b0000;
                seconds_tens <= 6'b000000;
                seconds_ones <= 4'b0000;
                pm <= ~pm;
            end else begin
                seconds_ones <= seconds_ones + 1;
                if (seconds_ones == 4'b1010) begin
                    seconds_ones <= 4'b0000;
                    seconds_tens <= seconds_tens + 1;
                end
                if (seconds_tens == 6'b0110) begin
                    seconds_tens <= 6'b000000;
                    minutes_ones <= minutes_ones + 1;
                end
                if (minutes_ones == 4'b1010) begin
                    minutes_ones <= 4'b0000;
                    minutes_tens <= minutes_tens + 1;
                end
                if (minutes_tens == 6'b0110) begin
                    minutes_tens <= 6'b000000;
                    hours_ones <= hours_ones + 1;
                end
                if (hours_ones == 4'b1010) begin
                    hours_ones <= 4'b0000;
                    hours_tens <= hours_tens + 1;
                end
                if (hours_tens == 4'b0001 && hours_ones == 4'b0000) begin
                    hours_tens <= 4'b0000;
                    hours_ones <= 4'b0001;
                end
            end
        end
    end
    
    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;
endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);


    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [5:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [5:0] seconds_tens;
    reg [3:0] seconds_ones;
    reg pm;
    
    always @(posedge clk) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 6'b000000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 6'b000000;
            seconds_ones <= 4'b0000;
            pm <= 0;
        end else if (ena) begin
            if (seconds_tens == 6'b010110 && seconds_ones == 4'b1001 && minutes_ones == 4'b1001 && hours_ones == 4'b1001) begin
                hours_tens <= 4'b0000;
                hours_ones <= 4'b0000;
                minutes_tens <= 6'b000000;
                minutes_ones <= 4'b0000;
                seconds_tens <= 6'b000000;
                seconds_ones <= 4'b0000;
                pm <= ~pm;
            end else begin
                seconds_ones <= seconds_ones + 1;
                if (seconds_ones == 4'b1010) begin
                    seconds_ones <= 4'b0000;
                    seconds_tens <= seconds_tens + 1;
                end
                if (seconds_tens == 6'b0110) begin
                    seconds_tens <= 6'b000000;
                    minutes_ones <= minutes_ones + 1;
                end
                if (minutes_ones == 4'b1010) begin
                    minutes_ones <= 4'b0000;
                    minutes_tens <= minutes_tens + 1;
                end
                if (minutes_tens == 6'b0110) begin
                    minutes_tens <= 6'b000000;
                    hours_ones <= hours_ones + 1;
                end
                if (hours_ones == 4'b1010) begin
                    hours_ones <= 4'b0000;
                    hours_tens <= hours_tens + 1;
                end
                if (hours_tens == 4'b0001 && hours_ones == 4'b0000) begin
                    hours_tens <= 4'b0000;
                    hours_ones <= 4'b0001;
                end
            end
        end
    end
    
    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;
endmodule
"
"
    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [5:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [5:0] seconds_tens;
    reg [3:0] seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if (reset) begin
            pm <= 0;
            hours_tens <= 1;
            hours_ones <= 2;
            minutes_tens <= 0;
            minutes_ones <= 0;
            seconds_tens <= 0;
            seconds_ones <= 0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 10) begin
                seconds_ones <= 0;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 6) begin
                    seconds_tens <= 0;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 10) begin
                        minutes_ones <= 0;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 6) begin
                            minutes_tens <= 0;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 10) begin
                                hours_ones <= 0;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 1 && hours_ones == 3) begin
                                    hours_tens <= 0;
                                    hours_ones <= 1;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
",-0.5,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);


    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [5:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [5:0] seconds_tens;
    reg [3:0] seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if (reset) begin
            pm <= 0;
            hours_tens <= 1;
            hours_ones <= 2;
            minutes_tens <= 0;
            minutes_ones <= 0;
            seconds_tens <= 0;
            seconds_ones <= 0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 10) begin
                seconds_ones <= 0;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 6) begin
                    seconds_tens <= 0;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 10) begin
                        minutes_ones <= 0;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 6) begin
                            minutes_tens <= 0;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 10) begin
                                hours_ones <= 0;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 1 && hours_ones == 3) begin
                                    hours_tens <= 0;
                                    hours_ones <= 1;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);


    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [5:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [5:0] seconds_tens;
    reg [3:0] seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if (reset) begin
            pm <= 0;
            hours_tens <= 1;
            hours_ones <= 2;
            minutes_tens <= 0;
            minutes_ones <= 0;
            seconds_tens <= 0;
            seconds_ones <= 0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 10) begin
                seconds_ones <= 0;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 6) begin
                    seconds_tens <= 0;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 10) begin
                        minutes_ones <= 0;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 6) begin
                            minutes_tens <= 0;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 10) begin
                                hours_ones <= 0;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 1 && hours_ones == 3) begin
                                    hours_tens <= 0;
                                    hours_ones <= 1;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
endmodule
"
"    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [5:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [5:0] seconds_tens;
    reg [3:0] seconds_ones;
    reg pm;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 6'b000000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 6'b000000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 4'b1010) begin
                seconds_ones <= 4'b0000;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 6'b011010) begin
                    seconds_tens <= 6'b000000;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 4'b1010) begin
                        minutes_ones <= 4'b0000;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 6'b011010) begin
                            minutes_tens <= 6'b000000;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 4'b1010) begin
                                hours_ones <= 4'b0000;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;

endmodule
",-1.0,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [5:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [5:0] seconds_tens;
    reg [3:0] seconds_ones;
    reg pm;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 6'b000000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 6'b000000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 4'b1010) begin
                seconds_ones <= 4'b0000;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 6'b011010) begin
                    seconds_tens <= 6'b000000;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 4'b1010) begin
                        minutes_ones <= 4'b0000;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 6'b011010) begin
                            minutes_tens <= 6'b000000;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 4'b1010) begin
                                hours_ones <= 4'b0000;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;

endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens;
    reg [3:0] hours_ones;
    reg [5:0] minutes_tens;
    reg [3:0] minutes_ones;
    reg [5:0] seconds_tens;
    reg [3:0] seconds_ones;
    reg pm;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 6'b000000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 6'b000000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 4'b1010) begin
                seconds_ones <= 4'b0000;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 6'b011010) begin
                    seconds_tens <= 6'b000000;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 4'b1010) begin
                        minutes_ones <= 4'b0000;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 6'b011010) begin
                            minutes_tens <= 6'b000000;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 4'b1010) begin
                                hours_ones <= 4'b0000;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;

endmodule
"
"    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if (reset) begin
            hours_tens <= 4'b0001;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 4'b1010) begin
                seconds_ones <= 4'b0000;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 4'b0110) begin
                    seconds_tens <= 4'b0000;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 4'b1010) begin
                        minutes_ones <= 4'b0000;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 4'b0110) begin
                            minutes_tens <= 4'b0000;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 4'b1010) begin
                                hours_ones <= 4'b0000;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;

endmodule
",-1.0,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if (reset) begin
            hours_tens <= 4'b0001;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 4'b1010) begin
                seconds_ones <= 4'b0000;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 4'b0110) begin
                    seconds_tens <= 4'b0000;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 4'b1010) begin
                        minutes_ones <= 4'b0000;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 4'b0110) begin
                            minutes_tens <= 4'b0000;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 4'b1010) begin
                                hours_ones <= 4'b0000;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;

endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens, hours_ones;
    reg [3:0] minutes_tens, minutes_ones;
    reg [3:0] seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if (reset) begin
            hours_tens <= 4'b0001;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 4'b1010) begin
                seconds_ones <= 4'b0000;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 4'b0110) begin
                    seconds_tens <= 4'b0000;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 4'b1010) begin
                        minutes_ones <= 4'b0000;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 4'b0110) begin
                            minutes_tens <= 4'b0000;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 4'b1010) begin
                                hours_ones <= 4'b0000;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};
    assign pm = pm;

endmodule
"
"    reg [3:0] hours_tens, hours_ones, minutes_tens, minutes_ones, seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 4'b1010) begin
                seconds_ones <= 4'b0000;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 4'b0110) begin
                    seconds_tens <= 4'b0000;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 4'b1010) begin
                        minutes_ones <= 4'b0000;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 4'b0110) begin
                            minutes_tens <= 4'b0000;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 4'b1010) begin
                                hours_ones <= 4'b0000;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};

endmodule
",-0.5,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens, hours_ones, minutes_tens, minutes_ones, seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 4'b1010) begin
                seconds_ones <= 4'b0000;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 4'b0110) begin
                    seconds_tens <= 4'b0000;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 4'b1010) begin
                        minutes_ones <= 4'b0000;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 4'b0110) begin
                            minutes_tens <= 4'b0000;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 4'b1010) begin
                                hours_ones <= 4'b0000;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};

endmodule
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);

    reg [3:0] hours_tens, hours_ones, minutes_tens, minutes_ones, seconds_tens, seconds_ones;
    reg pm;

    always @(posedge clk) begin
        if (reset) begin
            hours_tens <= 4'b0000;
            hours_ones <= 4'b0000;
            minutes_tens <= 4'b0000;
            minutes_ones <= 4'b0000;
            seconds_tens <= 4'b0000;
            seconds_ones <= 4'b0000;
            pm <= 1'b0;
        end else if (ena) begin
            seconds_ones <= seconds_ones + 1;
            if (seconds_ones == 4'b1010) begin
                seconds_ones <= 4'b0000;
                seconds_tens <= seconds_tens + 1;
                if (seconds_tens == 4'b0110) begin
                    seconds_tens <= 4'b0000;
                    minutes_ones <= minutes_ones + 1;
                    if (minutes_ones == 4'b1010) begin
                        minutes_ones <= 4'b0000;
                        minutes_tens <= minutes_tens + 1;
                        if (minutes_tens == 4'b0110) begin
                            minutes_tens <= 4'b0000;
                            hours_ones <= hours_ones + 1;
                            if (hours_ones == 4'b1010) begin
                                hours_ones <= 4'b0000;
                                hours_tens <= hours_tens + 1;
                                if (hours_tens == 4'b0001) begin
                                    hours_tens <= 4'b0000;
                                    pm <= ~pm;
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    assign hh = {hours_tens, hours_ones};
    assign mm = {minutes_tens, minutes_ones};
    assign ss = {seconds_tens, seconds_ones};

endmodule
"
"
    reg [3:0] count; // Counter register
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000; // Reset the counter to 0
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000; // Reset the counter to 0 when it reaches 9
            end else begin
                count <= count + 1; // Increment the counter
            end
        end
    end
    
    assign q = count; // Output the counter value
endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count; // Counter register
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000; // Reset the counter to 0
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000; // Reset the counter to 0 when it reaches 9
            end else begin
                count <= count + 1; // Increment the counter
            end
        end
    end
    
    assign q = count; // Output the counter value
endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count; // Counter register
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000; // Reset the counter to 0
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000; // Reset the counter to 0 when it reaches 9
            end else begin
                count <= count + 1; // Increment the counter
            end
        end
    end
    
    assign q = count; // Output the counter value
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= (count == 4'b1001) ? 4'b0000 : count + 1;
        end
    end

    assign q = count;
endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= (count == 4'b1001) ? 4'b0000 : count + 1;
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= (count == 4'b1001) ? 4'b0000 : count + 1;
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
"
"
    reg [3:0] count;
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end
    
    assign q = count;
endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end
    
    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end
    
    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            if (counter == 4'b1001) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;
endmodule
",-0.5,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            if (counter == 4'b1001) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;
endmodule
","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            if (counter == 4'b1001) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            counter <= counter + 1;
        end
    end

    assign q = counter;

endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            counter <= counter + 1;
        end
    end

    assign q = counter;

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            counter <= counter + 1;
        end
    end

    assign q = counter;

endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            counter <= counter + 1;
        end
    end

    assign q = counter;
endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            counter <= counter + 1;
        end
    end

    assign q = counter;
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            counter <= counter + 1;
        end
    end

    assign q = counter;
endmodule
"
"
    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            if (counter == 4'b1111) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;
endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            if (counter == 4'b1111) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            if (counter == 4'b1111) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;
endmodule
"
"
    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            counter <= counter + 1;
        end
    end

    assign q = counter;
endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            counter <= counter + 1;
        end
    end

    assign q = counter;
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else begin
            counter <= counter + 1;
        end
    end

    assign q = counter;
endmodule
"
"    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
",-0.5,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"    reg [3:0] q;

    always @(posedge clk) begin
        if (reset) begin
            q <= 4'b0001;
        end else begin
            if (q == 4'b1010) begin
                q <= 4'b0001;
            end else begin
                q <= q + 1;
            end
        end
    end

endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    reg [3:0] q;

    always @(posedge clk) begin
        if (reset) begin
            q <= 4'b0001;
        end else begin
            if (q == 4'b1010) begin
                q <= 4'b0001;
            end else begin
                q <= q + 1;
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    reg [3:0] q;

    always @(posedge clk) begin
        if (reset) begin
            q <= 4'b0001;
        end else begin
            if (q == 4'b1010) begin
                q <= 4'b0001;
            end else begin
                q <= q + 1;
            end
        end
    end

endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else begin
            if (count == 4'b1010) begin
                count <= 4'b0001;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"// Instantiate one-digit decade counters
decade_counter ones_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[0]),
    .q(q[3:0])
);

decade_counter tens_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[1]),
    .q(q[7:4])
);

decade_counter hundreds_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[2]),
    .q(q[11:8])
);

decade_counter thousands_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[3]),
    .q(q[15:12])
);

// Output enable signals for tens, hundreds, and thousands digits
assign ena = {ena[0], ena[1], ena[2], ena[3]};

endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);

// Instantiate one-digit decade counters
decade_counter ones_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[0]),
    .q(q[3:0])
);

decade_counter tens_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[1]),
    .q(q[7:4])
);

decade_counter hundreds_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[2]),
    .q(q[11:8])
);

decade_counter thousands_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[3]),
    .q(q[15:12])
);

// Output enable signals for tens, hundreds, and thousands digits
assign ena = {ena[0], ena[1], ena[2], ena[3]};

endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);

// Instantiate one-digit decade counters
decade_counter ones_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[0]),
    .q(q[3:0])
);

decade_counter tens_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[1]),
    .q(q[7:4])
);

decade_counter hundreds_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[2]),
    .q(q[11:8])
);

decade_counter thousands_digit (
    .clk(clk),
    .reset(reset),
    .enable(ena[3]),
    .q(q[15:12])
);

// Output enable signals for tens, hundreds, and thousands digits
assign ena = {ena[0], ena[1], ena[2], ena[3]};

endmodule
"
"    reg [3:0] ones_digit;
    reg [3:0] tens_digit;
    reg [3:0] hundreds_digit;
    reg [3:0] thousands_digit;
    
    reg [2:0] count;
    
    // Instantiate one-digit decade counters
    decade_counter ones_counter (.clk(clk), .reset(reset), .q(ones_digit));
    decade_counter tens_counter (.clk(clk), .reset(reset), .q(tens_digit));
    decade_counter hundreds_counter (.clk(clk), .reset(reset), .q(hundreds_digit));
    decade_counter thousands_counter (.clk(clk), .reset(reset), .q(thousands_digit));
    
    always @(posedge clk) begin
        if (reset) begin
            ones_digit <= 4'b0000;
            tens_digit <= 4'b0000;
            hundreds_digit <= 4'b0000;
            thousands_digit <= 4'b0000;
            count <= 3'b000;
        end else begin
            // Increment the ones digit every clock cycle
            if (ones_digit == 4'b1001) begin
                ones_digit <= 4'b0000;
                // Increment the tens digit when ones digit wraps around
                if (tens_digit == 4'b1001) begin
                    tens_digit <= 4'b0000;
                    // Increment the hundreds digit when tens digit wraps around
                    if (hundreds_digit == 4'b1001) begin
                        hundreds_digit <= 4'b0000;
                        // Increment the thousands digit when hundreds digit wraps around
                        if (thousands_digit == 4'b1001) begin
                            thousands_digit <= 4'b0000;
                        end else begin
                            thousands_digit <= thousands_digit + 1;
                        end
                    end else begin
                        hundreds_digit <= hundreds_digit + 1;
                    end
                end else begin
                    tens_digit <= tens_digit + 1;
                end
            end else begin
                ones_digit <= ones_digit + 1;
            end
            
            // Generate enable signals for tens, hundreds, and thousands digits
            count <= count + 1;
            if (count == 3'b000) begin
                ena <= 3'b111;
            end else begin
                ena <= 3'b000;
            end
        end
    end
    
    // Concatenate the digits to form the 4-digit BCD counter output
    assign q = {thousands_digit, hundreds_digit, tens_digit, ones_digit};
    
endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);

    reg [3:0] ones_digit;
    reg [3:0] tens_digit;
    reg [3:0] hundreds_digit;
    reg [3:0] thousands_digit;
    
    reg [2:0] count;
    
    // Instantiate one-digit decade counters
    decade_counter ones_counter (.clk(clk), .reset(reset), .q(ones_digit));
    decade_counter tens_counter (.clk(clk), .reset(reset), .q(tens_digit));
    decade_counter hundreds_counter (.clk(clk), .reset(reset), .q(hundreds_digit));
    decade_counter thousands_counter (.clk(clk), .reset(reset), .q(thousands_digit));
    
    always @(posedge clk) begin
        if (reset) begin
            ones_digit <= 4'b0000;
            tens_digit <= 4'b0000;
            hundreds_digit <= 4'b0000;
            thousands_digit <= 4'b0000;
            count <= 3'b000;
        end else begin
            // Increment the ones digit every clock cycle
            if (ones_digit == 4'b1001) begin
                ones_digit <= 4'b0000;
                // Increment the tens digit when ones digit wraps around
                if (tens_digit == 4'b1001) begin
                    tens_digit <= 4'b0000;
                    // Increment the hundreds digit when tens digit wraps around
                    if (hundreds_digit == 4'b1001) begin
                        hundreds_digit <= 4'b0000;
                        // Increment the thousands digit when hundreds digit wraps around
                        if (thousands_digit == 4'b1001) begin
                            thousands_digit <= 4'b0000;
                        end else begin
                            thousands_digit <= thousands_digit + 1;
                        end
                    end else begin
                        hundreds_digit <= hundreds_digit + 1;
                    end
                end else begin
                    tens_digit <= tens_digit + 1;
                end
            end else begin
                ones_digit <= ones_digit + 1;
            end
            
            // Generate enable signals for tens, hundreds, and thousands digits
            count <= count + 1;
            if (count == 3'b000) begin
                ena <= 3'b111;
            end else begin
                ena <= 3'b000;
            end
        end
    end
    
    // Concatenate the digits to form the 4-digit BCD counter output
    assign q = {thousands_digit, hundreds_digit, tens_digit, ones_digit};
    
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);

    reg [3:0] ones_digit;
    reg [3:0] tens_digit;
    reg [3:0] hundreds_digit;
    reg [3:0] thousands_digit;
    
    reg [2:0] count;
    
    // Instantiate one-digit decade counters
    decade_counter ones_counter (.clk(clk), .reset(reset), .q(ones_digit));
    decade_counter tens_counter (.clk(clk), .reset(reset), .q(tens_digit));
    decade_counter hundreds_counter (.clk(clk), .reset(reset), .q(hundreds_digit));
    decade_counter thousands_counter (.clk(clk), .reset(reset), .q(thousands_digit));
    
    always @(posedge clk) begin
        if (reset) begin
            ones_digit <= 4'b0000;
            tens_digit <= 4'b0000;
            hundreds_digit <= 4'b0000;
            thousands_digit <= 4'b0000;
            count <= 3'b000;
        end else begin
            // Increment the ones digit every clock cycle
            if (ones_digit == 4'b1001) begin
                ones_digit <= 4'b0000;
                // Increment the tens digit when ones digit wraps around
                if (tens_digit == 4'b1001) begin
                    tens_digit <= 4'b0000;
                    // Increment the hundreds digit when tens digit wraps around
                    if (hundreds_digit == 4'b1001) begin
                        hundreds_digit <= 4'b0000;
                        // Increment the thousands digit when hundreds digit wraps around
                        if (thousands_digit == 4'b1001) begin
                            thousands_digit <= 4'b0000;
                        end else begin
                            thousands_digit <= thousands_digit + 1;
                        end
                    end else begin
                        hundreds_digit <= hundreds_digit + 1;
                    end
                end else begin
                    tens_digit <= tens_digit + 1;
                end
            end else begin
                ones_digit <= ones_digit + 1;
            end
            
            // Generate enable signals for tens, hundreds, and thousands digits
            count <= count + 1;
            if (count == 3'b000) begin
                ena <= 3'b111;
            end else begin
                ena <= 3'b000;
            end
        end
    end
    
    // Concatenate the digits to form the 4-digit BCD counter output
    assign q = {thousands_digit, hundreds_digit, tens_digit, ones_digit};
    
endmodule
"
"
    reg [3:0] ones_digit;
    reg [3:0] tens_digit;
    reg [3:0] hundreds_digit;
    reg [3:0] thousands_digit;
    
    reg [2:0] ena_temp;
    
    one_digit_counter ones_counter(
        .clk(clk),
        .reset(reset),
        .q(ones_digit),
        .enable(ena_temp[0])
    );
    
    one_digit_counter tens_counter(
        .clk(clk),
        .reset(reset),
        .q(tens_digit),
        .enable(ena_temp[1])
    );
    
    one_digit_counter hundreds_counter(
        .clk(clk),
        .reset(reset),
        .q(hundreds_digit),
        .enable(ena_temp[2])
    );
    
    one_digit_counter thousands_counter(
        .clk(clk),
        .reset(reset),
        .q(thousands_digit),
        .enable(1'b1) // Always increment thousands digit
    );
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            ones_digit <= 4'b0000;
            tens_digit <= 4'b0000;
            hundreds_digit <= 4'b0000;
            thousands_digit <= 4'b0000;
            ena_temp <= 3'b000;
        end else begin
            if (ones_digit == 4'b1001) begin
                ones_digit <= 4'b0000;
                ena_temp <= ena_temp | 1'b1;
            end else begin
                ones_digit <= ones_digit + 4'b0001;
            end
            
            if (tens_digit == 4'b1001) begin
                tens_digit <= 4'b0000;
                ena_temp <= ena_temp | 1'b10;
            end else begin
                tens_digit <= tens_digit + 4'b0001;
            end
            
            if (hundreds_digit == 4'b1001) begin
                hundreds_digit <= 4'b0000;
                ena_temp <= ena_temp | 1'b100;
            end else begin
                hundreds_digit <= hundreds_digit + 4'b0001;
            end
        end
    end
    
    assign ena = ena_temp;
    assign q = {thousands_digit, hundreds_digit, tens_digit, ones_digit};
endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    reg [3:0] ones_digit;
    reg [3:0] tens_digit;
    reg [3:0] hundreds_digit;
    reg [3:0] thousands_digit;
    
    reg [2:0] ena_temp;
    
    one_digit_counter ones_counter(
        .clk(clk),
        .reset(reset),
        .q(ones_digit),
        .enable(ena_temp[0])
    );
    
    one_digit_counter tens_counter(
        .clk(clk),
        .reset(reset),
        .q(tens_digit),
        .enable(ena_temp[1])
    );
    
    one_digit_counter hundreds_counter(
        .clk(clk),
        .reset(reset),
        .q(hundreds_digit),
        .enable(ena_temp[2])
    );
    
    one_digit_counter thousands_counter(
        .clk(clk),
        .reset(reset),
        .q(thousands_digit),
        .enable(1'b1) // Always increment thousands digit
    );
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            ones_digit <= 4'b0000;
            tens_digit <= 4'b0000;
            hundreds_digit <= 4'b0000;
            thousands_digit <= 4'b0000;
            ena_temp <= 3'b000;
        end else begin
            if (ones_digit == 4'b1001) begin
                ones_digit <= 4'b0000;
                ena_temp <= ena_temp | 1'b1;
            end else begin
                ones_digit <= ones_digit + 4'b0001;
            end
            
            if (tens_digit == 4'b1001) begin
                tens_digit <= 4'b0000;
                ena_temp <= ena_temp | 1'b10;
            end else begin
                tens_digit <= tens_digit + 4'b0001;
            end
            
            if (hundreds_digit == 4'b1001) begin
                hundreds_digit <= 4'b0000;
                ena_temp <= ena_temp | 1'b100;
            end else begin
                hundreds_digit <= hundreds_digit + 4'b0001;
            end
        end
    end
    
    assign ena = ena_temp;
    assign q = {thousands_digit, hundreds_digit, tens_digit, ones_digit};
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    reg [3:0] ones_digit;
    reg [3:0] tens_digit;
    reg [3:0] hundreds_digit;
    reg [3:0] thousands_digit;
    
    reg [2:0] ena_temp;
    
    one_digit_counter ones_counter(
        .clk(clk),
        .reset(reset),
        .q(ones_digit),
        .enable(ena_temp[0])
    );
    
    one_digit_counter tens_counter(
        .clk(clk),
        .reset(reset),
        .q(tens_digit),
        .enable(ena_temp[1])
    );
    
    one_digit_counter hundreds_counter(
        .clk(clk),
        .reset(reset),
        .q(hundreds_digit),
        .enable(ena_temp[2])
    );
    
    one_digit_counter thousands_counter(
        .clk(clk),
        .reset(reset),
        .q(thousands_digit),
        .enable(1'b1) // Always increment thousands digit
    );
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            ones_digit <= 4'b0000;
            tens_digit <= 4'b0000;
            hundreds_digit <= 4'b0000;
            thousands_digit <= 4'b0000;
            ena_temp <= 3'b000;
        end else begin
            if (ones_digit == 4'b1001) begin
                ones_digit <= 4'b0000;
                ena_temp <= ena_temp | 1'b1;
            end else begin
                ones_digit <= ones_digit + 4'b0001;
            end
            
            if (tens_digit == 4'b1001) begin
                tens_digit <= 4'b0000;
                ena_temp <= ena_temp | 1'b10;
            end else begin
                tens_digit <= tens_digit + 4'b0001;
            end
            
            if (hundreds_digit == 4'b1001) begin
                hundreds_digit <= 4'b0000;
                ena_temp <= ena_temp | 1'b100;
            end else begin
                hundreds_digit <= hundreds_digit + 4'b0001;
            end
        end
    end
    
    assign ena = ena_temp;
    assign q = {thousands_digit, hundreds_digit, tens_digit, ones_digit};
endmodule
"
"
    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    wire ena0;
    wire ena1;
    wire ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (
        .clk(clk),
        .reset(reset),
        .q(q0),
        .ena(ena0)
    );
    
    decade_counter counter1 (
        .clk(clk),
        .reset(reset),
        .q(q1),
        .ena(ena1)
    );
    
    decade_counter counter2 (
        .clk(clk),
        .reset(reset),
        .q(q2),
        .ena(ena2)
    );
    
    decade_counter counter3 (
        .clk(clk),
        .reset(reset),
        .q(q3),
        .ena()
    );
    
    // Combine the outputs of the one-digit counters to form a 4-digit counter
    assign q = {q3, q2, q1, q0};
    assign ena = {ena2, ena1, ena0};
endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    wire ena0;
    wire ena1;
    wire ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (
        .clk(clk),
        .reset(reset),
        .q(q0),
        .ena(ena0)
    );
    
    decade_counter counter1 (
        .clk(clk),
        .reset(reset),
        .q(q1),
        .ena(ena1)
    );
    
    decade_counter counter2 (
        .clk(clk),
        .reset(reset),
        .q(q2),
        .ena(ena2)
    );
    
    decade_counter counter3 (
        .clk(clk),
        .reset(reset),
        .q(q3),
        .ena()
    );
    
    // Combine the outputs of the one-digit counters to form a 4-digit counter
    assign q = {q3, q2, q1, q0};
    assign ena = {ena2, ena1, ena0};
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    wire ena0;
    wire ena1;
    wire ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (
        .clk(clk),
        .reset(reset),
        .q(q0),
        .ena(ena0)
    );
    
    decade_counter counter1 (
        .clk(clk),
        .reset(reset),
        .q(q1),
        .ena(ena1)
    );
    
    decade_counter counter2 (
        .clk(clk),
        .reset(reset),
        .q(q2),
        .ena(ena2)
    );
    
    decade_counter counter3 (
        .clk(clk),
        .reset(reset),
        .q(q3),
        .ena()
    );
    
    // Combine the outputs of the one-digit counters to form a 4-digit counter
    assign q = {q3, q2, q1, q0};
    assign ena = {ena2, ena1, ena0};
endmodule
"
"
    wire [3:0] q0, q1, q2, q3;
    wire ena0, ena1, ena2;

    one_digit_counter digit0 (
        .clk(clk),
        .reset(reset),
        .ena(1'b1),
        .q(q0),
        .enable(ena0)
    );

    one_digit_counter digit1 (
        .clk(clk),
        .reset(reset),
        .ena(ena0),
        .q(q1),
        .enable(ena1)
    );

    one_digit_counter digit2 (
        .clk(clk),
        .reset(reset),
        .ena(ena1),
        .q(q2),
        .enable(ena2)
    );

    one_digit_counter digit3 (
        .clk(clk),
        .reset(reset),
        .ena(ena2),
        .q(q3),
        .enable(1'b1)
    );

    assign ena = {ena2, ena1, ena0};
    assign q = {q3, q2, q1, q0};
endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0, q1, q2, q3;
    wire ena0, ena1, ena2;

    one_digit_counter digit0 (
        .clk(clk),
        .reset(reset),
        .ena(1'b1),
        .q(q0),
        .enable(ena0)
    );

    one_digit_counter digit1 (
        .clk(clk),
        .reset(reset),
        .ena(ena0),
        .q(q1),
        .enable(ena1)
    );

    one_digit_counter digit2 (
        .clk(clk),
        .reset(reset),
        .ena(ena1),
        .q(q2),
        .enable(ena2)
    );

    one_digit_counter digit3 (
        .clk(clk),
        .reset(reset),
        .ena(ena2),
        .q(q3),
        .enable(1'b1)
    );

    assign ena = {ena2, ena1, ena0};
    assign q = {q3, q2, q1, q0};
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0, q1, q2, q3;
    wire ena0, ena1, ena2;

    one_digit_counter digit0 (
        .clk(clk),
        .reset(reset),
        .ena(1'b1),
        .q(q0),
        .enable(ena0)
    );

    one_digit_counter digit1 (
        .clk(clk),
        .reset(reset),
        .ena(ena0),
        .q(q1),
        .enable(ena1)
    );

    one_digit_counter digit2 (
        .clk(clk),
        .reset(reset),
        .ena(ena1),
        .q(q2),
        .enable(ena2)
    );

    one_digit_counter digit3 (
        .clk(clk),
        .reset(reset),
        .ena(ena2),
        .q(q3),
        .enable(1'b1)
    );

    assign ena = {ena2, ena1, ena0};
    assign q = {q3, q2, q1, q0};
endmodule
"
"    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    wire ena0;
    wire ena1;
    wire ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0(.clk(clk), .reset(reset), .q(q0), .ena(ena0));
    decade_counter counter1(.clk(clk), .reset(ena0), .q(q1), .ena(ena1));
    decade_counter counter2(.clk(clk), .reset(ena1), .q(q2), .ena(ena2));
    decade_counter counter3(.clk(clk), .reset(ena2), .q(q3), .ena(1'b1));
    
    // Output signals
    assign ena = {ena2, ena1, ena0};
    assign q = {q3, q2, q1, q0};
endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);

    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    wire ena0;
    wire ena1;
    wire ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0(.clk(clk), .reset(reset), .q(q0), .ena(ena0));
    decade_counter counter1(.clk(clk), .reset(ena0), .q(q1), .ena(ena1));
    decade_counter counter2(.clk(clk), .reset(ena1), .q(q2), .ena(ena2));
    decade_counter counter3(.clk(clk), .reset(ena2), .q(q3), .ena(1'b1));
    
    // Output signals
    assign ena = {ena2, ena1, ena0};
    assign q = {q3, q2, q1, q0};
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);

    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    wire ena0;
    wire ena1;
    wire ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0(.clk(clk), .reset(reset), .q(q0), .ena(ena0));
    decade_counter counter1(.clk(clk), .reset(ena0), .q(q1), .ena(ena1));
    decade_counter counter2(.clk(clk), .reset(ena1), .q(q2), .ena(ena2));
    decade_counter counter3(.clk(clk), .reset(ena2), .q(q3), .ena(1'b1));
    
    // Output signals
    assign ena = {ena2, ena1, ena0};
    assign q = {q3, q2, q1, q0};
endmodule
"
"
    wire [3:0] q0, q1, q2, q3;
    wire [3:1] ena0, ena1, ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (.clk(clk), .reset(reset), .enable(ena0), .q(q0));
    decade_counter counter1 (.clk(clk), .reset(reset), .enable(ena1), .q(q1));
    decade_counter counter2 (.clk(clk), .reset(reset), .enable(ena2), .q(q2));
    decade_counter counter3 (.clk(clk), .reset(reset), .enable(), .q(q3);
    
    // Connect outputs
    assign ena = {ena2, ena1, ena0};
    assign q = {q3, q2, q1, q0};
endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0, q1, q2, q3;
    wire [3:1] ena0, ena1, ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (.clk(clk), .reset(reset), .enable(ena0), .q(q0));
    decade_counter counter1 (.clk(clk), .reset(reset), .enable(ena1), .q(q1));
    decade_counter counter2 (.clk(clk), .reset(reset), .enable(ena2), .q(q2));
    decade_counter counter3 (.clk(clk), .reset(reset), .enable(), .q(q3);
    
    // Connect outputs
    assign ena = {ena2, ena1, ena0};
    assign q = {q3, q2, q1, q0};
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0, q1, q2, q3;
    wire [3:1] ena0, ena1, ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (.clk(clk), .reset(reset), .enable(ena0), .q(q0));
    decade_counter counter1 (.clk(clk), .reset(reset), .enable(ena1), .q(q1));
    decade_counter counter2 (.clk(clk), .reset(reset), .enable(ena2), .q(q2));
    decade_counter counter3 (.clk(clk), .reset(reset), .enable(), .q(q3);
    
    // Connect outputs
    assign ena = {ena2, ena1, ena0};
    assign q = {q3, q2, q1, q0};
endmodule
"
"
    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    wire ena0;
    wire ena1;
    wire ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (.clk(clk), .reset(reset), .q(q0), .ena(ena0));
    decade_counter counter1 (.clk(clk), .reset(reset), .q(q1), .ena(ena1));
    decade_counter counter2 (.clk(clk), .reset(reset), .q(q2), .ena(ena2));
    decade_counter counter3 (.clk(clk), .reset(reset), .q(q3), .ena());
    
    // Connect the outputs of the decade counters to the output ports
    assign q = {q3, q2, q1, q0};
    assign ena = {ena2, ena1, ena0};
endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    wire ena0;
    wire ena1;
    wire ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (.clk(clk), .reset(reset), .q(q0), .ena(ena0));
    decade_counter counter1 (.clk(clk), .reset(reset), .q(q1), .ena(ena1));
    decade_counter counter2 (.clk(clk), .reset(reset), .q(q2), .ena(ena2));
    decade_counter counter3 (.clk(clk), .reset(reset), .q(q3), .ena());
    
    // Connect the outputs of the decade counters to the output ports
    assign q = {q3, q2, q1, q0};
    assign ena = {ena2, ena1, ena0};
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    wire ena0;
    wire ena1;
    wire ena2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (.clk(clk), .reset(reset), .q(q0), .ena(ena0));
    decade_counter counter1 (.clk(clk), .reset(reset), .q(q1), .ena(ena1));
    decade_counter counter2 (.clk(clk), .reset(reset), .q(q2), .ena(ena2));
    decade_counter counter3 (.clk(clk), .reset(reset), .q(q3), .ena());
    
    // Connect the outputs of the decade counters to the output ports
    assign q = {q3, q2, q1, q0};
    assign ena = {ena2, ena1, ena0};
endmodule
"
"
    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (.clk(clk), .reset(reset), .q(q0));
    decade_counter counter1 (.clk(clk), .reset(reset), .q(q1));
    decade_counter counter2 (.clk(clk), .reset(reset), .q(q2));
    
    // Output the BCD counter values
    assign q = {q2, q1, q0};
    
    // Output the enable signals for upper three digits
    assign ena = {q2 != 9, q1 != 9, q0 != 9};
endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (.clk(clk), .reset(reset), .q(q0));
    decade_counter counter1 (.clk(clk), .reset(reset), .q(q1));
    decade_counter counter2 (.clk(clk), .reset(reset), .q(q2));
    
    // Output the BCD counter values
    assign q = {q2, q1, q0};
    
    // Output the enable signals for upper three digits
    assign ena = {q2 != 9, q1 != 9, q0 != 9};
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    
    // Instantiate one-digit decade counters
    decade_counter counter0 (.clk(clk), .reset(reset), .q(q0));
    decade_counter counter1 (.clk(clk), .reset(reset), .q(q1));
    decade_counter counter2 (.clk(clk), .reset(reset), .q(q2));
    
    // Output the BCD counter values
    assign q = {q2, q1, q0};
    
    // Output the enable signals for upper three digits
    assign ena = {q2 != 9, q1 != 9, q0 != 9};
endmodule
"
"
    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    decade_counter counter0 (.clk(clk), .reset(reset), .q(q0));
    decade_counter counter1 (.clk(clk), .reset(reset), .q(q1));
    decade_counter counter2 (.clk(clk), .reset(reset), .q(q2));
    decade_counter counter3 (.clk(clk), .reset(reset), .q(q3));
    
    assign q = {q3, q2, q1, q0};
    
    assign ena = {q3[3], q2[3], q1[3]};
endmodule
",-1.0,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    decade_counter counter0 (.clk(clk), .reset(reset), .q(q0));
    decade_counter counter1 (.clk(clk), .reset(reset), .q(q1));
    decade_counter counter2 (.clk(clk), .reset(reset), .q(q2));
    decade_counter counter3 (.clk(clk), .reset(reset), .q(q3));
    
    assign q = {q3, q2, q1, q0};
    
    assign ena = {q3[3], q2[3], q1[3]};
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);


    wire [3:0] q0;
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    decade_counter counter0 (.clk(clk), .reset(reset), .q(q0));
    decade_counter counter1 (.clk(clk), .reset(reset), .q(q1));
    decade_counter counter2 (.clk(clk), .reset(reset), .q(q2));
    decade_counter counter3 (.clk(clk), .reset(reset), .q(q3));
    
    assign q = {q3, q2, q1, q0};
    
    assign ena = {q3[3], q2[3], q1[3]};
endmodule
"
"    reg [3:0] q;

    always @(posedge clk) begin
        if (reset) begin
            q <= 4'b0000;
        end else if (slowena) begin
            if (q == 4'b1001) begin
                q <= 4'b0000;
            end else begin
                q <= q + 1;
            end
        end
    end

endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    reg [3:0] q;

    always @(posedge clk) begin
        if (reset) begin
            q <= 4'b0000;
        end else if (slowena) begin
            if (q == 4'b1001) begin
                q <= 4'b0000;
            end else begin
                q <= q + 1;
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    reg [3:0] q;

    always @(posedge clk) begin
        if (reset) begin
            q <= 4'b0000;
        end else if (slowena) begin
            if (q == 4'b1001) begin
                q <= 4'b0000;
            end else begin
                q <= q + 1;
            end
        end
    end

endmodule
"
"    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else if (slowena) begin
            if (counter == 4'b1001) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else if (slowena) begin
            if (counter == 4'b1001) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else if (slowena) begin
            if (counter == 4'b1001) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
"
"reg [3:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 4'b0000;
    end else if (slowena) begin
        if (count == 4'b1001) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

reg [3:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 4'b0000;
    end else if (slowena) begin
        if (count == 4'b1001) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

reg [3:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 4'b0000;
    end else if (slowena) begin
        if (count == 4'b1001) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
"
"reg [3:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 4'b0000;
    end else if (slowena) begin
        if (count == 4'b1001) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

reg [3:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 4'b0000;
    end else if (slowena) begin
        if (count == 4'b1001) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

reg [3:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 4'b0000;
    end else if (slowena) begin
        if (count == 4'b1001) begin
            count <= 4'b0000;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
"
"    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else if (slowena) begin
            if (count == 9) begin
                count <= 0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else if (slowena) begin
            if (count == 9) begin
                count <= 0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else if (slowena) begin
            if (count == 9) begin
                count <= 0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else if (slowena) begin
            if (counter == 4'b1001) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);


    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else if (slowena) begin
            if (counter == 4'b1001) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);


    reg [3:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 4'b0000;
        end else if (slowena) begin
            if (counter == 4'b1001) begin
                counter <= 4'b0000;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0;
        end else if (slowena) begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);


    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0;
        end else if (slowena) begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);


    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0;
        end else if (slowena) begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
"
"  reg [3:0] count;

  always @(posedge clk) begin
    if (reset) begin
      count <= 4'b0000;
    end else if (slowena) begin
      count <= count + 1;
    end
  end

  assign q = count;

endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

  reg [3:0] count;

  always @(posedge clk) begin
    if (reset) begin
      count <= 4'b0000;
    end else if (slowena) begin
      count <= count + 1;
    end
  end

  assign q = count;

endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

  reg [3:0] count;

  always @(posedge clk) begin
    if (reset) begin
      count <= 4'b0000;
    end else if (slowena) begin
      count <= count + 1;
    end
  end

  assign q = count;

endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else if (slowena) begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);


    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else if (slowena) begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);


    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else if (slowena) begin
            if (count == 4'b1001) begin
                count <= 4'b0000;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;

endmodule
"
"
    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (slowena) begin
                if (count == 4'b1001) begin
                    count <= 4'b0000;
                end else begin
                    count <= count + 1;
                end
            end
        end
    end

    assign q = count;

endmodule
",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);


    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (slowena) begin
                if (count == 4'b1001) begin
                    count <= 4'b0000;
                end else begin
                    count <= count + 1;
                end
            end
        end
    end

    assign q = count;

endmodule
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);


    reg [3:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0000;
        end else begin
            if (slowena) begin
                if (count == 4'b1001) begin
                    count <= 4'b0000;
                end else begin
                    count <= count + 1;
                end
            end
        end
    end

    assign q = count;

endmodule
"
"
    always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"
    always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"
    always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"
    always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"
    always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"   always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );

   always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );

   always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"
    always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"
    always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"
    always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"
    always @(posedge clk) begin
        q <= d;
    end
endmodule
",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );


    always @(posedge clk) begin
        q <= d;
    end
endmodule
"
"    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
",-0.5,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
"
"    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
",-0.5,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
"
"    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
",-0.5,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
"
"reg [15:0] q;

always @(posedge clk or negedge resetn) begin
    if (~resetn) begin
        q <= 16'b0;
    end else begin
        if (byteena[0]) begin
            q[7:0] <= d[7:0];
        end
        if (byteena[1]) begin
            q[15:8] <= d[15:8];
        end
    end
end

endmodule
",-0.5,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
reg [15:0] q;

always @(posedge clk or negedge resetn) begin
    if (~resetn) begin
        q <= 16'b0;
    end else begin
        if (byteena[0]) begin
            q[7:0] <= d[7:0];
        end
        if (byteena[1]) begin
            q[15:8] <= d[15:8];
        end
    end
end

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
reg [15:0] q;

always @(posedge clk or negedge resetn) begin
    if (~resetn) begin
        q <= 16'b0;
    end else begin
        if (byteena[0]) begin
            q[7:0] <= d[7:0];
        end
        if (byteena[1]) begin
            q[15:8] <= d[15:8];
        end
    end
end

endmodule
"
"    reg [15:0] q_reg;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q_reg <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q_reg[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q_reg[15:8] <= d[15:8];
            end
        end
    end

    assign q = q_reg;

endmodule
",-0.5,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q_reg;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q_reg <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q_reg[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q_reg[15:8] <= d[15:8];
            end
        end
    end

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q_reg;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q_reg <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q_reg[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q_reg[15:8] <= d[15:8];
            end
        end
    end

    assign q = q_reg;

endmodule
"
"    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
",-0.5,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
"
"
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
",-0.5,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
"
"    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
",-0.5,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q[15:8] <= d[15:8];
            end
        end
    end

endmodule
"
"    reg [15:0] q_reg;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q_reg <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q_reg[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q_reg[15:8] <= d[15:8];
            end
        end
    end

    assign q = q_reg;

endmodule
",-0.5,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q_reg;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q_reg <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q_reg[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q_reg[15:8] <= d[15:8];
            end
        end
    end

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q_reg;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q_reg <= 16'b0;
        end else begin
            if (byteena[0]) begin
                q_reg[7:0] <= d[7:0];
            end
            if (byteena[1]) begin
                q_reg[15:8] <= d[15:8];
            end
        end
    end

    assign q = q_reg;

endmodule
"
"    reg [15:0] q;
    reg [15:0] dffs [15:0];

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
            for (int i = 0; i < 16; i = i + 1) begin
                dffs[i] <= 1'b0;
            end
        end else begin
            for (int i = 0; i < 16; i = i + 1) begin
                if (byteena[1] && (i >= 8)) begin
                    dffs[i] <= d[i];
                end
                if (byteena[0] && (i < 8)) begin
                    dffs[i] <= d[i];
                end
            end
            q <= {dffs};
        end
    end

endmodule
",-1.0,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;
    reg [15:0] dffs [15:0];

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
            for (int i = 0; i < 16; i = i + 1) begin
                dffs[i] <= 1'b0;
            end
        end else begin
            for (int i = 0; i < 16; i = i + 1) begin
                if (byteena[1] && (i >= 8)) begin
                    dffs[i] <= d[i];
                end
                if (byteena[0] && (i < 8)) begin
                    dffs[i] <= d[i];
                end
            end
            q <= {dffs};
        end
    end

endmodule
","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    reg [15:0] q;
    reg [15:0] dffs [15:0];

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            q <= 16'b0;
            for (int i = 0; i < 16; i = i + 1) begin
                dffs[i] <= 1'b0;
            end
        end else begin
            for (int i = 0; i < 16; i = i + 1) begin
                if (byteena[1] && (i >= 8)) begin
                    dffs[i] <= d[i];
                end
                if (byteena[0] && (i < 8)) begin
                    dffs[i] <= d[i];
                end
            end
            q <= {dffs};
        end
    end

endmodule
"
"
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
"
"    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
"
"
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
"
"
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
"
"    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
"
"    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        q_reg <= d;
    end
    
    assign q = q_reg;
    
endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        q_reg <= d;
    end
    
    assign q = q_reg;
    
endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        q_reg <= d;
    end
    
    assign q = q_reg;
    
endmodule
"
"
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
"
"    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;
endmodule
"
"    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;

    always @(posedge clk) begin
        q_reg <= d;
    end

    assign q = q_reg;

endmodule
"
"
    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        q_reg <= d;
    end
    
    assign q = q_reg;
    
endmodule
",-0.5,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        q_reg <= d;
    end
    
    assign q = q_reg;
    
endmodule
","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        q_reg <= d;
    end
    
    assign q = q_reg;
    
endmodule
"
"    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"reg [7:0] q;

always @(posedge clk or posedge areset) begin
    if (areset) begin
        q <= 8'b0;
    end else begin
        q <= d;
    end
end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

reg [7:0] q;

always @(posedge clk or posedge areset) begin
    if (areset) begin
        q <= 8'b0;
    end else begin
        q <= d;
    end
end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

reg [7:0] q;

always @(posedge clk or posedge areset) begin
    if (areset) begin
        q <= 8'b0;
    end else begin
        q <= d;
    end
end

endmodule
"
"    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 8'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"
    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;

    always @(negedge clk or posedge reset) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end

    assign q = dff8;
endmodule
",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;

    always @(negedge clk or posedge reset) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end

    assign q = dff8;
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;

    always @(negedge clk or posedge reset) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end

    assign q = dff8;
endmodule
"
"
    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;

    always @(negedge clk or posedge reset) begin
        if (reset) begin
            dff1 <= 8'b00110100;
            dff2 <= 8'b00110100;
            dff3 <= 8'b00110100;
            dff4 <= 8'b00110100;
            dff5 <= 8'b00110100;
            dff6 <= 8'b00110100;
            dff7 <= 8'b00110100;
            dff8 <= 8'b00110100;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end

    assign q = dff8;
endmodule
",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;

    always @(negedge clk or posedge reset) begin
        if (reset) begin
            dff1 <= 8'b00110100;
            dff2 <= 8'b00110100;
            dff3 <= 8'b00110100;
            dff4 <= 8'b00110100;
            dff5 <= 8'b00110100;
            dff6 <= 8'b00110100;
            dff7 <= 8'b00110100;
            dff8 <= 8'b00110100;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end

    assign q = dff8;
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;

    always @(negedge clk or posedge reset) begin
        if (reset) begin
            dff1 <= 8'b00110100;
            dff2 <= 8'b00110100;
            dff3 <= 8'b00110100;
            dff4 <= 8'b00110100;
            dff5 <= 8'b00110100;
            dff6 <= 8'b00110100;
            dff7 <= 8'b00110100;
            dff8 <= 8'b00110100;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end

    assign q = dff8;
endmodule
"
"
    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            q_reg[0] <= 8'h34;
            q_reg[1] <= 8'h34;
            q_reg[2] <= 8'h34;
            q_reg[3] <= 8'h34;
            q_reg[4] <= 8'h34;
            q_reg[5] <= 8'h34;
            q_reg[6] <= 8'h34;
            q_reg[7] <= 8'h34;
        end else begin
            q_reg[0] <= d;
            q_reg[1] <= q_reg[0];
            q_reg[2] <= q_reg[1];
            q_reg[3] <= q_reg[2];
            q_reg[4] <= q_reg[3];
            q_reg[5] <= q_reg[4];
            q_reg[6] <= q_reg[5];
            q_reg[7] <= q_reg[6];
        end
    end
    
    assign q = q_reg[7];
endmodule
",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            q_reg[0] <= 8'h34;
            q_reg[1] <= 8'h34;
            q_reg[2] <= 8'h34;
            q_reg[3] <= 8'h34;
            q_reg[4] <= 8'h34;
            q_reg[5] <= 8'h34;
            q_reg[6] <= 8'h34;
            q_reg[7] <= 8'h34;
        end else begin
            q_reg[0] <= d;
            q_reg[1] <= q_reg[0];
            q_reg[2] <= q_reg[1];
            q_reg[3] <= q_reg[2];
            q_reg[4] <= q_reg[3];
            q_reg[5] <= q_reg[4];
            q_reg[6] <= q_reg[5];
            q_reg[7] <= q_reg[6];
        end
    end
    
    assign q = q_reg[7];
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            q_reg[0] <= 8'h34;
            q_reg[1] <= 8'h34;
            q_reg[2] <= 8'h34;
            q_reg[3] <= 8'h34;
            q_reg[4] <= 8'h34;
            q_reg[5] <= 8'h34;
            q_reg[6] <= 8'h34;
            q_reg[7] <= 8'h34;
        end else begin
            q_reg[0] <= d;
            q_reg[1] <= q_reg[0];
            q_reg[2] <= q_reg[1];
            q_reg[3] <= q_reg[2];
            q_reg[4] <= q_reg[3];
            q_reg[5] <= q_reg[4];
            q_reg[6] <= q_reg[5];
            q_reg[7] <= q_reg[6];
        end
    end
    
    assign q = q_reg[7];
endmodule
"
"
    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;
    
    always @(negedge clk or posedge reset) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end
    
    assign q = dff8;
    
endmodule
",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;
    
    always @(negedge clk or posedge reset) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end
    
    assign q = dff8;
    
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;
    
    always @(negedge clk or posedge reset) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end
    
    assign q = dff8;
    
endmodule
"
"
    reg [7:0] dff[7:0];
    
    always @(negedge clk) begin
        if (reset) begin
            for (int i = 0; i < 8; i = i + 1) begin
                dff[i] <= 8'b00110100; // Setting reset value to 0x34
            end
        end else begin
            for (int i = 0; i < 8; i = i + 1) begin
                dff[i] <= d[i];
            end
        end
    end
    
    assign q = dff;
    
endmodule
",-1.0,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff[7:0];
    
    always @(negedge clk) begin
        if (reset) begin
            for (int i = 0; i < 8; i = i + 1) begin
                dff[i] <= 8'b00110100; // Setting reset value to 0x34
            end
        end else begin
            for (int i = 0; i < 8; i = i + 1) begin
                dff[i] <= d[i];
            end
        end
    end
    
    assign q = dff;
    
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff[7:0];
    
    always @(negedge clk) begin
        if (reset) begin
            for (int i = 0; i < 8; i = i + 1) begin
                dff[i] <= 8'b00110100; // Setting reset value to 0x34
            end
        end else begin
            for (int i = 0; i < 8; i = i + 1) begin
                dff[i] <= d[i];
            end
        end
    end
    
    assign q = dff;
    
endmodule
"
"
    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;

    always @(negedge clk) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end

    assign q = dff8;
endmodule
",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;

    always @(negedge clk) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end

    assign q = dff8;
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;

    always @(negedge clk) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end

    assign q = dff8;
endmodule
"
"    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            // Reset all DFFs to 0x34
            q_reg[0] <= 8'b00110100;
            q_reg[1] <= 8'b00110100;
            q_reg[2] <= 8'b00110100;
            q_reg[3] <= 8'b00110100;
            q_reg[4] <= 8'b00110100;
            q_reg[5] <= 8'b00110100;
            q_reg[6] <= 8'b00110100;
            q_reg[7] <= 8'b00110100;
        end else begin
            // D flip-flop behavior
            q_reg[0] <= d[0];
            q_reg[1] <= d[1];
            q_reg[2] <= d[2];
            q_reg[3] <= d[3];
            q_reg[4] <= d[4];
            q_reg[5] <= d[5];
            q_reg[6] <= d[6];
            q_reg[7] <= d[7];
        end
    end
    
    assign q = {q_reg[7], q_reg[6], q_reg[5], q_reg[4], q_reg[3], q_reg[2], q_reg[1], q_reg[0]};
    
endmodule
",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            // Reset all DFFs to 0x34
            q_reg[0] <= 8'b00110100;
            q_reg[1] <= 8'b00110100;
            q_reg[2] <= 8'b00110100;
            q_reg[3] <= 8'b00110100;
            q_reg[4] <= 8'b00110100;
            q_reg[5] <= 8'b00110100;
            q_reg[6] <= 8'b00110100;
            q_reg[7] <= 8'b00110100;
        end else begin
            // D flip-flop behavior
            q_reg[0] <= d[0];
            q_reg[1] <= d[1];
            q_reg[2] <= d[2];
            q_reg[3] <= d[3];
            q_reg[4] <= d[4];
            q_reg[5] <= d[5];
            q_reg[6] <= d[6];
            q_reg[7] <= d[7];
        end
    end
    
    assign q = {q_reg[7], q_reg[6], q_reg[5], q_reg[4], q_reg[3], q_reg[2], q_reg[1], q_reg[0]};
    
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            // Reset all DFFs to 0x34
            q_reg[0] <= 8'b00110100;
            q_reg[1] <= 8'b00110100;
            q_reg[2] <= 8'b00110100;
            q_reg[3] <= 8'b00110100;
            q_reg[4] <= 8'b00110100;
            q_reg[5] <= 8'b00110100;
            q_reg[6] <= 8'b00110100;
            q_reg[7] <= 8'b00110100;
        end else begin
            // D flip-flop behavior
            q_reg[0] <= d[0];
            q_reg[1] <= d[1];
            q_reg[2] <= d[2];
            q_reg[3] <= d[3];
            q_reg[4] <= d[4];
            q_reg[5] <= d[5];
            q_reg[6] <= d[6];
            q_reg[7] <= d[7];
        end
    end
    
    assign q = {q_reg[7], q_reg[6], q_reg[5], q_reg[4], q_reg[3], q_reg[2], q_reg[1], q_reg[0]};
    
endmodule
"
"    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            for (int i=0; i<8; i=i+1) begin
                q_reg[i] <= 8'b00110100; // Reset to 0x34
            end
        end else begin
            for (int i=0; i<8; i=i+1) begin
                q_reg[i] <= d[i];
            end
        end
    end
    
    assign q = q_reg;
endmodule
",-1.0,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            for (int i=0; i<8; i=i+1) begin
                q_reg[i] <= 8'b00110100; // Reset to 0x34
            end
        end else begin
            for (int i=0; i<8; i=i+1) begin
                q_reg[i] <= d[i];
            end
        end
    end
    
    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            for (int i=0; i<8; i=i+1) begin
                q_reg[i] <= 8'b00110100; // Reset to 0x34
            end
        end else begin
            for (int i=0; i<8; i=i+1) begin
                q_reg[i] <= d[i];
            end
        end
    end
    
    assign q = q_reg;
endmodule
"
"
    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            q_reg[0] <= 8'h34;
            q_reg[1] <= 8'h34;
            q_reg[2] <= 8'h34;
            q_reg[3] <= 8'h34;
            q_reg[4] <= 8'h34;
            q_reg[5] <= 8'h34;
            q_reg[6] <= 8'h34;
            q_reg[7] <= 8'h34;
        end else begin
            q_reg[0] <= d;
            q_reg[1] <= q_reg[0];
            q_reg[2] <= q_reg[1];
            q_reg[3] <= q_reg[2];
            q_reg[4] <= q_reg[3];
            q_reg[5] <= q_reg[4];
            q_reg[6] <= q_reg[5];
            q_reg[7] <= q_reg[6];
        end
    end
    
    assign q = q_reg[7];
endmodule
",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            q_reg[0] <= 8'h34;
            q_reg[1] <= 8'h34;
            q_reg[2] <= 8'h34;
            q_reg[3] <= 8'h34;
            q_reg[4] <= 8'h34;
            q_reg[5] <= 8'h34;
            q_reg[6] <= 8'h34;
            q_reg[7] <= 8'h34;
        end else begin
            q_reg[0] <= d;
            q_reg[1] <= q_reg[0];
            q_reg[2] <= q_reg[1];
            q_reg[3] <= q_reg[2];
            q_reg[4] <= q_reg[3];
            q_reg[5] <= q_reg[4];
            q_reg[6] <= q_reg[5];
            q_reg[7] <= q_reg[6];
        end
    end
    
    assign q = q_reg[7];
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg [0:7];
    
    always @(negedge clk) begin
        if (reset) begin
            q_reg[0] <= 8'h34;
            q_reg[1] <= 8'h34;
            q_reg[2] <= 8'h34;
            q_reg[3] <= 8'h34;
            q_reg[4] <= 8'h34;
            q_reg[5] <= 8'h34;
            q_reg[6] <= 8'h34;
            q_reg[7] <= 8'h34;
        end else begin
            q_reg[0] <= d;
            q_reg[1] <= q_reg[0];
            q_reg[2] <= q_reg[1];
            q_reg[3] <= q_reg[2];
            q_reg[4] <= q_reg[3];
            q_reg[5] <= q_reg[4];
            q_reg[6] <= q_reg[5];
            q_reg[7] <= q_reg[6];
        end
    end
    
    assign q = q_reg[7];
endmodule
"
"
    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;
    
    always @(negedge clk) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end
    
    assign q = dff8;
    
endmodule
",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;
    
    always @(negedge clk) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end
    
    assign q = dff8;
    
endmodule
","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] dff1, dff2, dff3, dff4, dff5, dff6, dff7, dff8;
    
    always @(negedge clk) begin
        if (reset) begin
            dff1 <= 8'h34;
            dff2 <= 8'h34;
            dff3 <= 8'h34;
            dff4 <= 8'h34;
            dff5 <= 8'h34;
            dff6 <= 8'h34;
            dff7 <= 8'h34;
            dff8 <= 8'h34;
        end else begin
            dff1 <= d;
            dff2 <= dff1;
            dff3 <= dff2;
            dff4 <= dff3;
            dff5 <= dff4;
            dff6 <= dff5;
            dff7 <= dff6;
            dff8 <= dff7;
        end
    end
    
    assign q = dff8;
    
endmodule
"
"
    reg [7:0] q_reg; // Output register
    
    // Instantiate 8 D flip-flops with active high synchronous reset
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0; // Reset all flip-flops to 0
        end else begin
            q_reg <= d; // Update flip-flops with input data
        end
    end
    
    assign q = q_reg; // Output the values stored in the flip-flops
endmodule
",-0.5,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg; // Output register
    
    // Instantiate 8 D flip-flops with active high synchronous reset
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0; // Reset all flip-flops to 0
        end else begin
            q_reg <= d; // Update flip-flops with input data
        end
    end
    
    assign q = q_reg; // Output the values stored in the flip-flops
endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg; // Output register
    
    // Instantiate 8 D flip-flops with active high synchronous reset
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0; // Reset all flip-flops to 0
        end else begin
            q_reg <= d; // Update flip-flops with input data
        end
    end
    
    assign q = q_reg; // Output the values stored in the flip-flops
endmodule
"
"
    reg [7:0] q_reg;
    reg [7:0] d_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d_reg;
        end
    end
    
    always @(posedge clk) begin
        d_reg <= d;
    end
    
    assign q = q_reg;
endmodule
",-0.5,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    reg [7:0] d_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d_reg;
        end
    end
    
    always @(posedge clk) begin
        d_reg <= d;
    end
    
    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    reg [7:0] d_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d_reg;
        end
    end
    
    always @(posedge clk) begin
        d_reg <= d;
    end
    
    assign q = q_reg;
endmodule
"
"    reg [7:0] q_reg;
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
endmodule
",-0.5,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
endmodule
"
"
    reg [7:0] q_reg;  // Output register
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;  // Reset all flip-flops to 0
        end else begin
            q_reg <= d;  // Update flip-flop values with input d
        end
    end
    
    assign q = q_reg;  // Output q is connected to the output register
endmodule
",-0.5,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;  // Output register
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;  // Reset all flip-flops to 0
        end else begin
            q_reg <= d;  // Update flip-flop values with input d
        end
    end
    
    assign q = q_reg;  // Output q is connected to the output register
endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;  // Output register
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;  // Reset all flip-flops to 0
        end else begin
            q_reg <= d;  // Update flip-flop values with input d
        end
    end
    
    assign q = q_reg;  // Output q is connected to the output register
endmodule
"
"
    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
    
endmodule
",-0.5,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
    
endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
    
endmodule
"
"    reg [7:0] q_reg;
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
endmodule
",-0.5,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    reg [7:0] q_reg;
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
endmodule
"
"
    reg [7:0] q_reg;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end

    assign q = q_reg;
endmodule
",-0.5,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end

    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end

    assign q = q_reg;
endmodule
"
"
    reg [7:0] q_reg;
    wire [7:0] q_next;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= q_next;
        end
    end

    // Instantiate 8 D flip-flops
    dff dff0 (.clk(clk), .reset(reset), .d(d[0]), .q(q_next[0]));
    dff dff1 (.clk(clk), .reset(reset), .d(d[1]), .q(q_next[1]));
    dff dff2 (.clk(clk), .reset(reset), .d(d[2]), .q(q_next[2]));
    dff dff3 (.clk(clk), .reset(reset), .d(d[3]), .q(q_next[3]));
    dff dff4 (.clk(clk), .reset(reset), .d(d[4]), .q(q_next[4]));
    dff dff5 (.clk(clk), .reset(reset), .d(d[5]), .q(q_next[5]));
    dff dff6 (.clk(clk), .reset(reset), .d(d[6]), .q(q_next[6]));
    dff dff7 (.clk(clk), .reset(reset), .d(d[7]), .q(q_next[7]));

    assign q = q_reg;

endmodule
",-1.0,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    wire [7:0] q_next;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= q_next;
        end
    end

    // Instantiate 8 D flip-flops
    dff dff0 (.clk(clk), .reset(reset), .d(d[0]), .q(q_next[0]));
    dff dff1 (.clk(clk), .reset(reset), .d(d[1]), .q(q_next[1]));
    dff dff2 (.clk(clk), .reset(reset), .d(d[2]), .q(q_next[2]));
    dff dff3 (.clk(clk), .reset(reset), .d(d[3]), .q(q_next[3]));
    dff dff4 (.clk(clk), .reset(reset), .d(d[4]), .q(q_next[4]));
    dff dff5 (.clk(clk), .reset(reset), .d(d[5]), .q(q_next[5]));
    dff dff6 (.clk(clk), .reset(reset), .d(d[6]), .q(q_next[6]));
    dff dff7 (.clk(clk), .reset(reset), .d(d[7]), .q(q_next[7]));

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    wire [7:0] q_next;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= q_next;
        end
    end

    // Instantiate 8 D flip-flops
    dff dff0 (.clk(clk), .reset(reset), .d(d[0]), .q(q_next[0]));
    dff dff1 (.clk(clk), .reset(reset), .d(d[1]), .q(q_next[1]));
    dff dff2 (.clk(clk), .reset(reset), .d(d[2]), .q(q_next[2]));
    dff dff3 (.clk(clk), .reset(reset), .d(d[3]), .q(q_next[3]));
    dff dff4 (.clk(clk), .reset(reset), .d(d[4]), .q(q_next[4]));
    dff dff5 (.clk(clk), .reset(reset), .d(d[5]), .q(q_next[5]));
    dff dff6 (.clk(clk), .reset(reset), .d(d[6]), .q(q_next[6]));
    dff dff7 (.clk(clk), .reset(reset), .d(d[7]), .q(q_next[7]));

    assign q = q_reg;

endmodule
"
"
    reg [7:0] q_reg;
    wire [7:0] d_in;

    // Instantiate 8 D flip-flops with active high synchronous reset
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d_in;
        end
    end

    // Connect input D signals to the D flip-flops
    assign d_in = d;

    // Output the Q signals
    assign q = q_reg;
endmodule
",-0.5,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    wire [7:0] d_in;

    // Instantiate 8 D flip-flops with active high synchronous reset
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d_in;
        end
    end

    // Connect input D signals to the D flip-flops
    assign d_in = d;

    // Output the Q signals
    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    wire [7:0] d_in;

    // Instantiate 8 D flip-flops with active high synchronous reset
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d_in;
        end
    end

    // Connect input D signals to the D flip-flops
    assign d_in = d;

    // Output the Q signals
    assign q = q_reg;
endmodule
"
"
    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
    
endmodule
",-0.5,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
    
endmodule
","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    reg [7:0] q_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 8'b0;
        end else begin
            q_reg <= d;
        end
    end
    
    assign q = q_reg;
    
endmodule
"
"reg q_posedge, q_negedge;

always @(posedge clk)
begin
    q_posedge <= d;
end

always @(negedge clk)
begin
    q_negedge <= q_posedge;
end

assign q = q_negedge;

endmodule
",1.0,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
reg q_posedge, q_negedge;

always @(posedge clk)
begin
    q_posedge <= d;
end

always @(negedge clk)
begin
    q_negedge <= q_posedge;
end

assign q = q_negedge;

endmodule
","module top_module (
    input clk,
    input d,
    output q
);
reg q_posedge, q_negedge;

always @(posedge clk)
begin
    q_posedge <= d;
end

always @(negedge clk)
begin
    q_negedge <= q_posedge;
end

assign q = q_negedge;

endmodule
"
"
reg q_posedge, q_negedge;

always @(posedge clk) begin
    q_posedge <= d;
end

always @(negedge clk) begin
    q_negedge <= q_posedge;
end

assign q = q_negedge;

endmodule
",1.0,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

reg q_posedge, q_negedge;

always @(posedge clk) begin
    q_posedge <= d;
end

always @(negedge clk) begin
    q_negedge <= q_posedge;
end

assign q = q_negedge;

endmodule
","module top_module (
    input clk,
    input d,
    output q
);

reg q_posedge, q_negedge;

always @(posedge clk) begin
    q_posedge <= d;
end

always @(negedge clk) begin
    q_negedge <= q_posedge;
end

assign q = q_negedge;

endmodule
"
"
  reg q_posedge, q_negedge;

  always @(posedge clk) begin
    q_posedge <= d;
  end

  always @(negedge clk) begin
    q_negedge <= q_posedge;
  end

  assign q = q_negedge;

endmodule
",1.0,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

  reg q_posedge, q_negedge;

  always @(posedge clk) begin
    q_posedge <= d;
  end

  always @(negedge clk) begin
    q_negedge <= q_posedge;
  end

  assign q = q_negedge;

endmodule
","module top_module (
    input clk,
    input d,
    output q
);

  reg q_posedge, q_negedge;

  always @(posedge clk) begin
    q_posedge <= d;
  end

  always @(negedge clk) begin
    q_negedge <= q_posedge;
  end

  assign q = q_negedge;

endmodule
"
"reg q_posedge, q_negedge;

always @(posedge clk)
begin
    q_posedge <= d;
end

always @(negedge clk)
begin
    q_negedge <= d;
end

assign q = q_posedge & q_negedge;

endmodule
",-0.5,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
reg q_posedge, q_negedge;

always @(posedge clk)
begin
    q_posedge <= d;
end

always @(negedge clk)
begin
    q_negedge <= d;
end

assign q = q_posedge & q_negedge;

endmodule
","module top_module (
    input clk,
    input d,
    output q
);
reg q_posedge, q_negedge;

always @(posedge clk)
begin
    q_posedge <= d;
end

always @(negedge clk)
begin
    q_negedge <= d;
end

assign q = q_posedge & q_negedge;

endmodule
"
"
  reg q_posedge, q_negedge;

  always @(posedge clk) begin
    q_posedge <= d;
  end

  always @(negedge clk) begin
    q_negedge <= q_posedge;
  end

  assign q = q_negedge;

endmodule
",1.0,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

  reg q_posedge, q_negedge;

  always @(posedge clk) begin
    q_posedge <= d;
  end

  always @(negedge clk) begin
    q_negedge <= q_posedge;
  end

  assign q = q_negedge;

endmodule
","module top_module (
    input clk,
    input d,
    output q
);

  reg q_posedge, q_negedge;

  always @(posedge clk) begin
    q_posedge <= d;
  end

  always @(negedge clk) begin
    q_negedge <= q_posedge;
  end

  assign q = q_negedge;

endmodule
"
"reg q_posedge, q_negedge;

always @(posedge clk)
    q_posedge <= d;

always @(negedge clk)
    q_negedge <= d;

assign q = clk ? q_negedge : q_posedge;

endmodule
",-0.5,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
reg q_posedge, q_negedge;

always @(posedge clk)
    q_posedge <= d;

always @(negedge clk)
    q_negedge <= d;

assign q = clk ? q_negedge : q_posedge;

endmodule
","module top_module (
    input clk,
    input d,
    output q
);
reg q_posedge, q_negedge;

always @(posedge clk)
    q_posedge <= d;

always @(negedge clk)
    q_negedge <= d;

assign q = clk ? q_negedge : q_posedge;

endmodule
"
"
reg q_pos, q_neg;

always @(posedge clk) begin
    q_pos <= d;
end

always @(negedge clk) begin
    q_neg <= q_pos;
end

assign q = q_neg;

endmodule
",1.0,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

reg q_pos, q_neg;

always @(posedge clk) begin
    q_pos <= d;
end

always @(negedge clk) begin
    q_neg <= q_pos;
end

assign q = q_neg;

endmodule
","module top_module (
    input clk,
    input d,
    output q
);

reg q_pos, q_neg;

always @(posedge clk) begin
    q_pos <= d;
end

always @(negedge clk) begin
    q_neg <= q_pos;
end

assign q = q_neg;

endmodule
"
"// Create two flip-flops, one triggered on the positive edge of the clock and the other triggered on the negative edge of the clock
reg q_posedge, q_negedge;
always @(posedge clk)
    q_posedge <= d;
always @(negedge clk)
    q_negedge <= q_posedge;

assign q = q_negedge; // Output the value from the negative edge triggered flip-flop

endmodule
",1.0,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
// Create two flip-flops, one triggered on the positive edge of the clock and the other triggered on the negative edge of the clock
reg q_posedge, q_negedge;
always @(posedge clk)
    q_posedge <= d;
always @(negedge clk)
    q_negedge <= q_posedge;

assign q = q_negedge; // Output the value from the negative edge triggered flip-flop

endmodule
","module top_module (
    input clk,
    input d,
    output q
);
// Create two flip-flops, one triggered on the positive edge of the clock and the other triggered on the negative edge of the clock
reg q_posedge, q_negedge;
always @(posedge clk)
    q_posedge <= d;
always @(negedge clk)
    q_negedge <= q_posedge;

assign q = q_negedge; // Output the value from the negative edge triggered flip-flop

endmodule
"
"
reg q_posedge, q_negedge;

always @(posedge clk)
    q_posedge <= d;

always @(negedge clk)
    q_negedge <= q_posedge;

assign q = q_negedge;

endmodule
",1.0,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

reg q_posedge, q_negedge;

always @(posedge clk)
    q_posedge <= d;

always @(negedge clk)
    q_negedge <= q_posedge;

assign q = q_negedge;

endmodule
","module top_module (
    input clk,
    input d,
    output q
);

reg q_posedge, q_negedge;

always @(posedge clk)
    q_posedge <= d;

always @(negedge clk)
    q_negedge <= q_posedge;

assign q = q_negedge;

endmodule
"
"
reg q_posedge, q_negedge;

always @(posedge clk)
    q_posedge <= d;

always @(negedge clk)
    q_negedge <= q_posedge;

assign q = q_negedge;

endmodule
",1.0,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

reg q_posedge, q_negedge;

always @(posedge clk)
    q_posedge <= d;

always @(negedge clk)
    q_negedge <= q_posedge;

assign q = q_negedge;

endmodule
","module top_module (
    input clk,
    input d,
    output q
);

reg q_posedge, q_negedge;

always @(posedge clk)
    q_posedge <= d;

always @(negedge clk)
    q_negedge <= q_posedge;

assign q = q_negedge;

endmodule
"
"    reg [31:0] out_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            for (int i=0; i<32; i=i+1) begin
                if (in[i] && ~in[i+1]) begin
                    out_reg[i] <= 1;
                end else begin
                    out_reg[i] <= 0;
                end
            end
        end
    end
    
    assign out = out_reg;
    
endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            for (int i=0; i<32; i=i+1) begin
                if (in[i] && ~in[i+1]) begin
                    out_reg[i] <= 1;
                end else begin
                    out_reg[i] <= 0;
                end
            end
        end
    end
    
    assign out = out_reg;
    
endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            for (int i=0; i<32; i=i+1) begin
                if (in[i] && ~in[i+1]) begin
                    out_reg[i] <= 1;
                end else begin
                    out_reg[i] <= 0;
                end
            end
        end
    end
    
    assign out = out_reg;
    
endmodule
"
"    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg & ~in | in & ~{in[31], in[30:0]};
        end
    end

    assign out = out_reg;

endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg & ~in | in & ~{in[31], in[30:0]};
        end
    end

    assign out = out_reg;

endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg & ~in | in & ~{in[31], in[30:0]};
        end
    end

    assign out = out_reg;

endmodule
"
"    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'h0;
        end else begin
            out_reg <= (out_reg & ~in) | (in & ~{1'b1, in[31:1]});
        end
    end

    assign out = out_reg;

endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'h0;
        end else begin
            out_reg <= (out_reg & ~in) | (in & ~{1'b1, in[31:1]});
        end
    end

    assign out = out_reg;

endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'h0;
        end else begin
            out_reg <= (out_reg & ~in) | (in & ~{1'b1, in[31:1]});
        end
    end

    assign out = out_reg;

endmodule
"
"    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            for (int i=0; i<32; i=i+1) begin
                if (in[i] & !out_reg[i]) begin
                    out_reg[i] <= 1;
                end else if (!in[i]) begin
                    out_reg[i] <= 0;
                end
            end
        end
    end

    assign out = out_reg;

endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            for (int i=0; i<32; i=i+1) begin
                if (in[i] & !out_reg[i]) begin
                    out_reg[i] <= 1;
                end else if (!in[i]) begin
                    out_reg[i] <= 0;
                end
            end
        end
    end

    assign out = out_reg;

endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            for (int i=0; i<32; i=i+1) begin
                if (in[i] & !out_reg[i]) begin
                    out_reg[i] <= 1;
                end else if (!in[i]) begin
                    out_reg[i] <= 0;
                end
            end
        end
    end

    assign out = out_reg;

endmodule
"
"    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            for (int i = 0; i < 32; i = i + 1) begin
                if (in[i] & !out_reg[i]) begin
                    out_reg[i] <= 1;
                end else if (!in[i]) begin
                    out_reg[i] <= 0;
                end
            end
        end
    end

    assign out = out_reg;
endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            for (int i = 0; i < 32; i = i + 1) begin
                if (in[i] & !out_reg[i]) begin
                    out_reg[i] <= 1;
                end else if (!in[i]) begin
                    out_reg[i] <= 0;
                end
            end
        end
    end

    assign out = out_reg;
endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            for (int i = 0; i < 32; i = i + 1) begin
                if (in[i] & !out_reg[i]) begin
                    out_reg[i] <= 1;
                end else if (!in[i]) begin
                    out_reg[i] <= 0;
                end
            end
        end
    end

    assign out = out_reg;
endmodule
"
"    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg | (in & ~{1'b0, in[31:0]});
        end
    end

    assign out = out_reg;

endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg | (in & ~{1'b0, in[31:0]});
        end
    end

    assign out = out_reg;

endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg | (in & ~{1'b0, in[31:0]});
        end
    end

    assign out = out_reg;

endmodule
"
"    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg | (in & ~out_reg);
        end
    end

    assign out = out_reg;

endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg | (in & ~out_reg);
        end
    end

    assign out = out_reg;

endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg | (in & ~out_reg);
        end
    end

    assign out = out_reg;

endmodule
"
"    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= (out_reg & ~in) | (in & ~out_reg);
        end
    end

    assign out = out_reg;

endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= (out_reg & ~in) | (in & ~out_reg);
        end
    end

    assign out = out_reg;

endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= (out_reg & ~in) | (in & ~out_reg);
        end
    end

    assign out = out_reg;

endmodule
"
"    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= (out_reg & ~in) | (in & ~out_reg);
        end
    end

    assign out = out_reg;

endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= (out_reg & ~in) | (in & ~out_reg);
        end
    end

    assign out = out_reg;

endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= (out_reg & ~in) | (in & ~out_reg);
        end
    end

    assign out = out_reg;

endmodule
"
"    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg | (in & ~{1'b0, in[31:0]});
        end
    end

    assign out = out_reg;

endmodule
",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg | (in & ~{1'b0, in[31:0]});
        end
    end

    assign out = out_reg;

endmodule
","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] out_reg;

    always @(posedge clk) begin
        if (reset) begin
            out_reg <= 32'b0;
        end else begin
            out_reg <= out_reg | (in & ~{1'b0, in[31:0]});
        end
    end

    assign out = out_reg;

endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
    
endmodule
",-1.0,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
    
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
    
endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"reg [7:0] prev_in;
reg [7:0] pedge;

always @(posedge clk) begin
    for (int i = 0; i < 8; i = i + 1) begin
        if (prev_in[i] == 0 && in[i] == 1) begin
            pedge[i] <= 1;
        end else begin
            pedge[i] <= 0;
        end
    end
    prev_in <= in;
end

endmodule
",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
reg [7:0] prev_in;
reg [7:0] pedge;

always @(posedge clk) begin
    for (int i = 0; i < 8; i = i + 1) begin
        if (prev_in[i] == 0 && in[i] == 1) begin
            pedge[i] <= 1;
        end else begin
            pedge[i] <= 0;
        end
    end
    prev_in <= in;
end

endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
reg [7:0] prev_in;
reg [7:0] pedge;

always @(posedge clk) begin
    for (int i = 0; i < 8; i = i + 1) begin
        if (prev_in[i] == 0 && in[i] == 1) begin
            pedge[i] <= 1;
        end else begin
            pedge[i] <= 0;
        end
    end
    prev_in <= in;
end

endmodule
"
"
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"reg [7:0] prev_in;

always @(posedge clk) begin
    for (int i=0; i<8; i=i+1) begin
        if (prev_in[i] == 0 && in[i] == 1) begin
            pedge[i] <= 1;
        end else begin
            pedge[i] <= 0;
        end
    end
    prev_in <= in;
end

endmodule
",-1.0,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
reg [7:0] prev_in;

always @(posedge clk) begin
    for (int i=0; i<8; i=i+1) begin
        if (prev_in[i] == 0 && in[i] == 1) begin
            pedge[i] <= 1;
        end else begin
            pedge[i] <= 0;
        end
    end
    prev_in <= in;
end

endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
reg [7:0] prev_in;

always @(posedge clk) begin
    for (int i=0; i<8; i=i+1) begin
        if (prev_in[i] == 0 && in[i] == 1) begin
            pedge[i] <= 1;
        end else begin
            pedge[i] <= 0;
        end
    end
    prev_in <= in;
end

endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (prev_in[i] == 0 && in[i] == 1) begin
                pedge[i] <= 1;
            end else begin
                pedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"    reg [7:0] previous_state;

    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !previous_state[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
            previous_state[i] <= in[i];
        end
    end
endmodule
",-1.0,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] previous_state;

    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !previous_state[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
            previous_state[i] <= in[i];
        end
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] previous_state;

    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !previous_state[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
            previous_state[i] <= in[i];
        end
    end
endmodule
"
"    reg [7:0] previous_state;

    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !previous_state[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
            previous_state[i] <= in[i];
        end
    end
endmodule
",-1.0,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] previous_state;

    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !previous_state[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
            previous_state[i] <= in[i];
        end
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] previous_state;

    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !previous_state[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
            previous_state[i] <= in[i];
        end
    end
endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"    reg [7:0] prev_in;
    reg [7:0] anyedge;

    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end

endmodule
",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    reg [7:0] anyedge;

    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end

endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    reg [7:0] anyedge;

    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end

endmodule
"
"
    reg [7:0] prev_in;
    reg [7:0] anyedge;

    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end

endmodule
",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] prev_in;
    reg [7:0] anyedge;

    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end

endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] prev_in;
    reg [7:0] anyedge;

    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end

endmodule
"
"
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i+1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i+1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i+1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (in[i] && !prev_in[i]) begin // detect rising edge
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (in[i] && !prev_in[i]) begin // detect rising edge
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i=0; i<8; i=i+1) begin
            if (in[i] && !prev_in[i]) begin // detect rising edge
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
",-1.0,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg [7:0] prev_in;
    
    always @(posedge clk) begin
        for (int i = 0; i < 8; i = i + 1) begin
            if (in[i] && !prev_in[i]) begin
                anyedge[i] <= 1;
            end else begin
                anyedge[i] <= 0;
            end
        end
        prev_in <= in;
    end
endmodule
"
"// Define the function f based on the Karnaugh map
assign f = (x[1] & x[4]) | (x[1] & x[2] & x[3]) | (x[1] & x[2] & x[3]) | (x[2] & x[3] & x[4]);

endmodule
",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);


// Define the function f based on the Karnaugh map
assign f = (x[1] & x[4]) | (x[1] & x[2] & x[3]) | (x[1] & x[2] & x[3]) | (x[2] & x[3] & x[4]);

endmodule
","module top_module (
    input [4:1] x,
    output f
);


// Define the function f based on the Karnaugh map
assign f = (x[1] & x[4]) | (x[1] & x[2] & x[3]) | (x[1] & x[2] & x[3]) | (x[2] & x[3] & x[4]);

endmodule
"
"
wire f;

assign f = x[1]'x[2]'x[3]'x[4]' | x[1]'x[2]x[3]x[4] | x[1]x[2]x[3]x[4] | x[1]x[2]'x[3]'; 

endmodule
",-1.0,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);



wire f;

assign f = x[1]'x[2]'x[3]'x[4]' | x[1]'x[2]x[3]x[4] | x[1]x[2]x[3]x[4] | x[1]x[2]'x[3]'; 

endmodule
","module top_module (
    input [4:1] x,
    output f
);



wire f;

assign f = x[1]'x[2]'x[3]'x[4]' | x[1]'x[2]x[3]x[4] | x[1]x[2]x[3]x[4] | x[1]x[2]'x[3]'; 

endmodule
"
"// Define the function f based on the values in the Karnaugh map
assign f = (x[4] & x[3] & x[2]) | (x[4] & x[3] & !x[1]) | (x[4] & !x[3] & x[2]) | (!x[4] & x[3] & !x[2]);

endmodule
",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);


// Define the function f based on the values in the Karnaugh map
assign f = (x[4] & x[3] & x[2]) | (x[4] & x[3] & !x[1]) | (x[4] & !x[3] & x[2]) | (!x[4] & x[3] & !x[2]);

endmodule
","module top_module (
    input [4:1] x,
    output f
);


// Define the function f based on the values in the Karnaugh map
assign f = (x[4] & x[3] & x[2]) | (x[4] & x[3] & !x[1]) | (x[4] & !x[3] & x[2]) | (!x[4] & x[3] & !x[2]);

endmodule
"
"
// Implementing the function f using the Karnaugh map values
assign f = (x[4] & x[3] & ~x[2] & x[1]) | (~x[4] & x[3] & x[2] & x[1]) | (x[4] & ~x[3] & x[2] & ~x[1]) | (x[4] & ~x[3] & ~x[2] & x[1]); 

endmodule
",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);



// Implementing the function f using the Karnaugh map values
assign f = (x[4] & x[3] & ~x[2] & x[1]) | (~x[4] & x[3] & x[2] & x[1]) | (x[4] & ~x[3] & x[2] & ~x[1]) | (x[4] & ~x[3] & ~x[2] & x[1]); 

endmodule
","module top_module (
    input [4:1] x,
    output f
);



// Implementing the function f using the Karnaugh map values
assign f = (x[4] & x[3] & ~x[2] & x[1]) | (~x[4] & x[3] & x[2] & x[1]) | (x[4] & ~x[3] & x[2] & ~x[1]) | (x[4] & ~x[3] & ~x[2] & x[1]); 

endmodule
"
"// Define the truth table for the function f based on the given Karnaugh map
// Order of x[4:1] bits in the Karnaugh map: x_3', x_3, x_4, x_4'
// f = x_1'x_2'x_3'x_4' + x_1'x_2x_3'x_4' + x_1x_2x_3x_4 + x_1x_2x_3x_4'

assign f = (x[1] & ~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[1] & x[2] & x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]);

endmodule
",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);


// Define the truth table for the function f based on the given Karnaugh map
// Order of x[4:1] bits in the Karnaugh map: x_3', x_3, x_4, x_4'
// f = x_1'x_2'x_3'x_4' + x_1'x_2x_3'x_4' + x_1x_2x_3x_4 + x_1x_2x_3x_4'

assign f = (x[1] & ~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[1] & x[2] & x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]);

endmodule
","module top_module (
    input [4:1] x,
    output f
);


// Define the truth table for the function f based on the given Karnaugh map
// Order of x[4:1] bits in the Karnaugh map: x_3', x_3, x_4, x_4'
// f = x_1'x_2'x_3'x_4' + x_1'x_2x_3'x_4' + x_1x_2x_3x_4 + x_1x_2x_3x_4'

assign f = (x[1] & ~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[1] & x[2] & x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]);

endmodule
"
"// Implementing the function f based on the given Karnaugh map

assign f = (x[1] & ~x[2] & ~x[3] & x[4]) | (~x[1] & ~x[2] & x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (x[1] & ~x[2] & ~x[3] & ~x[4]); 

endmodule
",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);


// Implementing the function f based on the given Karnaugh map

assign f = (x[1] & ~x[2] & ~x[3] & x[4]) | (~x[1] & ~x[2] & x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (x[1] & ~x[2] & ~x[3] & ~x[4]); 

endmodule
","module top_module (
    input [4:1] x,
    output f
);


// Implementing the function f based on the given Karnaugh map

assign f = (x[1] & ~x[2] & ~x[3] & x[4]) | (~x[1] & ~x[2] & x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (x[1] & ~x[2] & ~x[3] & ~x[4]); 

endmodule
"
"// Define the output function f based on the Karnaugh map
assign f = (x[4] & x[3] & x[1]) | (x[4] & x[2] & x[1]) | (x[3] & x[2] & x[1]) | (x[3] & x[4] & x[1]); 

endmodule
",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);


// Define the output function f based on the Karnaugh map
assign f = (x[4] & x[3] & x[1]) | (x[4] & x[2] & x[1]) | (x[3] & x[2] & x[1]) | (x[3] & x[4] & x[1]); 

endmodule
","module top_module (
    input [4:1] x,
    output f
);


// Define the output function f based on the Karnaugh map
assign f = (x[4] & x[3] & x[1]) | (x[4] & x[2] & x[1]) | (x[3] & x[2] & x[1]) | (x[3] & x[4] & x[1]); 

endmodule
"
"// Implementing the function f based on the given Karnaugh map

assign f = (x[4] & x[3] & !x[2] & x[1]) | (!x[4] & x[3] & x[2] & x[1]) | (x[4] & !x[3] & !x[2] & x[1]) | (x[4] & !x[3] & x[2] & !x[1]);

endmodule
",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);


// Implementing the function f based on the given Karnaugh map

assign f = (x[4] & x[3] & !x[2] & x[1]) | (!x[4] & x[3] & x[2] & x[1]) | (x[4] & !x[3] & !x[2] & x[1]) | (x[4] & !x[3] & x[2] & !x[1]);

endmodule
","module top_module (
    input [4:1] x,
    output f
);


// Implementing the function f based on the given Karnaugh map

assign f = (x[4] & x[3] & !x[2] & x[1]) | (!x[4] & x[3] & x[2] & x[1]) | (x[4] & !x[3] & !x[2] & x[1]) | (x[4] & !x[3] & x[2] & !x[1]);

endmodule
"
"wire f;

assign f = x[1]&x[4] | x[2]&x[3] | x[1]&x[2]&x[3] | x[1]&x[3]&x[4]; 

endmodule
",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);


wire f;

assign f = x[1]&x[4] | x[2]&x[3] | x[1]&x[2]&x[3] | x[1]&x[3]&x[4]; 

endmodule
","module top_module (
    input [4:1] x,
    output f
);


wire f;

assign f = x[1]&x[4] | x[2]&x[3] | x[1]&x[2]&x[3] | x[1]&x[3]&x[4]; 

endmodule
"
"// Define the function f based on the Karnaugh map
assign f = (x[4] & x[3] & !x[2] & x[1]) | (!x[4] & !x[3] & !x[2] & !x[1]) | (x[4] & x[3] & x[2] & !x[1]) | (x[4] & x[3] & !x[2] & x[1]);

endmodule
",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);


// Define the function f based on the Karnaugh map
assign f = (x[4] & x[3] & !x[2] & x[1]) | (!x[4] & !x[3] & !x[2] & !x[1]) | (x[4] & x[3] & x[2] & !x[1]) | (x[4] & x[3] & !x[2] & x[1]);

endmodule
","module top_module (
    input [4:1] x,
    output f
);


// Define the function f based on the Karnaugh map
assign f = (x[4] & x[3] & !x[2] & x[1]) | (!x[4] & !x[3] & !x[2] & !x[1]) | (x[4] & x[3] & x[2] & !x[1]) | (x[4] & x[3] & !x[2] & x[1]);

endmodule
"
"    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } fsm_state;

    // Define outputs
    reg f, g;
    // Define current state
    reg [1:0] current_state, next_state;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            current_state <= STATE_A;
            f <= 0;
            g <= 0;
        end else begin
            current_state <= next_state;
        end
    end

    always @(*) begin
        case (current_state)
            STATE_A: begin
                next_state = x ? STATE_B : STATE_A;
                f = 0;
                g = 0;
            end
            STATE_B: begin
                next_state = STATE_C;
                f = 1;
                g = 0;
            end
            STATE_C: begin
                next_state = x ? STATE_D : STATE_C;
                f = 0;
                g = 0;
            end
            STATE_D: begin
                next_state = (x && y) ? STATE_E : STATE_D;
                f = 0;
                g = 1;
            end
            STATE_E: begin
                next_state = (y || (g && (current_state == STATE_E))) ? STATE_E : STATE_A;
                f = 0;
                g = y ? 1 : 0;
            end
        endcase
    end

endmodule
",-1.0,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } fsm_state;

    // Define outputs
    reg f, g;
    // Define current state
    reg [1:0] current_state, next_state;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            current_state <= STATE_A;
            f <= 0;
            g <= 0;
        end else begin
            current_state <= next_state;
        end
    end

    always @(*) begin
        case (current_state)
            STATE_A: begin
                next_state = x ? STATE_B : STATE_A;
                f = 0;
                g = 0;
            end
            STATE_B: begin
                next_state = STATE_C;
                f = 1;
                g = 0;
            end
            STATE_C: begin
                next_state = x ? STATE_D : STATE_C;
                f = 0;
                g = 0;
            end
            STATE_D: begin
                next_state = (x && y) ? STATE_E : STATE_D;
                f = 0;
                g = 1;
            end
            STATE_E: begin
                next_state = (y || (g && (current_state == STATE_E))) ? STATE_E : STATE_A;
                f = 0;
                g = y ? 1 : 0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } fsm_state;

    // Define outputs
    reg f, g;
    // Define current state
    reg [1:0] current_state, next_state;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            current_state <= STATE_A;
            f <= 0;
            g <= 0;
        end else begin
            current_state <= next_state;
        end
    end

    always @(*) begin
        case (current_state)
            STATE_A: begin
                next_state = x ? STATE_B : STATE_A;
                f = 0;
                g = 0;
            end
            STATE_B: begin
                next_state = STATE_C;
                f = 1;
                g = 0;
            end
            STATE_C: begin
                next_state = x ? STATE_D : STATE_C;
                f = 0;
                g = 0;
            end
            STATE_D: begin
                next_state = (x && y) ? STATE_E : STATE_D;
                f = 0;
                g = 1;
            end
            STATE_E: begin
                next_state = (y || (g && (current_state == STATE_E))) ? STATE_E : STATE_A;
                f = 0;
                g = y ? 1 : 0;
            end
        endcase
    end

endmodule
"
"    // Define states
    parameter A = 2'b00;
    parameter B = 2'b01;
    parameter C = 2'b10;
    parameter D = 2'b11;
    
    // Define outputs
    reg f, g;
    
    // Define state register
    reg [1:0] state, next_state;
    
    // State transition and output logic
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state <= A;
            f <= 0;
            g <= 0;
        end
        else begin
            state <= next_state;
            case (state)
                A: begin
                    f <= 1;
                    next_state <= B;
                end
                B: begin
                    if (x == 1 && y == 0) begin
                        next_state <= C;
                    end
                    else begin
                        next_state <= B;
                    end
                end
                C: begin
                    if (x == 1 && y == 1) begin
                        g <= 1;
                        next_state <= D;
                    end
                    else if (x == 0) begin
                        next_state <= B;
                    end
                    else begin
                        next_state <= C;
                    end
                end
                D: begin
                    if (y == 1) begin
                        g <= 1;
                        next_state <= D;
                    end
                    else begin
                        g <= 0;
                        next_state <= D;
                    end
                end
            endcase
        end
    end
    
endmodule
",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    parameter A = 2'b00;
    parameter B = 2'b01;
    parameter C = 2'b10;
    parameter D = 2'b11;
    
    // Define outputs
    reg f, g;
    
    // Define state register
    reg [1:0] state, next_state;
    
    // State transition and output logic
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state <= A;
            f <= 0;
            g <= 0;
        end
        else begin
            state <= next_state;
            case (state)
                A: begin
                    f <= 1;
                    next_state <= B;
                end
                B: begin
                    if (x == 1 && y == 0) begin
                        next_state <= C;
                    end
                    else begin
                        next_state <= B;
                    end
                end
                C: begin
                    if (x == 1 && y == 1) begin
                        g <= 1;
                        next_state <= D;
                    end
                    else if (x == 0) begin
                        next_state <= B;
                    end
                    else begin
                        next_state <= C;
                    end
                end
                D: begin
                    if (y == 1) begin
                        g <= 1;
                        next_state <= D;
                    end
                    else begin
                        g <= 0;
                        next_state <= D;
                    end
                end
            endcase
        end
    end
    
endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    parameter A = 2'b00;
    parameter B = 2'b01;
    parameter C = 2'b10;
    parameter D = 2'b11;
    
    // Define outputs
    reg f, g;
    
    // Define state register
    reg [1:0] state, next_state;
    
    // State transition and output logic
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state <= A;
            f <= 0;
            g <= 0;
        end
        else begin
            state <= next_state;
            case (state)
                A: begin
                    f <= 1;
                    next_state <= B;
                end
                B: begin
                    if (x == 1 && y == 0) begin
                        next_state <= C;
                    end
                    else begin
                        next_state <= B;
                    end
                end
                C: begin
                    if (x == 1 && y == 1) begin
                        g <= 1;
                        next_state <= D;
                    end
                    else if (x == 0) begin
                        next_state <= B;
                    end
                    else begin
                        next_state <= C;
                    end
                end
                D: begin
                    if (y == 1) begin
                        g <= 1;
                        next_state <= D;
                    end
                    else begin
                        g <= 0;
                        next_state <= D;
                    end
                end
            endcase
        end
    end
    
endmodule
"
"    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D
    } state_t;

    // Define state register
    state_t state, next_state;

    // Define outputs
    reg f, g;

    // Define internal signals
    reg [2:0] x_history;
    reg [1:0] y_count;

    // Sequential logic
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state <= STATE_A;
            f <= 0;
            g <= 0;
            x_history <= 3'b0;
            y_count <= 2'b0;
        end else begin
            state <= next_state;
            case (state)
                STATE_A: begin
                    if (f) begin
                        next_state = STATE_B;
                    end else begin
                        next_state = STATE_A;
                    end
                end
                STATE_B: begin
                    if (x == 1 && x_history == 3'b101) begin
                        next_state = STATE_C;
                    end else begin
                        next_state = STATE_B;
                    end
                end
                STATE_C: begin
                    if (y == 1) begin
                        g <= 1;
                        next_state = STATE_D;
                    end else begin
                        next_state = STATE_C;
                    end
                end
                STATE_D: begin
                    if (y == 1) begin
                        g <= 1;
                    end else begin
                        g <= 0;
                    end
                    next_state = STATE_D;
                end
            endcase
        end
    end

    // Combinational logic
    always @* begin
        case (state)
            STATE_A: begin
                f = 0;
            end
            STATE_B: begin
                f = 1;
            end
            default: begin
                f = 0;
            end
        endcase
    end

endmodule
",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D
    } state_t;

    // Define state register
    state_t state, next_state;

    // Define outputs
    reg f, g;

    // Define internal signals
    reg [2:0] x_history;
    reg [1:0] y_count;

    // Sequential logic
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state <= STATE_A;
            f <= 0;
            g <= 0;
            x_history <= 3'b0;
            y_count <= 2'b0;
        end else begin
            state <= next_state;
            case (state)
                STATE_A: begin
                    if (f) begin
                        next_state = STATE_B;
                    end else begin
                        next_state = STATE_A;
                    end
                end
                STATE_B: begin
                    if (x == 1 && x_history == 3'b101) begin
                        next_state = STATE_C;
                    end else begin
                        next_state = STATE_B;
                    end
                end
                STATE_C: begin
                    if (y == 1) begin
                        g <= 1;
                        next_state = STATE_D;
                    end else begin
                        next_state = STATE_C;
                    end
                end
                STATE_D: begin
                    if (y == 1) begin
                        g <= 1;
                    end else begin
                        g <= 0;
                    end
                    next_state = STATE_D;
                end
            endcase
        end
    end

    // Combinational logic
    always @* begin
        case (state)
            STATE_A: begin
                f = 0;
            end
            STATE_B: begin
                f = 1;
            end
            default: begin
                f = 0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D
    } state_t;

    // Define state register
    state_t state, next_state;

    // Define outputs
    reg f, g;

    // Define internal signals
    reg [2:0] x_history;
    reg [1:0] y_count;

    // Sequential logic
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state <= STATE_A;
            f <= 0;
            g <= 0;
            x_history <= 3'b0;
            y_count <= 2'b0;
        end else begin
            state <= next_state;
            case (state)
                STATE_A: begin
                    if (f) begin
                        next_state = STATE_B;
                    end else begin
                        next_state = STATE_A;
                    end
                end
                STATE_B: begin
                    if (x == 1 && x_history == 3'b101) begin
                        next_state = STATE_C;
                    end else begin
                        next_state = STATE_B;
                    end
                end
                STATE_C: begin
                    if (y == 1) begin
                        g <= 1;
                        next_state = STATE_D;
                    end else begin
                        next_state = STATE_C;
                    end
                end
                STATE_D: begin
                    if (y == 1) begin
                        g <= 1;
                    end else begin
                        g <= 0;
                    end
                    next_state = STATE_D;
                end
            endcase
        end
    end

    // Combinational logic
    always @* begin
        case (state)
            STATE_A: begin
                f = 0;
            end
            STATE_B: begin
                f = 1;
            end
            default: begin
                f = 0;
            end
        endcase
    end

endmodule
"
"    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E,
        STATE_F
    } state_t;

    // Define state register and next state logic
    state_t state_reg, state_next;

    // Define outputs f and g
    logic f_reg, g_reg;

    // Define internal signals
    logic x_reg[2:0]; // Register to store past 3 values of x
    logic y_reg[1:0]; // Register to store past 2 values of y
    logic x_match, y_match;

    // State register
    always_ff @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state_reg <= STATE_A;
            f_reg <= 0;
            g_reg <= 0;
            x_reg <= 3'b0;
            y_reg <= 2'b0;
        end else begin
            state_reg <= state_next;
            f_reg <= 0;
            g_reg <= 0;
            x_reg <= {x_reg[1:0], x};
            y_reg <= {y_reg[0], y};
        end
    end

    // State logic
    always_comb begin
        case(state_reg)
            STATE_A: begin
                if (~resetn) begin
                    state_next = STATE_A;
                end else begin
                    state_next = STATE_B;
                end
            end
            STATE_B: begin
                state_next = STATE_C;
                f_reg = 1;
            end
            STATE_C: begin
                if (x_reg == 3'b101) begin
                    state_next = STATE_D;
                end else begin
                    state_next = STATE_C;
                end
            end
            STATE_D: begin
                if (y_reg == 2'b01) begin
                    state_next = STATE_E;
                    g_reg = 1;
                end else if (y_reg == 2'b00) begin
                    state_next = STATE_F;
                    g_reg = 0;
                end else begin
                    state_next = STATE_D;
                end
            end
            STATE_E: begin
                if (y == 1) begin
                    state_next = STATE_E;
                end else begin
                    state_next = STATE_F;
                    g_reg = 0;
                end
            end
            STATE_F: begin
                if (~resetn) begin
                    state_next = STATE_A;
                end else begin
                    state_next = STATE_F;
                end
            end
        endcase
    end

    // Assign outputs
    assign f = f_reg;
    assign g = g_reg;

endmodule
",-1.0,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E,
        STATE_F
    } state_t;

    // Define state register and next state logic
    state_t state_reg, state_next;

    // Define outputs f and g
    logic f_reg, g_reg;

    // Define internal signals
    logic x_reg[2:0]; // Register to store past 3 values of x
    logic y_reg[1:0]; // Register to store past 2 values of y
    logic x_match, y_match;

    // State register
    always_ff @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state_reg <= STATE_A;
            f_reg <= 0;
            g_reg <= 0;
            x_reg <= 3'b0;
            y_reg <= 2'b0;
        end else begin
            state_reg <= state_next;
            f_reg <= 0;
            g_reg <= 0;
            x_reg <= {x_reg[1:0], x};
            y_reg <= {y_reg[0], y};
        end
    end

    // State logic
    always_comb begin
        case(state_reg)
            STATE_A: begin
                if (~resetn) begin
                    state_next = STATE_A;
                end else begin
                    state_next = STATE_B;
                end
            end
            STATE_B: begin
                state_next = STATE_C;
                f_reg = 1;
            end
            STATE_C: begin
                if (x_reg == 3'b101) begin
                    state_next = STATE_D;
                end else begin
                    state_next = STATE_C;
                end
            end
            STATE_D: begin
                if (y_reg == 2'b01) begin
                    state_next = STATE_E;
                    g_reg = 1;
                end else if (y_reg == 2'b00) begin
                    state_next = STATE_F;
                    g_reg = 0;
                end else begin
                    state_next = STATE_D;
                end
            end
            STATE_E: begin
                if (y == 1) begin
                    state_next = STATE_E;
                end else begin
                    state_next = STATE_F;
                    g_reg = 0;
                end
            end
            STATE_F: begin
                if (~resetn) begin
                    state_next = STATE_A;
                end else begin
                    state_next = STATE_F;
                end
            end
        endcase
    end

    // Assign outputs
    assign f = f_reg;
    assign g = g_reg;

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E,
        STATE_F
    } state_t;

    // Define state register and next state logic
    state_t state_reg, state_next;

    // Define outputs f and g
    logic f_reg, g_reg;

    // Define internal signals
    logic x_reg[2:0]; // Register to store past 3 values of x
    logic y_reg[1:0]; // Register to store past 2 values of y
    logic x_match, y_match;

    // State register
    always_ff @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state_reg <= STATE_A;
            f_reg <= 0;
            g_reg <= 0;
            x_reg <= 3'b0;
            y_reg <= 2'b0;
        end else begin
            state_reg <= state_next;
            f_reg <= 0;
            g_reg <= 0;
            x_reg <= {x_reg[1:0], x};
            y_reg <= {y_reg[0], y};
        end
    end

    // State logic
    always_comb begin
        case(state_reg)
            STATE_A: begin
                if (~resetn) begin
                    state_next = STATE_A;
                end else begin
                    state_next = STATE_B;
                end
            end
            STATE_B: begin
                state_next = STATE_C;
                f_reg = 1;
            end
            STATE_C: begin
                if (x_reg == 3'b101) begin
                    state_next = STATE_D;
                end else begin
                    state_next = STATE_C;
                end
            end
            STATE_D: begin
                if (y_reg == 2'b01) begin
                    state_next = STATE_E;
                    g_reg = 1;
                end else if (y_reg == 2'b00) begin
                    state_next = STATE_F;
                    g_reg = 0;
                end else begin
                    state_next = STATE_D;
                end
            end
            STATE_E: begin
                if (y == 1) begin
                    state_next = STATE_E;
                end else begin
                    state_next = STATE_F;
                    g_reg = 0;
                end
            end
            STATE_F: begin
                if (~resetn) begin
                    state_next = STATE_A;
                end else begin
                    state_next = STATE_F;
                end
            end
        endcase
    end

    // Assign outputs
    assign f = f_reg;
    assign g = g_reg;

endmodule
"
"    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define outputs
    reg f, g;
    
    // State register
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state <= STATE_A;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            STATE_A: begin
                if (resetn) begin
                    next_state = STATE_B;
                end else begin
                    next_state = STATE_A;
                end
            end
            
            STATE_B: begin
                next_state = STATE_C;
            end
            
            STATE_C: begin
                if (x == 1 && $past(x) == 0 && $past($past(x)) == 1) begin
                    next_state = STATE_D;
                end else begin
                    next_state = STATE_C;
                end
            end
            
            STATE_D: begin
                if (y == 1) begin
                    next_state = STATE_E;
                end else begin
                    next_state = STATE_C;
                end
            end
            
            STATE_E: begin
                if (y == 1 || (y == 0 && $past(y) == 1)) begin
                    next_state = STATE_E;
                end else begin
                    next_state = STATE_C;
                end
            end
        endcase
    end
    
    // Output logic
    always @(*) begin
        case (state)
            STATE_A: begin
                f = 0;
                g = 0;
            end
            
            STATE_B: begin
                f = 1;
                g = 0;
            end
            
            STATE_C: begin
                f = 0;
                g = 0;
            end
            
            STATE_D: begin
                f = 0;
                g = 1;
            end
            
            STATE_E: begin
                f = 0;
                g = 1;
            end
        endcase
    end

endmodule
",-1.0,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define outputs
    reg f, g;
    
    // State register
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state <= STATE_A;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            STATE_A: begin
                if (resetn) begin
                    next_state = STATE_B;
                end else begin
                    next_state = STATE_A;
                end
            end
            
            STATE_B: begin
                next_state = STATE_C;
            end
            
            STATE_C: begin
                if (x == 1 && $past(x) == 0 && $past($past(x)) == 1) begin
                    next_state = STATE_D;
                end else begin
                    next_state = STATE_C;
                end
            end
            
            STATE_D: begin
                if (y == 1) begin
                    next_state = STATE_E;
                end else begin
                    next_state = STATE_C;
                end
            end
            
            STATE_E: begin
                if (y == 1 || (y == 0 && $past(y) == 1)) begin
                    next_state = STATE_E;
                end else begin
                    next_state = STATE_C;
                end
            end
        endcase
    end
    
    // Output logic
    always @(*) begin
        case (state)
            STATE_A: begin
                f = 0;
                g = 0;
            end
            
            STATE_B: begin
                f = 1;
                g = 0;
            end
            
            STATE_C: begin
                f = 0;
                g = 0;
            end
            
            STATE_D: begin
                f = 0;
                g = 1;
            end
            
            STATE_E: begin
                f = 0;
                g = 1;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define outputs
    reg f, g;
    
    // State register
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state <= STATE_A;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            STATE_A: begin
                if (resetn) begin
                    next_state = STATE_B;
                end else begin
                    next_state = STATE_A;
                end
            end
            
            STATE_B: begin
                next_state = STATE_C;
            end
            
            STATE_C: begin
                if (x == 1 && $past(x) == 0 && $past($past(x)) == 1) begin
                    next_state = STATE_D;
                end else begin
                    next_state = STATE_C;
                end
            end
            
            STATE_D: begin
                if (y == 1) begin
                    next_state = STATE_E;
                end else begin
                    next_state = STATE_C;
                end
            end
            
            STATE_E: begin
                if (y == 1 || (y == 0 && $past(y) == 1)) begin
                    next_state = STATE_E;
                end else begin
                    next_state = STATE_C;
                end
            end
        endcase
    end
    
    // Output logic
    always @(*) begin
        case (state)
            STATE_A: begin
                f = 0;
                g = 0;
            end
            
            STATE_B: begin
                f = 1;
                g = 0;
            end
            
            STATE_C: begin
                f = 0;
                g = 0;
            end
            
            STATE_D: begin
                f = 0;
                g = 1;
            end
            
            STATE_E: begin
                f = 0;
                g = 1;
            end
        endcase
    end

endmodule
"
"    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E,
        STATE_F
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define outputs
    logic f_out, g_out;

    always_ff @(posedge clk or negedge resetn) begin
        if (!resetn) begin
            state <= STATE_A;
            f_out <= 0;
            g_out <= 0;
        end else begin
            state <= next_state;
            f_out <= f_out;
            g_out <= g_out;
        end
    end

    always_comb begin
        next_state = state;
        f = f_out;
        g = g_out;

        case (state)
            STATE_A: begin
                if (!resetn) begin
                    next_state = STATE_A;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_B: begin
                if (x == 1) begin
                    next_state = STATE_C;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_C: begin
                if (x == 0) begin
                    next_state = STATE_D;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_D: begin
                if (x == 1) begin
                    next_state = STATE_E;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_E: begin
                if (y == 1) begin
                    next_state = STATE_F;
                end else if (y == 0) begin
                    next_state = STATE_A;
                end else begin
                    next_state = STATE_E;
                end
            end

            STATE_F: begin
                if (y == 1) begin
                    next_state = STATE_F;
                end else begin
                    next_state = STATE_A;
                end
            end
        endcase
    end

endmodule
",-1.0,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E,
        STATE_F
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define outputs
    logic f_out, g_out;

    always_ff @(posedge clk or negedge resetn) begin
        if (!resetn) begin
            state <= STATE_A;
            f_out <= 0;
            g_out <= 0;
        end else begin
            state <= next_state;
            f_out <= f_out;
            g_out <= g_out;
        end
    end

    always_comb begin
        next_state = state;
        f = f_out;
        g = g_out;

        case (state)
            STATE_A: begin
                if (!resetn) begin
                    next_state = STATE_A;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_B: begin
                if (x == 1) begin
                    next_state = STATE_C;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_C: begin
                if (x == 0) begin
                    next_state = STATE_D;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_D: begin
                if (x == 1) begin
                    next_state = STATE_E;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_E: begin
                if (y == 1) begin
                    next_state = STATE_F;
                end else if (y == 0) begin
                    next_state = STATE_A;
                end else begin
                    next_state = STATE_E;
                end
            end

            STATE_F: begin
                if (y == 1) begin
                    next_state = STATE_F;
                end else begin
                    next_state = STATE_A;
                end
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E,
        STATE_F
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define outputs
    logic f_out, g_out;

    always_ff @(posedge clk or negedge resetn) begin
        if (!resetn) begin
            state <= STATE_A;
            f_out <= 0;
            g_out <= 0;
        end else begin
            state <= next_state;
            f_out <= f_out;
            g_out <= g_out;
        end
    end

    always_comb begin
        next_state = state;
        f = f_out;
        g = g_out;

        case (state)
            STATE_A: begin
                if (!resetn) begin
                    next_state = STATE_A;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_B: begin
                if (x == 1) begin
                    next_state = STATE_C;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_C: begin
                if (x == 0) begin
                    next_state = STATE_D;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_D: begin
                if (x == 1) begin
                    next_state = STATE_E;
                end else begin
                    next_state = STATE_B;
                end
            end

            STATE_E: begin
                if (y == 1) begin
                    next_state = STATE_F;
                end else if (y == 0) begin
                    next_state = STATE_A;
                end else begin
                    next_state = STATE_E;
                end
            end

            STATE_F: begin
                if (y == 1) begin
                    next_state = STATE_F;
                end else begin
                    next_state = STATE_A;
                end
            end
        endcase
    end

endmodule
"
"    // Define states
    typedef enum logic [2:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } fsm_state_t;

    // Define outputs
    reg f, g;
    
    // Define current state and next state
    fsm_state_t current_state, next_state;
    
    // FSM logic
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            current_state <= STATE_A;
            f <= 0;
            g <= 0;
        end
        else begin
            current_state <= next_state;
            case (current_state)
                STATE_A: begin
                    f <= 1;
                    next_state <= STATE_B;
                end
                STATE_B: begin
                    if (x == 1 && $past(x) == 0 && $past($past(x)) == 1)
                        next_state <= STATE_C;
                    else
                        next_state <= STATE_B;
                end
                STATE_C: begin
                    if (y == 1)
                        next_state <= STATE_D;
                    else
                        next_state <= STATE_E;
                end
                STATE_D: begin
                    g <= 1;
                    next_state <= STATE_D;
                end
                STATE_E: begin
                    g <= 0;
                    next_state <= STATE_E;
                end
                default: next_state <= STATE_A;
            endcase
        end
    end

endmodule
",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [2:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } fsm_state_t;

    // Define outputs
    reg f, g;
    
    // Define current state and next state
    fsm_state_t current_state, next_state;
    
    // FSM logic
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            current_state <= STATE_A;
            f <= 0;
            g <= 0;
        end
        else begin
            current_state <= next_state;
            case (current_state)
                STATE_A: begin
                    f <= 1;
                    next_state <= STATE_B;
                end
                STATE_B: begin
                    if (x == 1 && $past(x) == 0 && $past($past(x)) == 1)
                        next_state <= STATE_C;
                    else
                        next_state <= STATE_B;
                end
                STATE_C: begin
                    if (y == 1)
                        next_state <= STATE_D;
                    else
                        next_state <= STATE_E;
                end
                STATE_D: begin
                    g <= 1;
                    next_state <= STATE_D;
                end
                STATE_E: begin
                    g <= 0;
                    next_state <= STATE_E;
                end
                default: next_state <= STATE_A;
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [2:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } fsm_state_t;

    // Define outputs
    reg f, g;
    
    // Define current state and next state
    fsm_state_t current_state, next_state;
    
    // FSM logic
    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            current_state <= STATE_A;
            f <= 0;
            g <= 0;
        end
        else begin
            current_state <= next_state;
            case (current_state)
                STATE_A: begin
                    f <= 1;
                    next_state <= STATE_B;
                end
                STATE_B: begin
                    if (x == 1 && $past(x) == 0 && $past($past(x)) == 1)
                        next_state <= STATE_C;
                    else
                        next_state <= STATE_B;
                end
                STATE_C: begin
                    if (y == 1)
                        next_state <= STATE_D;
                    else
                        next_state <= STATE_E;
                end
                STATE_D: begin
                    g <= 1;
                    next_state <= STATE_D;
                end
                STATE_E: begin
                    g <= 0;
                    next_state <= STATE_E;
                end
                default: next_state <= STATE_A;
            endcase
        end
    end

endmodule
"
"    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define outputs
    logic f_out, g_out;
    
    always_ff @(posedge clk or negedge resetn) begin
        if (!resetn) begin
            state <= STATE_A;
        end else begin
            state <= next_state;
        end
    end
    
    always_comb begin
        case (state)
            STATE_A: begin
                f_out = 0;
                g_out = 0;
                if (!resetn) begin
                    next_state = STATE_A;
                end else if (x == 1) begin
                    next_state = STATE_B;
                end else begin
                    next_state = STATE_A;
                end
            end
            STATE_B: begin
                f_out = 1;
                g_out = 0;
                next_state = STATE_C;
            end
            STATE_C: begin
                f_out = 0;
                g_out = 0;
                if (x == 0) begin
                    next_state = STATE_A;
                end else if (x == 1) begin
                    next_state = STATE_D;
                end else begin
                    next_state = STATE_C;
                end
            end
            STATE_D: begin
                f_out = 0;
                g_out = 1;
                next_state = STATE_E;
            end
            STATE_E: begin
                f_out = 0;
                if (y == 1) begin
                    g_out = 1;
                    next_state = STATE_E;
                end else if (y == 0) begin
                    g_out = 0;
                    next_state = STATE_A;
                end else begin
                    next_state = STATE_E;
                end
            end
            default: begin
                f_out = 0;
                g_out = 0;
                next_state = STATE_A;
            end
        endcase
    end
    
    // Assign outputs
    assign f = f_out;
    assign g = g_out;

endmodule
",-1.0,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define outputs
    logic f_out, g_out;
    
    always_ff @(posedge clk or negedge resetn) begin
        if (!resetn) begin
            state <= STATE_A;
        end else begin
            state <= next_state;
        end
    end
    
    always_comb begin
        case (state)
            STATE_A: begin
                f_out = 0;
                g_out = 0;
                if (!resetn) begin
                    next_state = STATE_A;
                end else if (x == 1) begin
                    next_state = STATE_B;
                end else begin
                    next_state = STATE_A;
                end
            end
            STATE_B: begin
                f_out = 1;
                g_out = 0;
                next_state = STATE_C;
            end
            STATE_C: begin
                f_out = 0;
                g_out = 0;
                if (x == 0) begin
                    next_state = STATE_A;
                end else if (x == 1) begin
                    next_state = STATE_D;
                end else begin
                    next_state = STATE_C;
                end
            end
            STATE_D: begin
                f_out = 0;
                g_out = 1;
                next_state = STATE_E;
            end
            STATE_E: begin
                f_out = 0;
                if (y == 1) begin
                    g_out = 1;
                    next_state = STATE_E;
                end else if (y == 0) begin
                    g_out = 0;
                    next_state = STATE_A;
                end else begin
                    next_state = STATE_E;
                end
            end
            default: begin
                f_out = 0;
                g_out = 0;
                next_state = STATE_A;
            end
        endcase
    end
    
    // Assign outputs
    assign f = f_out;
    assign g = g_out;

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define outputs
    logic f_out, g_out;
    
    always_ff @(posedge clk or negedge resetn) begin
        if (!resetn) begin
            state <= STATE_A;
        end else begin
            state <= next_state;
        end
    end
    
    always_comb begin
        case (state)
            STATE_A: begin
                f_out = 0;
                g_out = 0;
                if (!resetn) begin
                    next_state = STATE_A;
                end else if (x == 1) begin
                    next_state = STATE_B;
                end else begin
                    next_state = STATE_A;
                end
            end
            STATE_B: begin
                f_out = 1;
                g_out = 0;
                next_state = STATE_C;
            end
            STATE_C: begin
                f_out = 0;
                g_out = 0;
                if (x == 0) begin
                    next_state = STATE_A;
                end else if (x == 1) begin
                    next_state = STATE_D;
                end else begin
                    next_state = STATE_C;
                end
            end
            STATE_D: begin
                f_out = 0;
                g_out = 1;
                next_state = STATE_E;
            end
            STATE_E: begin
                f_out = 0;
                if (y == 1) begin
                    g_out = 1;
                    next_state = STATE_E;
                end else if (y == 0) begin
                    g_out = 0;
                    next_state = STATE_A;
                end else begin
                    next_state = STATE_E;
                end
            end
            default: begin
                f_out = 0;
                g_out = 0;
                next_state = STATE_A;
            end
        endcase
    end
    
    // Assign outputs
    assign f = f_out;
    assign g = g_out;

endmodule
"
"    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } state_t;

    // Define state register and next state
    state_t state_reg, state_next;

    // Define outputs
    reg f, g;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            // Reset condition
            state_reg <= STATE_A;
            f <= 0;
            g <= 0;
        end else begin
            // State transition logic
            state_reg <= state_next;
            f <= 0;
            g <= 0;

            // Next state logic
            case (state_reg)
                STATE_A: begin
                    if (x) begin
                        state_next <= STATE_B;
                    end else begin
                        state_next <= STATE_A;
                    end
                end
                STATE_B: begin
                    f <= 1;
                    state_next <= STATE_C;
                end
                STATE_C: begin
                    if (x) begin
                        state_next <= STATE_D;
                    end else begin
                        state_next <= STATE_C;
                    end
                end
                STATE_D: begin
                    if (x) begin
                        state_next <= STATE_E;
                    end else begin
                        state_next <= STATE_C;
                    end
                end
                STATE_E: begin
                    if (y) begin
                        g <= 1;
                        state_next <= STATE_E;
                    end else begin
                        g <= 0;
                        state_next <= STATE_E;
                    end
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } state_t;

    // Define state register and next state
    state_t state_reg, state_next;

    // Define outputs
    reg f, g;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            // Reset condition
            state_reg <= STATE_A;
            f <= 0;
            g <= 0;
        end else begin
            // State transition logic
            state_reg <= state_next;
            f <= 0;
            g <= 0;

            // Next state logic
            case (state_reg)
                STATE_A: begin
                    if (x) begin
                        state_next <= STATE_B;
                    end else begin
                        state_next <= STATE_A;
                    end
                end
                STATE_B: begin
                    f <= 1;
                    state_next <= STATE_C;
                end
                STATE_C: begin
                    if (x) begin
                        state_next <= STATE_D;
                    end else begin
                        state_next <= STATE_C;
                    end
                end
                STATE_D: begin
                    if (x) begin
                        state_next <= STATE_E;
                    end else begin
                        state_next <= STATE_C;
                    end
                end
                STATE_E: begin
                    if (y) begin
                        g <= 1;
                        state_next <= STATE_E;
                    end else begin
                        g <= 0;
                        state_next <= STATE_E;
                    end
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [1:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } state_t;

    // Define state register and next state
    state_t state_reg, state_next;

    // Define outputs
    reg f, g;

    always @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            // Reset condition
            state_reg <= STATE_A;
            f <= 0;
            g <= 0;
        end else begin
            // State transition logic
            state_reg <= state_next;
            f <= 0;
            g <= 0;

            // Next state logic
            case (state_reg)
                STATE_A: begin
                    if (x) begin
                        state_next <= STATE_B;
                    end else begin
                        state_next <= STATE_A;
                    end
                end
                STATE_B: begin
                    f <= 1;
                    state_next <= STATE_C;
                end
                STATE_C: begin
                    if (x) begin
                        state_next <= STATE_D;
                    end else begin
                        state_next <= STATE_C;
                    end
                end
                STATE_D: begin
                    if (x) begin
                        state_next <= STATE_E;
                    end else begin
                        state_next <= STATE_C;
                    end
                end
                STATE_E: begin
                    if (y) begin
                        g <= 1;
                        state_next <= STATE_E;
                    end else begin
                        g <= 0;
                        state_next <= STATE_E;
                    end
                end
            endcase
        end
    end

endmodule
"
"    // Define states
    typedef enum logic [2:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } fsm_state_t;

    // Define state register and next state
    fsm_state_t state_reg, state_next;

    // Define outputs
    logic f_reg, f_next;
    logic g_reg, g_next;

    // State register
    always_ff @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state_reg <= STATE_A;
            f_reg <= 0;
            g_reg <= 0;
        end else begin
            state_reg <= state_next;
            f_reg <= f_next;
            g_reg <= g_next;
        end
    end

    // Next state logic
    always_comb begin
        state_next = state_reg;
        f_next = f_reg;
        g_next = g_reg;

        case (state_reg)
            STATE_A: begin
                if (~resetn) begin
                    state_next = STATE_A;
                end else begin
                    state_next = STATE_B;
                    f_next = 1;
                end
            end
            STATE_B: begin
                state_next = (x == 1) ? STATE_C : STATE_B;
            end
            STATE_C: begin
                state_next = (x == 0) ? STATE_D : STATE_C;
            end
            STATE_D: begin
                state_next = (x == 1) ? STATE_E : STATE_B;
                g_next = (x == 1) ? 1 : 0;
            end
            STATE_E: begin
                state_next = (y == 1) ? STATE_E : STATE_B;
                g_next = (y == 1) ? 1 : 0;
            end
        endcase
    end

    // Output assignment
    assign f = f_reg;
    assign g = g_reg;

endmodule
",-1.0,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [2:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } fsm_state_t;

    // Define state register and next state
    fsm_state_t state_reg, state_next;

    // Define outputs
    logic f_reg, f_next;
    logic g_reg, g_next;

    // State register
    always_ff @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state_reg <= STATE_A;
            f_reg <= 0;
            g_reg <= 0;
        end else begin
            state_reg <= state_next;
            f_reg <= f_next;
            g_reg <= g_next;
        end
    end

    // Next state logic
    always_comb begin
        state_next = state_reg;
        f_next = f_reg;
        g_next = g_reg;

        case (state_reg)
            STATE_A: begin
                if (~resetn) begin
                    state_next = STATE_A;
                end else begin
                    state_next = STATE_B;
                    f_next = 1;
                end
            end
            STATE_B: begin
                state_next = (x == 1) ? STATE_C : STATE_B;
            end
            STATE_C: begin
                state_next = (x == 0) ? STATE_D : STATE_C;
            end
            STATE_D: begin
                state_next = (x == 1) ? STATE_E : STATE_B;
                g_next = (x == 1) ? 1 : 0;
            end
            STATE_E: begin
                state_next = (y == 1) ? STATE_E : STATE_B;
                g_next = (y == 1) ? 1 : 0;
            end
        endcase
    end

    // Output assignment
    assign f = f_reg;
    assign g = g_reg;

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);


    // Define states
    typedef enum logic [2:0] {
        STATE_A,
        STATE_B,
        STATE_C,
        STATE_D,
        STATE_E
    } fsm_state_t;

    // Define state register and next state
    fsm_state_t state_reg, state_next;

    // Define outputs
    logic f_reg, f_next;
    logic g_reg, g_next;

    // State register
    always_ff @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            state_reg <= STATE_A;
            f_reg <= 0;
            g_reg <= 0;
        end else begin
            state_reg <= state_next;
            f_reg <= f_next;
            g_reg <= g_next;
        end
    end

    // Next state logic
    always_comb begin
        state_next = state_reg;
        f_next = f_reg;
        g_next = g_reg;

        case (state_reg)
            STATE_A: begin
                if (~resetn) begin
                    state_next = STATE_A;
                end else begin
                    state_next = STATE_B;
                    f_next = 1;
                end
            end
            STATE_B: begin
                state_next = (x == 1) ? STATE_C : STATE_B;
            end
            STATE_C: begin
                state_next = (x == 0) ? STATE_D : STATE_C;
            end
            STATE_D: begin
                state_next = (x == 1) ? STATE_E : STATE_B;
                g_next = (x == 1) ? 1 : 0;
            end
            STATE_E: begin
                state_next = (y == 1) ? STATE_E : STATE_B;
                g_next = (y == 1) ? 1 : 0;
            end
        endcase
    end

    // Output assignment
    assign f = f_reg;
    assign g = g_reg;

endmodule
"
"    reg [2:0] present_state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
        end else begin
            present_state <= next_state;
        end
    end
    
    always @(*) begin
        case (present_state)
            3'b000: begin
                if (x == 1) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x == 1) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x == 1) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x == 1) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x == 1) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
        endcase
    end
endmodule
",-1.0,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] present_state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
        end else begin
            present_state <= next_state;
        end
    end
    
    always @(*) begin
        case (present_state)
            3'b000: begin
                if (x == 1) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x == 1) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x == 1) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x == 1) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x == 1) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] present_state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
        end else begin
            present_state <= next_state;
        end
    end
    
    always @(*) begin
        case (present_state)
            3'b000: begin
                if (x == 1) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x == 1) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x == 1) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x == 1) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x == 1) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
        endcase
    end
endmodule
"
"    reg [2:0] present_state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
        end else begin
            present_state <= next_state;
        end
    end
    
    always @* begin
        case (present_state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end
endmodule
",-1.0,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] present_state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
        end else begin
            present_state <= next_state;
        end
    end
    
    always @* begin
        case (present_state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] present_state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
        end else begin
            present_state <= next_state;
        end
    end
    
    always @* begin
        case (present_state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end
endmodule
"
"
    reg [2:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end
    
    always @(*) begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b010;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b010;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b011;
                end
            end
        endcase
    end
    
    assign z = (state == 3'b011) ? 1'b1 : 1'b0;
    
endmodule
",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);


    reg [2:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end
    
    always @(*) begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b010;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b010;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b011;
                end
            end
        endcase
    end
    
    assign z = (state == 3'b011) ? 1'b1 : 1'b0;
    
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);


    reg [2:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end
    
    always @(*) begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b010;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b010;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b011;
                end
            end
        endcase
    end
    
    assign z = (state == 3'b011) ? 1'b1 : 1'b0;
    
endmodule
"
"    reg [2:0] state, next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case (state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end

endmodule
",-1.0,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case (state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case (state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end

endmodule
"
"    reg [2:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end
    
    always @(*) begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end
endmodule
",-1.0,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end
    
    always @(*) begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end
    
    always @(*) begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end
endmodule
"
"
    reg [2:0] present_state, next_state;
    reg output_z;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
            output_z <= 1'b0;
        end else begin
            present_state <= next_state;
            output_z <= (present_state == 3'b011) ? 1'b1 : 1'b0;
        end
    end
    
    always @(*) begin
        case (present_state)
            3'b000: begin
                next_state = x ? 3'b001 : 3'b000;
            end
            3'b001: begin
                next_state = x ? 3'b100 : 3'b001;
            end
            3'b010: begin
                next_state = x ? 3'b001 : 3'b010;
            end
            3'b011: begin
                next_state = x ? 3'b010 : 3'b001;
            end
            3'b100: begin
                next_state = x ? 3'b100 : 3'b011;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    assign z = output_z;
    
endmodule
",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);


    reg [2:0] present_state, next_state;
    reg output_z;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
            output_z <= 1'b0;
        end else begin
            present_state <= next_state;
            output_z <= (present_state == 3'b011) ? 1'b1 : 1'b0;
        end
    end
    
    always @(*) begin
        case (present_state)
            3'b000: begin
                next_state = x ? 3'b001 : 3'b000;
            end
            3'b001: begin
                next_state = x ? 3'b100 : 3'b001;
            end
            3'b010: begin
                next_state = x ? 3'b001 : 3'b010;
            end
            3'b011: begin
                next_state = x ? 3'b010 : 3'b001;
            end
            3'b100: begin
                next_state = x ? 3'b100 : 3'b011;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    assign z = output_z;
    
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);


    reg [2:0] present_state, next_state;
    reg output_z;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
            output_z <= 1'b0;
        end else begin
            present_state <= next_state;
            output_z <= (present_state == 3'b011) ? 1'b1 : 1'b0;
        end
    end
    
    always @(*) begin
        case (present_state)
            3'b000: begin
                next_state = x ? 3'b001 : 3'b000;
            end
            3'b001: begin
                next_state = x ? 3'b100 : 3'b001;
            end
            3'b010: begin
                next_state = x ? 3'b001 : 3'b010;
            end
            3'b011: begin
                next_state = x ? 3'b010 : 3'b001;
            end
            3'b100: begin
                next_state = x ? 3'b100 : 3'b011;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    assign z = output_z;
    
endmodule
"
"
    reg [2:0] present_state, next_state;
    reg output_z;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
            output_z <= 1'b0;
        end else begin
            present_state <= next_state;
            output_z <= (present_state == 3'b011) ? 1'b1 : 1'b0;
        end
    end
    
    always @* begin
        case (present_state)
            3'b000: begin
                next_state = x ? 3'b001 : 3'b000;
            end
            3'b001: begin
                next_state = x ? 3'b100 : 3'b001;
            end
            3'b010: begin
                next_state = x ? 3'b001 : 3'b010;
            end
            3'b011: begin
                next_state = x ? 3'b010 : 3'b001;
            end
            3'b100: begin
                next_state = x ? 3'b100 : 3'b011;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    assign z = output_z;
    
endmodule
",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);


    reg [2:0] present_state, next_state;
    reg output_z;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
            output_z <= 1'b0;
        end else begin
            present_state <= next_state;
            output_z <= (present_state == 3'b011) ? 1'b1 : 1'b0;
        end
    end
    
    always @* begin
        case (present_state)
            3'b000: begin
                next_state = x ? 3'b001 : 3'b000;
            end
            3'b001: begin
                next_state = x ? 3'b100 : 3'b001;
            end
            3'b010: begin
                next_state = x ? 3'b001 : 3'b010;
            end
            3'b011: begin
                next_state = x ? 3'b010 : 3'b001;
            end
            3'b100: begin
                next_state = x ? 3'b100 : 3'b011;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    assign z = output_z;
    
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);


    reg [2:0] present_state, next_state;
    reg output_z;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            present_state <= 3'b000;
            output_z <= 1'b0;
        end else begin
            present_state <= next_state;
            output_z <= (present_state == 3'b011) ? 1'b1 : 1'b0;
        end
    end
    
    always @* begin
        case (present_state)
            3'b000: begin
                next_state = x ? 3'b001 : 3'b000;
            end
            3'b001: begin
                next_state = x ? 3'b100 : 3'b001;
            end
            3'b010: begin
                next_state = x ? 3'b001 : 3'b010;
            end
            3'b011: begin
                next_state = x ? 3'b010 : 3'b001;
            end
            3'b100: begin
                next_state = x ? 3'b100 : 3'b011;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    assign z = output_z;
    
endmodule
"
"    reg [2:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            3'b000: begin
                if (x == 1) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b000;
                end
            end
            3'b001: begin
                if (x == 1) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b010: begin
                if (x == 1) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b010;
                end
            end
            3'b011: begin
                if (x == 1) begin
                    next_state = 3'b010;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b100: begin
                if (x == 1) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b011;
                end
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign z = (state == 3'b011) ? 1 : 0;
    
endmodule
",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            3'b000: begin
                if (x == 1) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b000;
                end
            end
            3'b001: begin
                if (x == 1) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b010: begin
                if (x == 1) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b010;
                end
            end
            3'b011: begin
                if (x == 1) begin
                    next_state = 3'b010;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b100: begin
                if (x == 1) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b011;
                end
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign z = (state == 3'b011) ? 1 : 0;
    
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            3'b000: begin
                if (x == 1) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b000;
                end
            end
            3'b001: begin
                if (x == 1) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b010: begin
                if (x == 1) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b010;
                end
            end
            3'b011: begin
                if (x == 1) begin
                    next_state = 3'b010;
                end else begin
                    next_state = 3'b001;
                end
            end
            3'b100: begin
                if (x == 1) begin
                    next_state = 3'b100;
                end else begin
                    next_state = 3'b011;
                end
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign z = (state == 3'b011) ? 1 : 0;
    
endmodule
"
"    reg [2:0] state, next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end

endmodule
",-1.0,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end

endmodule
"
"    reg [2:0] state, next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end
endmodule
",-1.0,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    reg [2:0] state, next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            3'b000: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b000;
                    z = 1'b0;
                end
            end
            3'b001: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b0;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b010: begin
                if (x) begin
                    next_state = 3'b001;
                    z = 1'b0;
                end else begin
                    next_state = 3'b010;
                    z = 1'b0;
                end
            end
            3'b011: begin
                if (x) begin
                    next_state = 3'b010;
                    z = 1'b1;
                end else begin
                    next_state = 3'b001;
                    z = 1'b0;
                end
            end
            3'b100: begin
                if (x) begin
                    next_state = 3'b100;
                    z = 1'b1;
                end else begin
                    next_state = 3'b011;
                    z = 1'b0;
                end
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end
endmodule
"
"    reg [2:0] next_state;
    reg [1:0] output_z;
    
    always @ (posedge clk) begin
        case ({y, x})
            3'b000_0: begin
                next_state <= 3'b000;
                output_z <= 2'b00;
            end
            3'b001_0: begin
                next_state <= 3'b001;
                output_z <= 2'b00;
            end
            3'b010_0: begin
                next_state <= 3'b010;
                output_z <= 2'b00;
            end
            3'b011_0: begin
                next_state <= 3'b001;
                output_z <= 2'b01;
            end
            3'b100_0: begin
                next_state <= 3'b011;
                output_z <= 2'b01;
            end
            default: begin
                next_state <= 3'b000;
                output_z <= 2'b00;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = output_z[1];
endmodule
",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    reg [1:0] output_z;
    
    always @ (posedge clk) begin
        case ({y, x})
            3'b000_0: begin
                next_state <= 3'b000;
                output_z <= 2'b00;
            end
            3'b001_0: begin
                next_state <= 3'b001;
                output_z <= 2'b00;
            end
            3'b010_0: begin
                next_state <= 3'b010;
                output_z <= 2'b00;
            end
            3'b011_0: begin
                next_state <= 3'b001;
                output_z <= 2'b01;
            end
            3'b100_0: begin
                next_state <= 3'b011;
                output_z <= 2'b01;
            end
            default: begin
                next_state <= 3'b000;
                output_z <= 2'b00;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = output_z[1];
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    reg [1:0] output_z;
    
    always @ (posedge clk) begin
        case ({y, x})
            3'b000_0: begin
                next_state <= 3'b000;
                output_z <= 2'b00;
            end
            3'b001_0: begin
                next_state <= 3'b001;
                output_z <= 2'b00;
            end
            3'b010_0: begin
                next_state <= 3'b010;
                output_z <= 2'b00;
            end
            3'b011_0: begin
                next_state <= 3'b001;
                output_z <= 2'b01;
            end
            3'b100_0: begin
                next_state <= 3'b011;
                output_z <= 2'b01;
            end
            default: begin
                next_state <= 3'b000;
                output_z <= 2'b00;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = output_z[1];
endmodule
"
"    reg [2:0] next_state;
    
    always @(posedge clk) begin
        case ({y, x})
            3'b0000: begin
                next_state = 3'b000;
                z = 0;
            end
            3'b0010: begin
                next_state = 3'b001;
                z = 0;
            end
            3'b0100: begin
                next_state = 3'b010;
                z = 0;
            end
            3'b0111: begin
                next_state = 3'b001;
                z = 1;
            end
            3'b1000: begin
                next_state = 3'b011;
                z = 1;
            end
            default: begin
                next_state = 3'b000;
                z = 0;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
    
endmodule
",-1.0,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @(posedge clk) begin
        case ({y, x})
            3'b0000: begin
                next_state = 3'b000;
                z = 0;
            end
            3'b0010: begin
                next_state = 3'b001;
                z = 0;
            end
            3'b0100: begin
                next_state = 3'b010;
                z = 0;
            end
            3'b0111: begin
                next_state = 3'b001;
                z = 1;
            end
            3'b1000: begin
                next_state = 3'b011;
                z = 1;
            end
            default: begin
                next_state = 3'b000;
                z = 0;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
    
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @(posedge clk) begin
        case ({y, x})
            3'b0000: begin
                next_state = 3'b000;
                z = 0;
            end
            3'b0010: begin
                next_state = 3'b001;
                z = 0;
            end
            3'b0100: begin
                next_state = 3'b010;
                z = 0;
            end
            3'b0111: begin
                next_state = 3'b001;
                z = 1;
            end
            3'b1000: begin
                next_state = 3'b011;
                z = 1;
            end
            default: begin
                next_state = 3'b000;
                z = 0;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
    
endmodule
"
"    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case ({y, x})
            3'b0000: next_state = 3'b000;
            3'b0001: next_state = 3'b001;
            3'b0010: next_state = 3'b001;
            3'b0011: next_state = 3'b010;
            3'b0100: next_state = 3'b001;
            default: next_state = 3'b000;
        endcase
    end
    
    assign Y0 = next_state[0];
    
    always @* begin
        case (y)
            3'b011: z = 1;
            3'b100: z = 1;
            default: z = 0;
        endcase
    end
endmodule
",-1.0,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case ({y, x})
            3'b0000: next_state = 3'b000;
            3'b0001: next_state = 3'b001;
            3'b0010: next_state = 3'b001;
            3'b0011: next_state = 3'b010;
            3'b0100: next_state = 3'b001;
            default: next_state = 3'b000;
        endcase
    end
    
    assign Y0 = next_state[0];
    
    always @* begin
        case (y)
            3'b011: z = 1;
            3'b100: z = 1;
            default: z = 0;
        endcase
    end
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case ({y, x})
            3'b0000: next_state = 3'b000;
            3'b0001: next_state = 3'b001;
            3'b0010: next_state = 3'b001;
            3'b0011: next_state = 3'b010;
            3'b0100: next_state = 3'b001;
            default: next_state = 3'b000;
        endcase
    end
    
    assign Y0 = next_state[0];
    
    always @* begin
        case (y)
            3'b011: z = 1;
            3'b100: z = 1;
            default: z = 0;
        endcase
    end
endmodule
"
"    reg [2:0] next_state;
    
    always @(posedge clk) begin
        case({y, x})
            3'b000  : next_state = 3'b001;
            3'b001  : next_state = 3'b100;
            3'b010  : next_state = 3'b001;
            3'b011  : next_state = 3'b010;
            3'b100  : next_state = 3'b100;
            default : next_state = 3'b000;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011 && x == 1) ? 1 : 0;
endmodule
",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @(posedge clk) begin
        case({y, x})
            3'b000  : next_state = 3'b001;
            3'b001  : next_state = 3'b100;
            3'b010  : next_state = 3'b001;
            3'b011  : next_state = 3'b010;
            3'b100  : next_state = 3'b100;
            default : next_state = 3'b000;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011 && x == 1) ? 1 : 0;
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @(posedge clk) begin
        case({y, x})
            3'b000  : next_state = 3'b001;
            3'b001  : next_state = 3'b100;
            3'b010  : next_state = 3'b001;
            3'b011  : next_state = 3'b010;
            3'b100  : next_state = 3'b100;
            default : next_state = 3'b000;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011 && x == 1) ? 1 : 0;
endmodule
"
"    reg [2:0] next_state;
    reg z_output;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: begin
                next_state <= 3'b001;
                z_output <= 1'b0;
            end
            3'b001: begin
                next_state <= 3'b100;
                z_output <= 1'b0;
            end
            3'b010: begin
                next_state <= 3'b001;
                z_output <= 1'b0;
            end
            3'b011: begin
                next_state <= 3'b010;
                z_output <= 1'b1;
            end
            3'b100: begin
                next_state <= 3'b100;
                z_output <= 1'b1;
            end
            default: begin
                next_state <= 3'b000;
                z_output <= 1'b0;
            end
        endcase
    end

    assign Y0 = next_state[0];
    assign z = z_output;
endmodule
",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    reg z_output;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: begin
                next_state <= 3'b001;
                z_output <= 1'b0;
            end
            3'b001: begin
                next_state <= 3'b100;
                z_output <= 1'b0;
            end
            3'b010: begin
                next_state <= 3'b001;
                z_output <= 1'b0;
            end
            3'b011: begin
                next_state <= 3'b010;
                z_output <= 1'b1;
            end
            3'b100: begin
                next_state <= 3'b100;
                z_output <= 1'b1;
            end
            default: begin
                next_state <= 3'b000;
                z_output <= 1'b0;
            end
        endcase
    end

    assign Y0 = next_state[0];
    assign z = z_output;
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    reg z_output;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: begin
                next_state <= 3'b001;
                z_output <= 1'b0;
            end
            3'b001: begin
                next_state <= 3'b100;
                z_output <= 1'b0;
            end
            3'b010: begin
                next_state <= 3'b001;
                z_output <= 1'b0;
            end
            3'b011: begin
                next_state <= 3'b010;
                z_output <= 1'b1;
            end
            3'b100: begin
                next_state <= 3'b100;
                z_output <= 1'b1;
            end
            default: begin
                next_state <= 3'b000;
                z_output <= 1'b0;
            end
        endcase
    end

    assign Y0 = next_state[0];
    assign z = z_output;
endmodule
"
"    reg [2:0] next_state;
    reg z_next;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: begin
                next_state <= 3'b001;
                z_next <= 1'b0;
            end
            3'b001: begin
                next_state <= 3'b100;
                z_next <= 1'b0;
            end
            3'b010: begin
                next_state <= 3'b001;
                z_next <= 1'b0;
            end
            3'b011: begin
                next_state <= 3'b010;
                z_next <= 1'b1;
            end
            3'b100: begin
                next_state <= 3'b100;
                z_next <= 1'b1;
            end
            default: begin
                next_state <= 3'b000;
                z_next <= 1'b0;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = z_next;
endmodule
",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    reg z_next;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: begin
                next_state <= 3'b001;
                z_next <= 1'b0;
            end
            3'b001: begin
                next_state <= 3'b100;
                z_next <= 1'b0;
            end
            3'b010: begin
                next_state <= 3'b001;
                z_next <= 1'b0;
            end
            3'b011: begin
                next_state <= 3'b010;
                z_next <= 1'b1;
            end
            3'b100: begin
                next_state <= 3'b100;
                z_next <= 1'b1;
            end
            default: begin
                next_state <= 3'b000;
                z_next <= 1'b0;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = z_next;
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    reg z_next;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: begin
                next_state <= 3'b001;
                z_next <= 1'b0;
            end
            3'b001: begin
                next_state <= 3'b100;
                z_next <= 1'b0;
            end
            3'b010: begin
                next_state <= 3'b001;
                z_next <= 1'b0;
            end
            3'b011: begin
                next_state <= 3'b010;
                z_next <= 1'b1;
            end
            3'b100: begin
                next_state <= 3'b100;
                z_next <= 1'b1;
            end
            default: begin
                next_state <= 3'b000;
                z_next <= 1'b0;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = z_next;
endmodule
"
"    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: next_state = 3'b001;
            3'b001: next_state = 3'b100;
            3'b010: next_state = 3'b001;
            3'b011: next_state = 3'b010;
            3'b100: next_state = 3'b100;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011 || y == 3'b100) ? 1 : 0;
endmodule
",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: next_state = 3'b001;
            3'b001: next_state = 3'b100;
            3'b010: next_state = 3'b001;
            3'b011: next_state = 3'b010;
            3'b100: next_state = 3'b100;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011 || y == 3'b100) ? 1 : 0;
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: next_state = 3'b001;
            3'b001: next_state = 3'b100;
            3'b010: next_state = 3'b001;
            3'b011: next_state = 3'b010;
            3'b100: next_state = 3'b100;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011 || y == 3'b100) ? 1 : 0;
endmodule
"
"    reg [2:0] next_state;
    
    always @(posedge clk) begin
        case({x, y})
            3'b000: next_state = 3'b000;
            3'b001: next_state = 3'b100;
            3'b010: next_state = 3'b001;
            3'b011: next_state = 3'b010;
            3'b100: next_state = 3'b100;
            default: next_state = 3'b000;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011) ? 1 : 0;
endmodule
",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @(posedge clk) begin
        case({x, y})
            3'b000: next_state = 3'b000;
            3'b001: next_state = 3'b100;
            3'b010: next_state = 3'b001;
            3'b011: next_state = 3'b010;
            3'b100: next_state = 3'b100;
            default: next_state = 3'b000;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011) ? 1 : 0;
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @(posedge clk) begin
        case({x, y})
            3'b000: next_state = 3'b000;
            3'b001: next_state = 3'b100;
            3'b010: next_state = 3'b001;
            3'b011: next_state = 3'b010;
            3'b100: next_state = 3'b100;
            default: next_state = 3'b000;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011) ? 1 : 0;
endmodule
"
"    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: next_state = 3'b001;
            3'b001: next_state = 3'b100;
            3'b010: next_state = 3'b001;
            3'b011: next_state = 3'b010;
            3'b100: next_state = 3'b100;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011 || y == 3'b100) ? 1 : 0;
endmodule
",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: next_state = 3'b001;
            3'b001: next_state = 3'b100;
            3'b010: next_state = 3'b001;
            3'b011: next_state = 3'b010;
            3'b100: next_state = 3'b100;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011 || y == 3'b100) ? 1 : 0;
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case (y)
            3'b000: next_state = 3'b001;
            3'b001: next_state = 3'b100;
            3'b010: next_state = 3'b001;
            3'b011: next_state = 3'b010;
            3'b100: next_state = 3'b100;
        endcase
    end
    
    assign Y0 = next_state[0];
    assign z = (y == 3'b011 || y == 3'b100) ? 1 : 0;
endmodule
"
"    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case ({y, x})
            3'b0000: begin
                next_state = 3'b000;
                z = 0;
            end
            3'b0001: begin
                next_state = 3'b001;
                z = 0;
            end
            3'b0010: begin
                next_state = 3'b010;
                z = 0;
            end
            3'b0011: begin
                next_state = 3'b001;
                z = 1;
            end
            3'b0100: begin
                next_state = 3'b011;
                z = 1;
            end
            default: begin
                next_state = 3'b000;
                z = 0;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
endmodule
",-1.0,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case ({y, x})
            3'b0000: begin
                next_state = 3'b000;
                z = 0;
            end
            3'b0001: begin
                next_state = 3'b001;
                z = 0;
            end
            3'b0010: begin
                next_state = 3'b010;
                z = 0;
            end
            3'b0011: begin
                next_state = 3'b001;
                z = 1;
            end
            3'b0100: begin
                next_state = 3'b011;
                z = 1;
            end
            default: begin
                next_state = 3'b000;
                z = 0;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
endmodule
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] next_state;
    
    always @ (posedge clk) begin
        case ({y, x})
            3'b0000: begin
                next_state = 3'b000;
                z = 0;
            end
            3'b0001: begin
                next_state = 3'b001;
                z = 0;
            end
            3'b0010: begin
                next_state = 3'b010;
                z = 0;
            end
            3'b0011: begin
                next_state = 3'b001;
                z = 1;
            end
            3'b0100: begin
                next_state = 3'b011;
                z = 1;
            end
            default: begin
                next_state = 3'b000;
                z = 0;
            end
        endcase
    end
    
    assign Y0 = next_state[0];
endmodule
"
"    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 0;
        end else begin
            case(state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Move to state C
                    end else begin
                        state <= 2'b11; // Move to state D
                    end
                end
                2'b10: begin // State C
                    if (w == 1) begin
                        z_reg <= 1; // Set output z to 1
                    end
                    state <= 2'b01; // Move back to state B
                end
                2'b11: begin // State D
                    z_reg <= 0; // Set output z to 0
                    state <= 2'b01; // Move back to state B
                end
            endcase
        end
    end
    
    assign z = z_reg;
endmodule
",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 0;
        end else begin
            case(state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Move to state C
                    end else begin
                        state <= 2'b11; // Move to state D
                    end
                end
                2'b10: begin // State C
                    if (w == 1) begin
                        z_reg <= 1; // Set output z to 1
                    end
                    state <= 2'b01; // Move back to state B
                end
                2'b11: begin // State D
                    z_reg <= 0; // Set output z to 0
                    state <= 2'b01; // Move back to state B
                end
            endcase
        end
    end
    
    assign z = z_reg;
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 0;
        end else begin
            case(state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Move to state C
                    end else begin
                        state <= 2'b11; // Move to state D
                    end
                end
                2'b10: begin // State C
                    if (w == 1) begin
                        z_reg <= 1; // Set output z to 1
                    end
                    state <= 2'b01; // Move back to state B
                end
                2'b11: begin // State D
                    z_reg <= 0; // Set output z to 0
                    state <= 2'b01; // Move back to state B
                end
            endcase
        end
    end
    
    assign z = z_reg;
endmodule
"
"    reg [1:0] state;
    reg z_output;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_output <= 0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check next two clock cycles
                    end else begin
                        state <= 2'b11; // Transition to check next two clock cycles
                    end
                end
                2'b10: begin // Check next two clock cycles
                    if (w == 1) begin
                        z_output <= 1; // Set output z to 1
                    end else begin
                        z_output <= 0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
                2'b11: begin // Check next two clock cycles
                    if (w == 1) begin
                        z_output <= 1; // Set output z to 1
                    end else begin
                        z_output <= 0; // Set output z to 0
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end

    assign z = z_output;

endmodule
",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;
    reg z_output;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_output <= 0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check next two clock cycles
                    end else begin
                        state <= 2'b11; // Transition to check next two clock cycles
                    end
                end
                2'b10: begin // Check next two clock cycles
                    if (w == 1) begin
                        z_output <= 1; // Set output z to 1
                    end else begin
                        z_output <= 0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
                2'b11: begin // Check next two clock cycles
                    if (w == 1) begin
                        z_output <= 1; // Set output z to 1
                    end else begin
                        z_output <= 0; // Set output z to 0
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end

    assign z = z_output;

endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;
    reg z_output;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_output <= 0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check next two clock cycles
                    end else begin
                        state <= 2'b11; // Transition to check next two clock cycles
                    end
                end
                2'b10: begin // Check next two clock cycles
                    if (w == 1) begin
                        z_output <= 1; // Set output z to 1
                    end else begin
                        z_output <= 0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
                2'b11: begin // Check next two clock cycles
                    if (w == 1) begin
                        z_output <= 1; // Set output z to 1
                    end else begin
                        z_output <= 0; // Set output z to 0
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end

    assign z = z_output;

endmodule
"
"
    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 1'b0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w) begin
                        state <= 2'b10; // Move to state C
                    end else begin
                        state <= 2'b00; // Move back to state A
                    end
                end
                2'b10: begin // State C
                    if (w) begin
                        z_reg <= 1'b1;
                    end else begin
                        z_reg <= 1'b0;
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end
    
    assign z = z_reg;
endmodule
",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 1'b0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w) begin
                        state <= 2'b10; // Move to state C
                    end else begin
                        state <= 2'b00; // Move back to state A
                    end
                end
                2'b10: begin // State C
                    if (w) begin
                        z_reg <= 1'b1;
                    end else begin
                        z_reg <= 1'b0;
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end
    
    assign z = z_reg;
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 1'b0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w) begin
                        state <= 2'b10; // Move to state C
                    end else begin
                        state <= 2'b00; // Move back to state A
                    end
                end
                2'b10: begin // State C
                    if (w) begin
                        z_reg <= 1'b1;
                    end else begin
                        z_reg <= 1'b0;
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end
    
    assign z = z_reg;
endmodule
"
"
    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check w
                    end else begin
                        state <= 2'b00; // Go back to state A
                    end
                end
                2'b10: begin // Check w
                    if (w == 1) begin
                        state <= 2'b11; // Increment count
                    end else begin
                        state <= 2'b10; // Stay in check state
                    end
                end
                2'b11: begin // Increment count
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b00; // Go back to state A
                end
            endcase
        end
    end
endmodule
",-1.0,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check w
                    end else begin
                        state <= 2'b00; // Go back to state A
                    end
                end
                2'b10: begin // Check w
                    if (w == 1) begin
                        state <= 2'b11; // Increment count
                    end else begin
                        state <= 2'b10; // Stay in check state
                    end
                end
                2'b11: begin // Increment count
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b00; // Go back to state A
                end
            endcase
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check w
                    end else begin
                        state <= 2'b00; // Go back to state A
                    end
                end
                2'b10: begin // Check w
                    if (w == 1) begin
                        state <= 2'b11; // Increment count
                    end else begin
                        state <= 2'b10; // Stay in check state
                    end
                end
                2'b11: begin // Increment count
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b00; // Go back to state A
                end
            endcase
        end
    end
endmodule
"
"  reg [1:0] state;
  reg z_reg;
  
  always @(posedge clk) begin
    if (reset) begin
      state <= 2'b00; // Reset state A
      z_reg <= 1'b0;
    end else begin
      case (state)
        2'b00: begin // State A
          if (s) begin
            state <= 2'b01; // Move to state B
          end
        end
        2'b01: begin // State B
          if (w) begin
            state <= 2'b10; // Move to state C
          end
        end
        2'b10: begin // State C
          if (w) begin
            z_reg <= 1'b1; // Set output z to 1
          end else begin
            z_reg <= 1'b0; // Set output z to 0
          end
          state <= 2'b11; // Move to state D
        end
        2'b11: begin // State D
          state <= 2'b01; // Move back to state B
        end
      endcase
    end
  end
  
  assign z = z_reg;
endmodule
",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
  reg [1:0] state;
  reg z_reg;
  
  always @(posedge clk) begin
    if (reset) begin
      state <= 2'b00; // Reset state A
      z_reg <= 1'b0;
    end else begin
      case (state)
        2'b00: begin // State A
          if (s) begin
            state <= 2'b01; // Move to state B
          end
        end
        2'b01: begin // State B
          if (w) begin
            state <= 2'b10; // Move to state C
          end
        end
        2'b10: begin // State C
          if (w) begin
            z_reg <= 1'b1; // Set output z to 1
          end else begin
            z_reg <= 1'b0; // Set output z to 0
          end
          state <= 2'b11; // Move to state D
        end
        2'b11: begin // State D
          state <= 2'b01; // Move back to state B
        end
      endcase
    end
  end
  
  assign z = z_reg;
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
  reg [1:0] state;
  reg z_reg;
  
  always @(posedge clk) begin
    if (reset) begin
      state <= 2'b00; // Reset state A
      z_reg <= 1'b0;
    end else begin
      case (state)
        2'b00: begin // State A
          if (s) begin
            state <= 2'b01; // Move to state B
          end
        end
        2'b01: begin // State B
          if (w) begin
            state <= 2'b10; // Move to state C
          end
        end
        2'b10: begin // State C
          if (w) begin
            z_reg <= 1'b1; // Set output z to 1
          end else begin
            z_reg <= 1'b0; // Set output z to 0
          end
          state <= 2'b11; // Move to state D
        end
        2'b11: begin // State D
          state <= 2'b01; // Move back to state B
        end
      endcase
    end
  end
  
  assign z = z_reg;
endmodule
"
"    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check w for the next three clock cycles
                    end else begin
                        state <= 2'b11; // Stay in state B
                    end
                end
                2'b10: begin // Transition state for checking w
                    state <= 2'b11;
                end
                2'b11: begin // Check w
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
            endcase
        end
    end
endmodule
",-1.0,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check w for the next three clock cycles
                    end else begin
                        state <= 2'b11; // Stay in state B
                    end
                end
                2'b10: begin // Transition state for checking w
                    state <= 2'b11;
                end
                2'b11: begin // Check w
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
            endcase
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check w for the next three clock cycles
                    end else begin
                        state <= 2'b11; // Stay in state B
                    end
                end
                2'b10: begin // Transition state for checking w
                    state <= 2'b11;
                end
                2'b11: begin // Check w
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
            endcase
        end
    end
endmodule
"
"
    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Move to state C
                    end
                end
                2'b10: begin // State C
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b11; // Move to state D
                end
                2'b11: begin // State D
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Move to state C
                    end
                end
                2'b10: begin // State C
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b11; // Move to state D
                end
                2'b11: begin // State D
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Move to state C
                    end
                end
                2'b10: begin // State C
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b11; // Move to state D
                end
                2'b11: begin // State D
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end

endmodule
"
"
    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 1'b0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w) begin
                        state <= 2'b10; // Move to state C
                    end
                end
                2'b10: begin // State C
                    if (w) begin
                        z_reg <= 1'b1; // Set output z to 1
                    end else begin
                        z_reg <= 1'b0; // Set output z to 0
                    end
                    state <= 2'b11; // Move to state D
                end
                2'b11: begin // State D
                    if (w) begin
                        z_reg <= 1'b0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
            endcase
        end
    end

    assign z = z_reg;

endmodule
",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 1'b0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w) begin
                        state <= 2'b10; // Move to state C
                    end
                end
                2'b10: begin // State C
                    if (w) begin
                        z_reg <= 1'b1; // Set output z to 1
                    end else begin
                        z_reg <= 1'b0; // Set output z to 0
                    end
                    state <= 2'b11; // Move to state D
                end
                2'b11: begin // State D
                    if (w) begin
                        z_reg <= 1'b0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
            endcase
        end
    end

    assign z = z_reg;

endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 1'b0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w) begin
                        state <= 2'b10; // Move to state C
                    end
                end
                2'b10: begin // State C
                    if (w) begin
                        z_reg <= 1'b1; // Set output z to 1
                    end else begin
                        z_reg <= 1'b0; // Set output z to 0
                    end
                    state <= 2'b11; // Move to state D
                end
                2'b11: begin // State D
                    if (w) begin
                        z_reg <= 1'b0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
            endcase
        end
    end

    assign z = z_reg;

endmodule
"
"    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 1'b0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w) begin
                        state <= 2'b10; // Move to state C
                    end
                end
                2'b10: begin // State C
                    if (w) begin
                        state <= 2'b11; // Move to state D
                    end
                end
                2'b11: begin // State D
                    if (w) begin
                        z_reg <= 1'b1; // Set output z to 1
                    end else begin
                        z_reg <= 1'b0; // Set output z to 0
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end
    
    assign z = z_reg;
    
endmodule
",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 1'b0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w) begin
                        state <= 2'b10; // Move to state C
                    end
                end
                2'b10: begin // State C
                    if (w) begin
                        state <= 2'b11; // Move to state D
                    end
                end
                2'b11: begin // State D
                    if (w) begin
                        z_reg <= 1'b1; // Set output z to 1
                    end else begin
                        z_reg <= 1'b0; // Set output z to 0
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end
    
    assign z = z_reg;
    
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;
    reg z_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
            z_reg <= 1'b0;
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w) begin
                        state <= 2'b10; // Move to state C
                    end
                end
                2'b10: begin // State C
                    if (w) begin
                        state <= 2'b11; // Move to state D
                    end
                end
                2'b11: begin // State D
                    if (w) begin
                        z_reg <= 1'b1; // Set output z to 1
                    end else begin
                        z_reg <= 1'b0; // Set output z to 0
                    end
                    state <= 2'b00; // Move back to state A
                end
            endcase
        end
    end
    
    assign z = z_reg;
    
endmodule
"
"    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check next clock cycle
                    end else begin
                        state <= 2'b11; // Transition to check next clock cycle
                    end
                end
                2'b10: begin // Check if w = 1 in exactly two of the next three clock cycles
                    if (w == 1) begin
                        state <= 2'b10; // Stay in state B
                    end else begin
                        state <= 2'b11; // Move to state C
                    end
                end
                2'b11: begin // Set output z based on previous checks
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
                default: state <= 2'b00; // Default to state A
            endcase
        end
    end
endmodule
",-1.0,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check next clock cycle
                    end else begin
                        state <= 2'b11; // Transition to check next clock cycle
                    end
                end
                2'b10: begin // Check if w = 1 in exactly two of the next three clock cycles
                    if (w == 1) begin
                        state <= 2'b10; // Stay in state B
                    end else begin
                        state <= 2'b11; // Move to state C
                    end
                end
                2'b11: begin // Set output z based on previous checks
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
                default: state <= 2'b00; // Default to state A
            endcase
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    reg [1:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00; // Reset state A
        end else begin
            case (state)
                2'b00: begin // State A
                    if (s == 1) begin
                        state <= 2'b01; // Move to state B
                    end
                end
                2'b01: begin // State B
                    if (w == 1) begin
                        state <= 2'b10; // Transition to check next clock cycle
                    end else begin
                        state <= 2'b11; // Transition to check next clock cycle
                    end
                end
                2'b10: begin // Check if w = 1 in exactly two of the next three clock cycles
                    if (w == 1) begin
                        state <= 2'b10; // Stay in state B
                    end else begin
                        state <= 2'b11; // Move to state C
                    end
                end
                2'b11: begin // Set output z based on previous checks
                    if (w == 1) begin
                        z <= 1; // Set output z to 1
                    end else begin
                        z <= 0; // Set output z to 0
                    end
                    state <= 2'b01; // Move back to state B
                end
                default: state <= 2'b00; // Default to state A
            endcase
        end
    end
endmodule
"
"
    wire [3:0] Q;
    
    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[0]));
    MUXDFF mux2 (.D(Q[0]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[1]));
    MUXDFF mux3 (.D(Q[1]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[2]));
    MUXDFF mux4 (.D(Q[2]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[3]));
    
    assign LEDR = Q;
    
endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    wire [3:0] Q;
    
    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[0]));
    MUXDFF mux2 (.D(Q[0]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[1]));
    MUXDFF mux3 (.D(Q[1]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[2]));
    MUXDFF mux4 (.D(Q[2]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[3]));
    
    assign LEDR = Q;
    
endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    wire [3:0] Q;
    
    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[0]));
    MUXDFF mux2 (.D(Q[0]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[1]));
    MUXDFF mux3 (.D(Q[1]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[2]));
    MUXDFF mux4 (.D(Q[2]), .clk(KEY[0]), .E(KEY[1]), .R(SW[1]), .Q(Q[3]));
    
    assign LEDR = Q;
    
endmodule
"
"

    wire [3:0] out_muxdff_0, out_muxdff_1, out_muxdff_2, out_muxdff_3;
    
    MUXDFF muxdff_0 (
        .D(SW[0]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_0)
    );
    
    MUXDFF muxdff_1 (
        .D(out_muxdff_0),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_1)
    );
    
    MUXDFF muxdff_2 (
        .D(out_muxdff_1),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_2)
    );
    
    MUXDFF muxdff_3 (
        .D(out_muxdff_2),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_3)
    );
    
    assign LEDR = {out_muxdff_3, out_muxdff_2, out_muxdff_1, out_muxdff_0};
    
endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] out_muxdff_0, out_muxdff_1, out_muxdff_2, out_muxdff_3;
    
    MUXDFF muxdff_0 (
        .D(SW[0]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_0)
    );
    
    MUXDFF muxdff_1 (
        .D(out_muxdff_0),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_1)
    );
    
    MUXDFF muxdff_2 (
        .D(out_muxdff_1),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_2)
    );
    
    MUXDFF muxdff_3 (
        .D(out_muxdff_2),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_3)
    );
    
    assign LEDR = {out_muxdff_3, out_muxdff_2, out_muxdff_1, out_muxdff_0};
    
endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] out_muxdff_0, out_muxdff_1, out_muxdff_2, out_muxdff_3;
    
    MUXDFF muxdff_0 (
        .D(SW[0]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_0)
    );
    
    MUXDFF muxdff_1 (
        .D(out_muxdff_0),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_1)
    );
    
    MUXDFF muxdff_2 (
        .D(out_muxdff_1),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_2)
    );
    
    MUXDFF muxdff_3 (
        .D(out_muxdff_2),
        .clk(KEY[0]),
        .E(KEY[1]),
        .R(SW[1]),
        .L(KEY[2]),
        .w(KEY[3]),
        .Q(out_muxdff_3)
    );
    
    assign LEDR = {out_muxdff_3, out_muxdff_2, out_muxdff_1, out_muxdff_0};
    
endmodule
"
"

    wire [3:0] Q;
    
    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[0]), .w(KEY[3]));
    MUXDFF mux2 (.D(Q[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[1]), .w(KEY[3]));
    MUXDFF mux3 (.D(Q[1]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[2]), .w(KEY[3]));
    MUXDFF mux4 (.D(Q[2]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[3]), .w(KEY[3]));
    
    assign LEDR = Q;
    
endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] Q;
    
    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[0]), .w(KEY[3]));
    MUXDFF mux2 (.D(Q[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[1]), .w(KEY[3]));
    MUXDFF mux3 (.D(Q[1]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[2]), .w(KEY[3]));
    MUXDFF mux4 (.D(Q[2]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[3]), .w(KEY[3]));
    
    assign LEDR = Q;
    
endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] Q;
    
    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[0]), .w(KEY[3]));
    MUXDFF mux2 (.D(Q[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[1]), .w(KEY[3]));
    MUXDFF mux3 (.D(Q[1]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[2]), .w(KEY[3]));
    MUXDFF mux4 (.D(Q[2]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[3]), .w(KEY[3]));
    
    assign LEDR = Q;
    
endmodule
"
"

    wire [3:0] Q;
    
    MUXDFF mux1 (
        .D(Q[0]),
        .R(SW[0]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    MUXDFF mux2 (
        .D(Q[1]),
        .R(SW[1]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    MUXDFF mux3 (
        .D(Q[2]),
        .R(SW[2]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    MUXDFF mux4 (
        .D(Q[3]),
        .R(SW[3]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    assign LEDR = Q;
    
endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] Q;
    
    MUXDFF mux1 (
        .D(Q[0]),
        .R(SW[0]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    MUXDFF mux2 (
        .D(Q[1]),
        .R(SW[1]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    MUXDFF mux3 (
        .D(Q[2]),
        .R(SW[2]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    MUXDFF mux4 (
        .D(Q[3]),
        .R(SW[3]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    assign LEDR = Q;
    
endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] Q;
    
    MUXDFF mux1 (
        .D(Q[0]),
        .R(SW[0]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    MUXDFF mux2 (
        .D(Q[1]),
        .R(SW[1]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    MUXDFF mux3 (
        .D(Q[2]),
        .R(SW[2]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    MUXDFF mux4 (
        .D(Q[3]),
        .R(SW[3]),
        .clk(KEY[0]),
        .E(KEY[1]),
        .L(KEY[2]),
        .w(KEY[3])
    );
    
    assign LEDR = Q;
    
endmodule
"
"

    wire [3:0] Q;

    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[0]), .Q(LEDR[0]));
    MUXDFF mux2 (.D(Q[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[1]), .Q(LEDR[1]));
    MUXDFF mux3 (.D(Q[1]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[2]), .Q(LEDR[2]));
    MUXDFF mux4 (.D(Q[2]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[3]), .Q(LEDR[3]));

endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] Q;

    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[0]), .Q(LEDR[0]));
    MUXDFF mux2 (.D(Q[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[1]), .Q(LEDR[1]));
    MUXDFF mux3 (.D(Q[1]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[2]), .Q(LEDR[2]));
    MUXDFF mux4 (.D(Q[2]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[3]), .Q(LEDR[3]));

endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] Q;

    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[0]), .Q(LEDR[0]));
    MUXDFF mux2 (.D(Q[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[1]), .Q(LEDR[1]));
    MUXDFF mux3 (.D(Q[1]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[2]), .Q(LEDR[2]));
    MUXDFF mux4 (.D(Q[2]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(Q[3]), .Q(LEDR[3]));

endmodule
"
"

  wire [3:0] out1, out2, out3, out4;
  
  MUXDFF mux1(SW[0], KEY[0], KEY[1], KEY[2], KEY[3], out1);
  MUXDFF mux2(SW[1], KEY[0], KEY[1], KEY[2], KEY[3], out2);
  MUXDFF mux3(SW[2], KEY[0], KEY[1], KEY[2], KEY[3], out3);
  MUXDFF mux4(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], out4);
  
  assign LEDR = {out4, out3, out2, out1};
  
endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


  wire [3:0] out1, out2, out3, out4;
  
  MUXDFF mux1(SW[0], KEY[0], KEY[1], KEY[2], KEY[3], out1);
  MUXDFF mux2(SW[1], KEY[0], KEY[1], KEY[2], KEY[3], out2);
  MUXDFF mux3(SW[2], KEY[0], KEY[1], KEY[2], KEY[3], out3);
  MUXDFF mux4(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], out4);
  
  assign LEDR = {out4, out3, out2, out1};
  
endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


  wire [3:0] out1, out2, out3, out4;
  
  MUXDFF mux1(SW[0], KEY[0], KEY[1], KEY[2], KEY[3], out1);
  MUXDFF mux2(SW[1], KEY[0], KEY[1], KEY[2], KEY[3], out2);
  MUXDFF mux3(SW[2], KEY[0], KEY[1], KEY[2], KEY[3], out3);
  MUXDFF mux4(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], out4);
  
  assign LEDR = {out4, out3, out2, out1};
  
endmodule
"
"

wire [3:0] out1, out2, out3, out4;

MUXDFF dff1(SW[0], KEY[0], KEY[1], KEY[2], KEY[3], out1);
MUXDFF dff2(SW[1], KEY[0], KEY[1], KEY[2], KEY[3], out2);
MUXDFF dff3(SW[2], KEY[0], KEY[1], KEY[2], KEY[3], out3);
MUXDFF dff4(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], out4);

assign LEDR = {out4, out3, out2, out1};

endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


wire [3:0] out1, out2, out3, out4;

MUXDFF dff1(SW[0], KEY[0], KEY[1], KEY[2], KEY[3], out1);
MUXDFF dff2(SW[1], KEY[0], KEY[1], KEY[2], KEY[3], out2);
MUXDFF dff3(SW[2], KEY[0], KEY[1], KEY[2], KEY[3], out3);
MUXDFF dff4(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], out4);

assign LEDR = {out4, out3, out2, out1};

endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


wire [3:0] out1, out2, out3, out4;

MUXDFF dff1(SW[0], KEY[0], KEY[1], KEY[2], KEY[3], out1);
MUXDFF dff2(SW[1], KEY[0], KEY[1], KEY[2], KEY[3], out2);
MUXDFF dff3(SW[2], KEY[0], KEY[1], KEY[2], KEY[3], out3);
MUXDFF dff4(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], out4);

assign LEDR = {out4, out3, out2, out1};

endmodule
"
"

    wire [3:0] q;
    
    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[0]), .w(KEY[3]));
    MUXDFF mux2 (.D(q[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[1]), .w(KEY[3]));
    MUXDFF mux3 (.D(q[1]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[2]), .w(KEY[3]));
    MUXDFF mux4 (.D(q[2]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[3]), .w(KEY[3]));
    
    assign LEDR = q;
    
endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] q;
    
    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[0]), .w(KEY[3]));
    MUXDFF mux2 (.D(q[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[1]), .w(KEY[3]));
    MUXDFF mux3 (.D(q[1]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[2]), .w(KEY[3]));
    MUXDFF mux4 (.D(q[2]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[3]), .w(KEY[3]));
    
    assign LEDR = q;
    
endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] q;
    
    MUXDFF mux1 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[0]), .w(KEY[3]));
    MUXDFF mux2 (.D(q[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[1]), .w(KEY[3]));
    MUXDFF mux3 (.D(q[1]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[2]), .w(KEY[3]));
    MUXDFF mux4 (.D(q[2]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .R(q[3]), .w(KEY[3]));
    
    assign LEDR = q;
    
endmodule
"
"

    wire [3:0] out_muxdff_0, out_muxdff_1, out_muxdff_2, out_muxdff_3;
    
    MUXDFF muxdff_0 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_0));
    MUXDFF muxdff_1 (.D(out_muxdff_0), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_1));
    MUXDFF muxdff_2 (.D(out_muxdff_1), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_2));
    MUXDFF muxdff_3 (.D(out_muxdff_2), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_3));
    
    assign LEDR = out_muxdff_3;
    
endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] out_muxdff_0, out_muxdff_1, out_muxdff_2, out_muxdff_3;
    
    MUXDFF muxdff_0 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_0));
    MUXDFF muxdff_1 (.D(out_muxdff_0), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_1));
    MUXDFF muxdff_2 (.D(out_muxdff_1), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_2));
    MUXDFF muxdff_3 (.D(out_muxdff_2), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_3));
    
    assign LEDR = out_muxdff_3;
    
endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] out_muxdff_0, out_muxdff_1, out_muxdff_2, out_muxdff_3;
    
    MUXDFF muxdff_0 (.D(SW[0]), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_0));
    MUXDFF muxdff_1 (.D(out_muxdff_0), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_1));
    MUXDFF muxdff_2 (.D(out_muxdff_1), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_2));
    MUXDFF muxdff_3 (.D(out_muxdff_2), .clk(KEY[0]), .E(KEY[1]), .L(KEY[2]), .w(KEY[3]), .Q(out_muxdff_3));
    
    assign LEDR = out_muxdff_3;
    
endmodule
"
"

    wire [3:0] Q;
    wire [3:0] D;
    
    MUXDFF muxdff1(SW[0], KEY[0], KEY[1], KEY[2], KEY[3], Q[0], D[0]);
    MUXDFF muxdff2(SW[1], KEY[0], KEY[1], KEY[2], KEY[3], Q[1], D[1]);
    MUXDFF muxdff3(SW[2], KEY[0], KEY[1], KEY[2], KEY[3], Q[2], D[2]);
    MUXDFF muxdff4(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], Q[3], D[3]);
    
    assign LEDR = Q;
    
endmodule
",-1.0,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] Q;
    wire [3:0] D;
    
    MUXDFF muxdff1(SW[0], KEY[0], KEY[1], KEY[2], KEY[3], Q[0], D[0]);
    MUXDFF muxdff2(SW[1], KEY[0], KEY[1], KEY[2], KEY[3], Q[1], D[1]);
    MUXDFF muxdff3(SW[2], KEY[0], KEY[1], KEY[2], KEY[3], Q[2], D[2]);
    MUXDFF muxdff4(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], Q[3], D[3]);
    
    assign LEDR = Q;
    
endmodule
","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //


    wire [3:0] Q;
    wire [3:0] D;
    
    MUXDFF muxdff1(SW[0], KEY[0], KEY[1], KEY[2], KEY[3], Q[0], D[0]);
    MUXDFF muxdff2(SW[1], KEY[0], KEY[1], KEY[2], KEY[3], Q[1], D[1]);
    MUXDFF muxdff3(SW[2], KEY[0], KEY[1], KEY[2], KEY[3], Q[2], D[2]);
    MUXDFF muxdff4(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], Q[3], D[3]);
    
    assign LEDR = Q;
    
endmodule
"
"// Define the D flip-flop module
module d_flip_flop (
    input clk,
    input reset,
    input D,
    output reg Q
);

always @(posedge clk) begin
    if (reset) begin
        Q <= 1'b0;
    end else begin
        Q <= D;
    end
end

endmodule
",-1.0,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );
// Define the D flip-flop module
module d_flip_flop (
    input clk,
    input reset,
    input D,
    output reg Q
);

always @(posedge clk) begin
    if (reset) begin
        Q <= 1'b0;
    end else begin
        Q <= D;
    end
end

endmodule
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );
// Define the D flip-flop module
module d_flip_flop (
    input clk,
    input reset,
    input D,
    output reg Q
);

always @(posedge clk) begin
    if (reset) begin
        Q <= 1'b0;
    end else begin
        Q <= D;
    end
end

endmodule
"
"
    reg [7:0] Q;
    reg [2:0] address;
    
    // 8-bit shift register
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    // 3-input LUT
    always @* begin
        case ({A, B, C})
            3'b000: address = 3'b000;
            3'b001: address = 3'b001;
            3'b010: address = 3'b010;
            3'b011: address = 3'b011;
            3'b100: address = 3'b100;
            3'b101: address = 3'b101;
            3'b110: address = 3'b110;
            3'b111: address = 3'b111;
        endcase
        
        case (address)
            3'b000: Z = Q[0];
            3'b001: Z = Q[1];
            3'b010: Z = Q[2];
            3'b011: Z = Q[3];
            3'b100: Z = Q[4];
            3'b101: Z = Q[5];
            3'b110: Z = Q[6];
            3'b111: Z = Q[7];
        endcase
    end
endmodule
",-1.0,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] address;
    
    // 8-bit shift register
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    // 3-input LUT
    always @* begin
        case ({A, B, C})
            3'b000: address = 3'b000;
            3'b001: address = 3'b001;
            3'b010: address = 3'b010;
            3'b011: address = 3'b011;
            3'b100: address = 3'b100;
            3'b101: address = 3'b101;
            3'b110: address = 3'b110;
            3'b111: address = 3'b111;
        endcase
        
        case (address)
            3'b000: Z = Q[0];
            3'b001: Z = Q[1];
            3'b010: Z = Q[2];
            3'b011: Z = Q[3];
            3'b100: Z = Q[4];
            3'b101: Z = Q[5];
            3'b110: Z = Q[6];
            3'b111: Z = Q[7];
        endcase
    end
endmodule
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] address;
    
    // 8-bit shift register
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    // 3-input LUT
    always @* begin
        case ({A, B, C})
            3'b000: address = 3'b000;
            3'b001: address = 3'b001;
            3'b010: address = 3'b010;
            3'b011: address = 3'b011;
            3'b100: address = 3'b100;
            3'b101: address = 3'b101;
            3'b110: address = 3'b110;
            3'b111: address = 3'b111;
        endcase
        
        case (address)
            3'b000: Z = Q[0];
            3'b001: Z = Q[1];
            3'b010: Z = Q[2];
            3'b011: Z = Q[3];
            3'b100: Z = Q[4];
            3'b101: Z = Q[5];
            3'b110: Z = Q[6];
            3'b111: Z = Q[7];
        endcase
    end
endmodule
"
"// Define 8 D-type flip-flops for the shift register
DFF dff0 ( .clk(clk), .d(S), .q(Q0) );
DFF dff1 ( .clk(clk), .d(Q0), .q(Q1) );
DFF dff2 ( .clk(clk), .d(Q1), .q(Q2) );
DFF dff3 ( .clk(clk), .d(Q2), .q(Q3) );
DFF dff4 ( .clk(clk), .d(Q3), .q(Q4) );
DFF dff5 ( .clk(clk), .d(Q4), .q(Q5) );
DFF dff6 ( .clk(clk), .d(Q5), .q(Q6) );
DFF dff7 ( .clk(clk), .d(Q6), .q(Q7) );

// Define 3-to-8 decoder for selecting the output based on ABC inputs
decoder dec ( .A(A), .B(B), .C(C), .Y(Y) );

// Define 8-to-1 multiplexer for selecting the output based on decoder output
mux_8to1 mux ( .A(Q0), .B(Q1), .C(Q2), .D(Q3), .E(Q4), .F(Q5), .G(Q6), .H(Q7), .S(Y), .Z(Z) );
",-1.0,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );
// Define 8 D-type flip-flops for the shift register
DFF dff0 ( .clk(clk), .d(S), .q(Q0) );
DFF dff1 ( .clk(clk), .d(Q0), .q(Q1) );
DFF dff2 ( .clk(clk), .d(Q1), .q(Q2) );
DFF dff3 ( .clk(clk), .d(Q2), .q(Q3) );
DFF dff4 ( .clk(clk), .d(Q3), .q(Q4) );
DFF dff5 ( .clk(clk), .d(Q4), .q(Q5) );
DFF dff6 ( .clk(clk), .d(Q5), .q(Q6) );
DFF dff7 ( .clk(clk), .d(Q6), .q(Q7) );

// Define 3-to-8 decoder for selecting the output based on ABC inputs
decoder dec ( .A(A), .B(B), .C(C), .Y(Y) );

// Define 8-to-1 multiplexer for selecting the output based on decoder output
mux_8to1 mux ( .A(Q0), .B(Q1), .C(Q2), .D(Q3), .E(Q4), .F(Q5), .G(Q6), .H(Q7), .S(Y), .Z(Z) );
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );
// Define 8 D-type flip-flops for the shift register
DFF dff0 ( .clk(clk), .d(S), .q(Q0) );
DFF dff1 ( .clk(clk), .d(Q0), .q(Q1) );
DFF dff2 ( .clk(clk), .d(Q1), .q(Q2) );
DFF dff3 ( .clk(clk), .d(Q2), .q(Q3) );
DFF dff4 ( .clk(clk), .d(Q3), .q(Q4) );
DFF dff5 ( .clk(clk), .d(Q4), .q(Q5) );
DFF dff6 ( .clk(clk), .d(Q5), .q(Q6) );
DFF dff7 ( .clk(clk), .d(Q6), .q(Q7) );

// Define 3-to-8 decoder for selecting the output based on ABC inputs
decoder dec ( .A(A), .B(B), .C(C), .Y(Y) );

// Define 8-to-1 multiplexer for selecting the output based on decoder output
mux_8to1 mux ( .A(Q0), .B(Q1), .C(Q2), .D(Q3), .E(Q4), .F(Q5), .G(Q6), .H(Q7), .S(Y), .Z(Z) );
"
"
    reg [7:0] Q;
    reg [2:0] select;

    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end

    always @* begin
        case ({A, B, C})
            3'b000: select = 3'b000;
            3'b001: select = 3'b001;
            3'b010: select = 3'b010;
            3'b011: select = 3'b011;
            3'b100: select = 3'b100;
            3'b101: select = 3'b101;
            3'b110: select = 3'b110;
            3'b111: select = 3'b111;
        endcase
    end

    assign Z = Q[select];

endmodule
",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] select;

    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end

    always @* begin
        case ({A, B, C})
            3'b000: select = 3'b000;
            3'b001: select = 3'b001;
            3'b010: select = 3'b010;
            3'b011: select = 3'b011;
            3'b100: select = 3'b100;
            3'b101: select = 3'b101;
            3'b110: select = 3'b110;
            3'b111: select = 3'b111;
        endcase
    end

    assign Z = Q[select];

endmodule
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] select;

    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end

    always @* begin
        case ({A, B, C})
            3'b000: select = 3'b000;
            3'b001: select = 3'b001;
            3'b010: select = 3'b010;
            3'b011: select = 3'b011;
            3'b100: select = 3'b100;
            3'b101: select = 3'b101;
            3'b110: select = 3'b110;
            3'b111: select = 3'b111;
        endcase
    end

    assign Z = Q[select];

endmodule
"
"
    reg [7:0] Q;
    reg [2:0] address;
    
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    always @(*) begin
        case ({A, B, C})
            3'b000: address = 3'b000;
            3'b001: address = 3'b001;
            3'b010: address = 3'b010;
            3'b011: address = 3'b011;
            3'b100: address = 3'b100;
            3'b101: address = 3'b101;
            3'b110: address = 3'b110;
            3'b111: address = 3'b111;
        endcase
    end
    
    assign Z = Q[address];
    
endmodule
",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] address;
    
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    always @(*) begin
        case ({A, B, C})
            3'b000: address = 3'b000;
            3'b001: address = 3'b001;
            3'b010: address = 3'b010;
            3'b011: address = 3'b011;
            3'b100: address = 3'b100;
            3'b101: address = 3'b101;
            3'b110: address = 3'b110;
            3'b111: address = 3'b111;
        endcase
    end
    
    assign Z = Q[address];
    
endmodule
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] address;
    
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    always @(*) begin
        case ({A, B, C})
            3'b000: address = 3'b000;
            3'b001: address = 3'b001;
            3'b010: address = 3'b010;
            3'b011: address = 3'b011;
            3'b100: address = 3'b100;
            3'b101: address = 3'b101;
            3'b110: address = 3'b110;
            3'b111: address = 3'b111;
        endcase
    end
    
    assign Z = Q[address];
    
endmodule
"
"
    reg [7:0] Q;
    reg [2:0] select;
    
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    always @* begin
        case ({A, B, C})
            3'b000: select = 3'b000;
            3'b001: select = 3'b001;
            3'b010: select = 3'b010;
            3'b011: select = 3'b011;
            3'b100: select = 3'b100;
            3'b101: select = 3'b101;
            3'b110: select = 3'b110;
            3'b111: select = 3'b111;
        endcase
    end
    
    assign Z = Q[select];
    
endmodule
",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] select;
    
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    always @* begin
        case ({A, B, C})
            3'b000: select = 3'b000;
            3'b001: select = 3'b001;
            3'b010: select = 3'b010;
            3'b011: select = 3'b011;
            3'b100: select = 3'b100;
            3'b101: select = 3'b101;
            3'b110: select = 3'b110;
            3'b111: select = 3'b111;
        endcase
    end
    
    assign Z = Q[select];
    
endmodule
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] select;
    
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    always @* begin
        case ({A, B, C})
            3'b000: select = 3'b000;
            3'b001: select = 3'b001;
            3'b010: select = 3'b010;
            3'b011: select = 3'b011;
            3'b100: select = 3'b100;
            3'b101: select = 3'b101;
            3'b110: select = 3'b110;
            3'b111: select = 3'b111;
        endcase
    end
    
    assign Z = Q[select];
    
endmodule
"
"
    reg [7:0] Q;
    reg [2:0] address;

    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end

    always @* begin
        case ({A, B, C})
            3'b000: address = 3'b000;
            3'b001: address = 3'b001;
            3'b010: address = 3'b010;
            3'b011: address = 3'b011;
            3'b100: address = 3'b100;
            3'b101: address = 3'b101;
            3'b110: address = 3'b110;
            3'b111: address = 3'b111;
        endcase

        case (address)
            3'b000: Z = Q[0];
            3'b001: Z = Q[1];
            3'b010: Z = Q[2];
            3'b011: Z = Q[3];
            3'b100: Z = Q[4];
            3'b101: Z = Q[5];
            3'b110: Z = Q[6];
            3'b111: Z = Q[7];
        endcase
    end
endmodule
",-1.0,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] address;

    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end

    always @* begin
        case ({A, B, C})
            3'b000: address = 3'b000;
            3'b001: address = 3'b001;
            3'b010: address = 3'b010;
            3'b011: address = 3'b011;
            3'b100: address = 3'b100;
            3'b101: address = 3'b101;
            3'b110: address = 3'b110;
            3'b111: address = 3'b111;
        endcase

        case (address)
            3'b000: Z = Q[0];
            3'b001: Z = Q[1];
            3'b010: Z = Q[2];
            3'b011: Z = Q[3];
            3'b100: Z = Q[4];
            3'b101: Z = Q[5];
            3'b110: Z = Q[6];
            3'b111: Z = Q[7];
        endcase
    end
endmodule
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] address;

    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end

    always @* begin
        case ({A, B, C})
            3'b000: address = 3'b000;
            3'b001: address = 3'b001;
            3'b010: address = 3'b010;
            3'b011: address = 3'b011;
            3'b100: address = 3'b100;
            3'b101: address = 3'b101;
            3'b110: address = 3'b110;
            3'b111: address = 3'b111;
        endcase

        case (address)
            3'b000: Z = Q[0];
            3'b001: Z = Q[1];
            3'b010: Z = Q[2];
            3'b011: Z = Q[3];
            3'b100: Z = Q[4];
            3'b101: Z = Q[5];
            3'b110: Z = Q[6];
            3'b111: Z = Q[7];
        endcase
    end
endmodule
"
"
    reg [7:0] Q;
    reg [2:0] index;

    always @(posedge clk) begin
        if (enable) begin
            // Shift register logic
            Q <= {Q[6:0], S};
        end

        // Multiplexer logic
        case ({A, B, C})
            3'b000: index <= 3'b000;
            3'b001: index <= 3'b001;
            3'b010: index <= 3'b010;
            3'b011: index <= 3'b011;
            3'b100: index <= 3'b100;
            3'b101: index <= 3'b101;
            3'b110: index <= 3'b110;
            3'b111: index <= 3'b111;
        endcase
    end

    assign Z = Q[index];
endmodule
",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] index;

    always @(posedge clk) begin
        if (enable) begin
            // Shift register logic
            Q <= {Q[6:0], S};
        end

        // Multiplexer logic
        case ({A, B, C})
            3'b000: index <= 3'b000;
            3'b001: index <= 3'b001;
            3'b010: index <= 3'b010;
            3'b011: index <= 3'b011;
            3'b100: index <= 3'b100;
            3'b101: index <= 3'b101;
            3'b110: index <= 3'b110;
            3'b111: index <= 3'b111;
        endcase
    end

    assign Z = Q[index];
endmodule
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    reg [2:0] index;

    always @(posedge clk) begin
        if (enable) begin
            // Shift register logic
            Q <= {Q[6:0], S};
        end

        // Multiplexer logic
        case ({A, B, C})
            3'b000: index <= 3'b000;
            3'b001: index <= 3'b001;
            3'b010: index <= 3'b010;
            3'b011: index <= 3'b011;
            3'b100: index <= 3'b100;
            3'b101: index <= 3'b101;
            3'b110: index <= 3'b110;
            3'b111: index <= 3'b111;
        endcase
    end

    assign Z = Q[index];
endmodule
"
"
    reg [7:0] Q;
    
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    assign Z = (A & ~B & ~C) ? Q[0] :
               (~A & B & ~C) ? Q[1] :
               (A & B & ~C) ? Q[2] :
               (~A & ~B & C) ? Q[3] :
               (A & ~B & C) ? Q[4] :
               (~A & B & C) ? Q[5] :
               (A & B & C) ? Q[6] :
               Q[7];
    
endmodule
",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    assign Z = (A & ~B & ~C) ? Q[0] :
               (~A & B & ~C) ? Q[1] :
               (A & B & ~C) ? Q[2] :
               (~A & ~B & C) ? Q[3] :
               (A & ~B & C) ? Q[4] :
               (~A & B & C) ? Q[5] :
               (A & B & C) ? Q[6] :
               Q[7];
    
endmodule
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );

    reg [7:0] Q;
    
    always @(posedge clk) begin
        if (enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    assign Z = (A & ~B & ~C) ? Q[0] :
               (~A & B & ~C) ? Q[1] :
               (A & B & ~C) ? Q[2] :
               (~A & ~B & C) ? Q[3] :
               (A & ~B & C) ? Q[4] :
               (~A & B & C) ? Q[5] :
               (A & B & C) ? Q[6] :
               Q[7];
    
endmodule
"
"// Define the D-type flip-flop module
module d_flip_flop (
    input clk,
    input enable,
    input D,
    output reg Q
);
    always @(posedge clk) begin
        if (enable) begin
            Q <= D;
        end
    end
endmodule
",-1.0,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );
// Define the D-type flip-flop module
module d_flip_flop (
    input clk,
    input enable,
    input D,
    output reg Q
);
    always @(posedge clk) begin
        if (enable) begin
            Q <= D;
        end
    end
endmodule
","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );
// Define the D-type flip-flop module
module d_flip_flop (
    input clk,
    input enable,
    input D,
    output reg Q
);
    always @(posedge clk) begin
        if (enable) begin
            Q <= D;
        end
    end
endmodule
"
"    assign out_sop = (~a & ~b & c & d) | (a & ~b & ~c & ~d) | (~a & b & ~c & ~d);
    assign out_pos = (a + b + ~c + ~d) * (~a + b + c + d) * (a + ~b + c + d);
endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    assign out_sop = (~a & ~b & c & d) | (a & ~b & ~c & ~d) | (~a & b & ~c & ~d);
    assign out_pos = (a + b + ~c + ~d) * (~a + b + c + d) * (a + ~b + c + d);
endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    assign out_sop = (~a & ~b & c & d) | (a & ~b & ~c & ~d) | (~a & b & ~c & ~d);
    assign out_pos = (a + b + ~c + ~d) * (~a + b + c + d) * (a + ~b + c + d);
endmodule
"
"    assign out_sop = ~(a & b & ~c & d) & ~(~a & b & c & d) & ~(a & ~b & c & d);
    assign out_pos = (a | b | ~c | d) & (~a | b | c | d) & (a | ~b | c | d);
endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    assign out_sop = ~(a & b & ~c & d) & ~(~a & b & c & d) & ~(a & ~b & c & d);
    assign out_pos = (a | b | ~c | d) & (~a | b | c | d) & (a | ~b | c | d);
endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    assign out_sop = ~(a & b & ~c & d) & ~(~a & b & c & d) & ~(a & ~b & c & d);
    assign out_pos = (a | b | ~c | d) & (~a | b | c | d) & (a | ~b | c | d);
endmodule
"
"    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;

    assign w1 = !(a | b | c | d); // 0
    assign w2 = !(a & !b & !c & !d); // 1
    assign w3 = !(a & !b & c & !d); // 4
    assign w4 = !(a & !b & !c & d); // 5
    assign w5 = !(a & b & !c & !d); // 6
    assign w6 = !(a & b & c & d); // 9
    assign w7 = !(a & b & !c & d); // 10
    assign w8 = !(a & b & c & !d); // 13
    assign w9 = !(a & b & c & d); // 14
    assign w10 = !(a & !b & c & d); // 2
    assign w11 = !(a & b & c & d); // 7
    assign w12 = !(a & b & c & d); // 15

    assign out_sop = w10 | w11 | w12;
    assign out_pos = w1 & w2 & w3 & w4 & w5 & w6 & w7 & w8 & w9;
endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;

    assign w1 = !(a | b | c | d); // 0
    assign w2 = !(a & !b & !c & !d); // 1
    assign w3 = !(a & !b & c & !d); // 4
    assign w4 = !(a & !b & !c & d); // 5
    assign w5 = !(a & b & !c & !d); // 6
    assign w6 = !(a & b & c & d); // 9
    assign w7 = !(a & b & !c & d); // 10
    assign w8 = !(a & b & c & !d); // 13
    assign w9 = !(a & b & c & d); // 14
    assign w10 = !(a & !b & c & d); // 2
    assign w11 = !(a & b & c & d); // 7
    assign w12 = !(a & b & c & d); // 15

    assign out_sop = w10 | w11 | w12;
    assign out_pos = w1 & w2 & w3 & w4 & w5 & w6 & w7 & w8 & w9;
endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;

    assign w1 = !(a | b | c | d); // 0
    assign w2 = !(a & !b & !c & !d); // 1
    assign w3 = !(a & !b & c & !d); // 4
    assign w4 = !(a & !b & !c & d); // 5
    assign w5 = !(a & b & !c & !d); // 6
    assign w6 = !(a & b & c & d); // 9
    assign w7 = !(a & b & !c & d); // 10
    assign w8 = !(a & b & c & !d); // 13
    assign w9 = !(a & b & c & d); // 14
    assign w10 = !(a & !b & c & d); // 2
    assign w11 = !(a & b & c & d); // 7
    assign w12 = !(a & b & c & d); // 15

    assign out_sop = w10 | w11 | w12;
    assign out_pos = w1 & w2 & w3 & w4 & w5 & w6 & w7 & w8 & w9;
endmodule
"
"
    assign out_sop = (~a & ~b & c & d) | (a & ~b & ~c & ~d) | (a & b & c & d);
    assign out_pos = (a | b | ~c | ~d) & (~a | b | c | d) & (~a | ~b | ~c | ~d);
endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (~a & ~b & c & d) | (a & ~b & ~c & ~d) | (a & b & c & d);
    assign out_pos = (a | b | ~c | ~d) & (~a | b | c | d) & (~a | ~b | ~c | ~d);
endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (~a & ~b & c & d) | (a & ~b & ~c & ~d) | (a & b & c & d);
    assign out_pos = (a | b | ~c | ~d) & (~a | b | c | d) & (~a | ~b | ~c | ~d);
endmodule
"
"    // Define the truth table for the given conditions
    // 2, 7, 15 -> output 1
    // 0, 1, 4, 5, 6, 9, 10, 13, 14 -> output 0
    // 3, 8, 11, 12 -> output undefined

    // Output in minimum SOP form
    assign out_sop = (~a & ~b & c & d) | (~a & b & ~c & d) | (a & ~b & ~c & d);

    // Output in minimum POS form
    assign out_pos = (a | b | ~c | d) & (a | ~b | c | d) & (~a | b | c | d);

endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    // Define the truth table for the given conditions
    // 2, 7, 15 -> output 1
    // 0, 1, 4, 5, 6, 9, 10, 13, 14 -> output 0
    // 3, 8, 11, 12 -> output undefined

    // Output in minimum SOP form
    assign out_sop = (~a & ~b & c & d) | (~a & b & ~c & d) | (a & ~b & ~c & d);

    // Output in minimum POS form
    assign out_pos = (a | b | ~c | d) & (a | ~b | c | d) & (~a | b | c | d);

endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    // Define the truth table for the given conditions
    // 2, 7, 15 -> output 1
    // 0, 1, 4, 5, 6, 9, 10, 13, 14 -> output 0
    // 3, 8, 11, 12 -> output undefined

    // Output in minimum SOP form
    assign out_sop = (~a & ~b & c & d) | (~a & b & ~c & d) | (a & ~b & ~c & d);

    // Output in minimum POS form
    assign out_pos = (a | b | ~c | d) & (a | ~b | c | d) & (~a | b | c | d);

endmodule
"
"    // SOP form
    assign out_sop = (~a & ~b & c & d) | (~a & ~b & ~c & d) | (a & ~b & c & ~d);
    
    // POS form
    assign out_pos = (a | b | ~c | d) & (a | b | c | ~d) & (~a | b | ~c | ~d); 

endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    // SOP form
    assign out_sop = (~a & ~b & c & d) | (~a & ~b & ~c & d) | (a & ~b & c & ~d);
    
    // POS form
    assign out_pos = (a | b | ~c | d) & (a | b | c | ~d) & (~a | b | ~c | ~d); 

endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    // SOP form
    assign out_sop = (~a & ~b & c & d) | (~a & ~b & ~c & d) | (a & ~b & c & ~d);
    
    // POS form
    assign out_pos = (a | b | ~c | d) & (a | b | c | ~d) & (~a | b | ~c | ~d); 

endmodule
"
"    assign out_sop = (~a & ~b & c & d) | (a & ~b & ~c & ~d) | (~a & b & ~c & ~d);
    assign out_pos = (a | b | ~c | ~d) & (~a | b | c | d) & (a | ~b | c | d);
endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    assign out_sop = (~a & ~b & c & d) | (a & ~b & ~c & ~d) | (~a & b & ~c & ~d);
    assign out_pos = (a | b | ~c | ~d) & (~a | b | c | d) & (a | ~b | c | d);
endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    assign out_sop = (~a & ~b & c & d) | (a & ~b & ~c & ~d) | (~a & b & ~c & ~d);
    assign out_pos = (a | b | ~c | ~d) & (~a | b | c | d) & (a | ~b | c | d);
endmodule
"
"
    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
    
    assign w1 = a & b & c & d; // 15
    assign w2 = ~a & ~b & ~c & ~d; // 0
    assign w3 = ~a & b & ~c & ~d; // 1
    assign w4 = a & ~b & ~c & ~d; // 4
    assign w5 = ~a & ~b & c & ~d; // 5
    assign w6 = ~a & b & c & ~d; // 6
    assign w7 = a & ~b & c & ~d; // 9
    assign w8 = ~a & ~b & ~c & d; // 10
    assign w9 = a & b & ~c & ~d; // 13
    assign w10 = ~a & b & c & d; // 2
    assign w11 = a & ~b & c & d; // 7
    assign w12 = a & b & ~c & d; // 15
    assign w13 = a & ~b & ~c & d; // 11
    assign w14 = ~a & b & ~c & d; // 12
    assign w15 = a & b & c & ~d; // 14
    
    assign out_sop = w1 | w10 | w11 | w12;
    assign out_pos = w2 & w3 & w4 & w5 & w6 & w7 & w8 & w9 & w13 & w14 & w15;
endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
    
    assign w1 = a & b & c & d; // 15
    assign w2 = ~a & ~b & ~c & ~d; // 0
    assign w3 = ~a & b & ~c & ~d; // 1
    assign w4 = a & ~b & ~c & ~d; // 4
    assign w5 = ~a & ~b & c & ~d; // 5
    assign w6 = ~a & b & c & ~d; // 6
    assign w7 = a & ~b & c & ~d; // 9
    assign w8 = ~a & ~b & ~c & d; // 10
    assign w9 = a & b & ~c & ~d; // 13
    assign w10 = ~a & b & c & d; // 2
    assign w11 = a & ~b & c & d; // 7
    assign w12 = a & b & ~c & d; // 15
    assign w13 = a & ~b & ~c & d; // 11
    assign w14 = ~a & b & ~c & d; // 12
    assign w15 = a & b & c & ~d; // 14
    
    assign out_sop = w1 | w10 | w11 | w12;
    assign out_pos = w2 & w3 & w4 & w5 & w6 & w7 & w8 & w9 & w13 & w14 & w15;
endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
    
    assign w1 = a & b & c & d; // 15
    assign w2 = ~a & ~b & ~c & ~d; // 0
    assign w3 = ~a & b & ~c & ~d; // 1
    assign w4 = a & ~b & ~c & ~d; // 4
    assign w5 = ~a & ~b & c & ~d; // 5
    assign w6 = ~a & b & c & ~d; // 6
    assign w7 = a & ~b & c & ~d; // 9
    assign w8 = ~a & ~b & ~c & d; // 10
    assign w9 = a & b & ~c & ~d; // 13
    assign w10 = ~a & b & c & d; // 2
    assign w11 = a & ~b & c & d; // 7
    assign w12 = a & b & ~c & d; // 15
    assign w13 = a & ~b & ~c & d; // 11
    assign w14 = ~a & b & ~c & d; // 12
    assign w15 = a & b & c & ~d; // 14
    
    assign out_sop = w1 | w10 | w11 | w12;
    assign out_pos = w2 & w3 & w4 & w5 & w6 & w7 & w8 & w9 & w13 & w14 & w15;
endmodule
"
"    wire condition_2 = (a & ~b & ~c & ~d);
    wire condition_7 = (~a & b & c & d);
    wire condition_15 = (~a & ~b & ~c & d);

    assign out_sop = condition_2 | condition_7 | condition_15;
    assign out_pos = (a | b | c | d) & ~(a & b & c & d);

endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    wire condition_2 = (a & ~b & ~c & ~d);
    wire condition_7 = (~a & b & c & d);
    wire condition_15 = (~a & ~b & ~c & d);

    assign out_sop = condition_2 | condition_7 | condition_15;
    assign out_pos = (a | b | c | d) & ~(a & b & c & d);

endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    wire condition_2 = (a & ~b & ~c & ~d);
    wire condition_7 = (~a & b & c & d);
    wire condition_15 = (~a & ~b & ~c & d);

    assign out_sop = condition_2 | condition_7 | condition_15;
    assign out_pos = (a | b | c | d) & ~(a & b & c & d);

endmodule
"
"    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
    
    assign w1 = !(a | b | c | d); // 0
    assign w2 = !(a & b & c & d); // 15
    assign w3 = !(a & b & !c & !d); // 14
    assign w4 = !(a & b & !c & d); // 13
    assign w5 = !(a & !b & c & !d); // 10
    assign w6 = !(a & !b & c & d); // 9
    assign w7 = !(!a & b & c & !d); // 6
    assign w8 = !(!a & b & c & d); // 5
    assign w9 = !(!a & b & !c & !d); // 4
    assign w10 = !(!a & !b & c & !d); // 1
    assign w11 = !(!a & !b & c & d); // 0
    assign w12 = !(!a & !b & !c & !d); // 3
    assign w13 = !(!a & !b & !c & d); // 2
    assign w14 = !(!a & b & !c & d); // 7
    assign w15 = !(!a & !b & !c & !d); // 12
    
    assign out_sop = w1 | w2 | w14;
    
    assign out_pos = w3 & w4 & w5 & w6 & w7 & w8 & w9 & w10 & w11 & w12 & w13 & w15;
endmodule
",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
    
    assign w1 = !(a | b | c | d); // 0
    assign w2 = !(a & b & c & d); // 15
    assign w3 = !(a & b & !c & !d); // 14
    assign w4 = !(a & b & !c & d); // 13
    assign w5 = !(a & !b & c & !d); // 10
    assign w6 = !(a & !b & c & d); // 9
    assign w7 = !(!a & b & c & !d); // 6
    assign w8 = !(!a & b & c & d); // 5
    assign w9 = !(!a & b & !c & !d); // 4
    assign w10 = !(!a & !b & c & !d); // 1
    assign w11 = !(!a & !b & c & d); // 0
    assign w12 = !(!a & !b & !c & !d); // 3
    assign w13 = !(!a & !b & !c & d); // 2
    assign w14 = !(!a & b & !c & d); // 7
    assign w15 = !(!a & !b & !c & !d); // 12
    
    assign out_sop = w1 | w2 | w14;
    
    assign out_pos = w3 & w4 & w5 & w6 & w7 & w8 & w9 & w10 & w11 & w12 & w13 & w15;
endmodule
","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
    
    assign w1 = !(a | b | c | d); // 0
    assign w2 = !(a & b & c & d); // 15
    assign w3 = !(a & b & !c & !d); // 14
    assign w4 = !(a & b & !c & d); // 13
    assign w5 = !(a & !b & c & !d); // 10
    assign w6 = !(a & !b & c & d); // 9
    assign w7 = !(!a & b & c & !d); // 6
    assign w8 = !(!a & b & c & d); // 5
    assign w9 = !(!a & b & !c & !d); // 4
    assign w10 = !(!a & !b & c & !d); // 1
    assign w11 = !(!a & !b & c & d); // 0
    assign w12 = !(!a & !b & !c & !d); // 3
    assign w13 = !(!a & !b & !c & d); // 2
    assign w14 = !(!a & b & !c & d); // 7
    assign w15 = !(!a & !b & !c & !d); // 12
    
    assign out_sop = w1 | w2 | w14;
    
    assign out_pos = w3 & w4 & w5 & w6 & w7 & w8 & w9 & w10 & w11 & w12 & w13 & w15;
endmodule
"
"// Define states
typedef enum logic [2:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1
} state_t;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [2:0] state, next_state;

// Define state transition and output logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= BELOW_S1;
    end else begin
        state <= next_state;
    end
end

always_comb begin
    case(state)
        ABOVE_S3: begin
            if (s == 3'b111) begin
                next_state = ABOVE_S3;
                fr3 = 1'b0;
                fr2 = 1'b0;
                fr1 = 1'b0;
                dfr = 1'b0;
            end else if (s == 3'b110) begin
                next_state = BETWEEN_S3_S2;
                fr3 = 1'b0;
                fr2 = 1'b0;
                fr1 = 1'b1;
                dfr = 1'b0;
            end else if (s == 3'b100) begin
                next_state = BETWEEN_S2_S1;
                fr3 = 1'b0;
                fr2 = 1'b1;
                fr1 = 1'b1;
                dfr = 1'b0;
            end else begin
                next_state = BELOW_S1;
                fr3 = 1'b1;
                fr2 = 1'b1;
                fr1 = 1'b1;
                dfr = 1'b0;
            end
        end
        BETWEEN_S3_S2: begin
            // Define logic for state BETWEEN_S3_S2
        end
        BETWEEN_S2_S1: begin
            // Define logic for state BETWEEN_S2_S1
        end
        BELOW_S1: begin
            // Define logic for state BELOW_S1
        end
    endcase
end

endmodule
",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
typedef enum logic [2:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1
} state_t;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [2:0] state, next_state;

// Define state transition and output logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= BELOW_S1;
    end else begin
        state <= next_state;
    end
end

always_comb begin
    case(state)
        ABOVE_S3: begin
            if (s == 3'b111) begin
                next_state = ABOVE_S3;
                fr3 = 1'b0;
                fr2 = 1'b0;
                fr1 = 1'b0;
                dfr = 1'b0;
            end else if (s == 3'b110) begin
                next_state = BETWEEN_S3_S2;
                fr3 = 1'b0;
                fr2 = 1'b0;
                fr1 = 1'b1;
                dfr = 1'b0;
            end else if (s == 3'b100) begin
                next_state = BETWEEN_S2_S1;
                fr3 = 1'b0;
                fr2 = 1'b1;
                fr1 = 1'b1;
                dfr = 1'b0;
            end else begin
                next_state = BELOW_S1;
                fr3 = 1'b1;
                fr2 = 1'b1;
                fr1 = 1'b1;
                dfr = 1'b0;
            end
        end
        BETWEEN_S3_S2: begin
            // Define logic for state BETWEEN_S3_S2
        end
        BETWEEN_S2_S1: begin
            // Define logic for state BETWEEN_S2_S1
        end
        BELOW_S1: begin
            // Define logic for state BELOW_S1
        end
    endcase
end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
typedef enum logic [2:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1
} state_t;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [2:0] state, next_state;

// Define state transition and output logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= BELOW_S1;
    end else begin
        state <= next_state;
    end
end

always_comb begin
    case(state)
        ABOVE_S3: begin
            if (s == 3'b111) begin
                next_state = ABOVE_S3;
                fr3 = 1'b0;
                fr2 = 1'b0;
                fr1 = 1'b0;
                dfr = 1'b0;
            end else if (s == 3'b110) begin
                next_state = BETWEEN_S3_S2;
                fr3 = 1'b0;
                fr2 = 1'b0;
                fr1 = 1'b1;
                dfr = 1'b0;
            end else if (s == 3'b100) begin
                next_state = BETWEEN_S2_S1;
                fr3 = 1'b0;
                fr2 = 1'b1;
                fr1 = 1'b1;
                dfr = 1'b0;
            end else begin
                next_state = BELOW_S1;
                fr3 = 1'b1;
                fr2 = 1'b1;
                fr1 = 1'b1;
                dfr = 1'b0;
            end
        end
        BETWEEN_S3_S2: begin
            // Define logic for state BETWEEN_S3_S2
        end
        BETWEEN_S2_S1: begin
            // Define logic for state BETWEEN_S2_S1
        end
        BELOW_S1: begin
            // Define logic for state BELOW_S1
        end
    endcase
end

endmodule
"
"// Define states
parameter S_IDLE = 2'b00;
parameter S_ABOVE_S3 = 2'b01;
parameter S_BETWEEN_S3_S2 = 2'b10;
parameter S_BETWEEN_S2_S1 = 2'b11;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [1:0] state, next_state;

// State transition and output logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= S_IDLE;
        fr3 <= 1'b1;
        fr2 <= 1'b1;
        fr1 <= 1'b1;
        dfr <= 1'b1;
    end else begin
        state <= next_state;
        case (state)
            S_IDLE: begin
                if (s[2]) next_state = S_ABOVE_S3;
                else next_state = S_IDLE;
                fr3 <= 1'b1;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
            end
            S_ABOVE_S3: begin
                if (s[1]) next_state = S_BETWEEN_S3_S2;
                else next_state = S_ABOVE_S3;
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            end
            S_BETWEEN_S3_S2: begin
                if (s[0]) next_state = S_BETWEEN_S2_S1;
                else next_state = S_BETWEEN_S3_S2;
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
            S_BETWEEN_S2_S1: begin
                if (!s[0]) next_state = S_IDLE;
                else next_state = S_BETWEEN_S2_S1;
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
            end
        endcase
    end
end

endmodule
",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
parameter S_IDLE = 2'b00;
parameter S_ABOVE_S3 = 2'b01;
parameter S_BETWEEN_S3_S2 = 2'b10;
parameter S_BETWEEN_S2_S1 = 2'b11;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [1:0] state, next_state;

// State transition and output logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= S_IDLE;
        fr3 <= 1'b1;
        fr2 <= 1'b1;
        fr1 <= 1'b1;
        dfr <= 1'b1;
    end else begin
        state <= next_state;
        case (state)
            S_IDLE: begin
                if (s[2]) next_state = S_ABOVE_S3;
                else next_state = S_IDLE;
                fr3 <= 1'b1;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
            end
            S_ABOVE_S3: begin
                if (s[1]) next_state = S_BETWEEN_S3_S2;
                else next_state = S_ABOVE_S3;
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            end
            S_BETWEEN_S3_S2: begin
                if (s[0]) next_state = S_BETWEEN_S2_S1;
                else next_state = S_BETWEEN_S3_S2;
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
            S_BETWEEN_S2_S1: begin
                if (!s[0]) next_state = S_IDLE;
                else next_state = S_BETWEEN_S2_S1;
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
            end
        endcase
    end
end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
parameter S_IDLE = 2'b00;
parameter S_ABOVE_S3 = 2'b01;
parameter S_BETWEEN_S3_S2 = 2'b10;
parameter S_BETWEEN_S2_S1 = 2'b11;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [1:0] state, next_state;

// State transition and output logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= S_IDLE;
        fr3 <= 1'b1;
        fr2 <= 1'b1;
        fr1 <= 1'b1;
        dfr <= 1'b1;
    end else begin
        state <= next_state;
        case (state)
            S_IDLE: begin
                if (s[2]) next_state = S_ABOVE_S3;
                else next_state = S_IDLE;
                fr3 <= 1'b1;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
            end
            S_ABOVE_S3: begin
                if (s[1]) next_state = S_BETWEEN_S3_S2;
                else next_state = S_ABOVE_S3;
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            end
            S_BETWEEN_S3_S2: begin
                if (s[0]) next_state = S_BETWEEN_S2_S1;
                else next_state = S_BETWEEN_S3_S2;
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
            S_BETWEEN_S2_S1: begin
                if (!s[0]) next_state = S_IDLE;
                else next_state = S_BETWEEN_S2_S1;
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
            end
        endcase
    end
end

endmodule
"
"// Define states
parameter S_IDLE = 2'b00;
parameter S_ABOVE_S3 = 2'b01;
parameter S_BETWEEN_S3_S2 = 2'b10;
parameter S_BETWEEN_S2_S1 = 2'b11;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [1:0] state, next_state;

// State transition and output logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= S_IDLE;
        fr3 <= 1'b1;
        fr2 <= 1'b1;
        fr1 <= 1'b1;
        dfr <= 1'b1;
    end else begin
        state <= next_state;
        case (state)
            S_IDLE:
                if (s[3]) next_state = S_ABOVE_S3;
                else next_state = S_IDLE;
                fr3 <= 1'b1;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
            S_ABOVE_S3:
                if (s[2]) next_state = S_BETWEEN_S3_S2;
                else next_state = S_ABOVE_S3;
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            S_BETWEEN_S3_S2:
                if (s[1]) next_state = S_BETWEEN_S2_S1;
                else next_state = S_BETWEEN_S3_S2;
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            S_BETWEEN_S2_S1:
                if (s[1]) next_state = S_BETWEEN_S2_S1;
                else next_state = S_IDLE;
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
        endcase
    end
end

endmodule
",-1.0,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
parameter S_IDLE = 2'b00;
parameter S_ABOVE_S3 = 2'b01;
parameter S_BETWEEN_S3_S2 = 2'b10;
parameter S_BETWEEN_S2_S1 = 2'b11;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [1:0] state, next_state;

// State transition and output logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= S_IDLE;
        fr3 <= 1'b1;
        fr2 <= 1'b1;
        fr1 <= 1'b1;
        dfr <= 1'b1;
    end else begin
        state <= next_state;
        case (state)
            S_IDLE:
                if (s[3]) next_state = S_ABOVE_S3;
                else next_state = S_IDLE;
                fr3 <= 1'b1;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
            S_ABOVE_S3:
                if (s[2]) next_state = S_BETWEEN_S3_S2;
                else next_state = S_ABOVE_S3;
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            S_BETWEEN_S3_S2:
                if (s[1]) next_state = S_BETWEEN_S2_S1;
                else next_state = S_BETWEEN_S3_S2;
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            S_BETWEEN_S2_S1:
                if (s[1]) next_state = S_BETWEEN_S2_S1;
                else next_state = S_IDLE;
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
        endcase
    end
end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
parameter S_IDLE = 2'b00;
parameter S_ABOVE_S3 = 2'b01;
parameter S_BETWEEN_S3_S2 = 2'b10;
parameter S_BETWEEN_S2_S1 = 2'b11;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [1:0] state, next_state;

// State transition and output logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= S_IDLE;
        fr3 <= 1'b1;
        fr2 <= 1'b1;
        fr1 <= 1'b1;
        dfr <= 1'b1;
    end else begin
        state <= next_state;
        case (state)
            S_IDLE:
                if (s[3]) next_state = S_ABOVE_S3;
                else next_state = S_IDLE;
                fr3 <= 1'b1;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
            S_ABOVE_S3:
                if (s[2]) next_state = S_BETWEEN_S3_S2;
                else next_state = S_ABOVE_S3;
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            S_BETWEEN_S3_S2:
                if (s[1]) next_state = S_BETWEEN_S2_S1;
                else next_state = S_BETWEEN_S3_S2;
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            S_BETWEEN_S2_S1:
                if (s[1]) next_state = S_BETWEEN_S2_S1;
                else next_state = S_IDLE;
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b1;
        endcase
    end
end

endmodule
"
"// Define states
typedef enum logic[2:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1
} state_t;

// Define outputs
output reg fr3;
output reg fr2;
output reg fr1;
output reg dfr;

// Define state register
reg [2:0] state_reg, state_next;

// Define output register
reg [1:0] output_reg, output_next;

// Define state transition and output logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= BELOW_S1;
        output_reg <= 2'b11;
    end else begin
        state_reg <= state_next;
        output_reg <= output_next;
    end
end

always_comb begin
    case(state_reg)
        ABOVE_S3: begin
            if (s[2]) begin
                state_next = BETWEEN_S3_S2;
                output_next = 2'b01;
            end else begin
                state_next = ABOVE_S3;
                output_next = 2'b00;
            end
        end
        BETWEEN_S3_S2: begin
            if (s[1]) begin
                state_next = BETWEEN_S2_S1;
                output_next = 2'b01;
            end else if (!s[2]) begin
                state_next = ABOVE_S3;
                output_next = 2'b00;
            end else begin
                state_next = BETWEEN_S3_S2;
                output_next = 2'b01;
            end
        end
        BETWEEN_S2_S1: begin
            if (s[0]) begin
                state_next = BELOW_S1;
                output_next = 2'b01;
            end else if (!s[1]) begin
                state_next = BETWEEN_S3_S2;
                output_next = 2'b01;
            end else begin
                state_next = BETWEEN_S2_S1;
                output_next = 2'b10;
            end
        end
        BELOW_S1: begin
            if (!s[0]) begin
                state_next = BETWEEN_S2_S1;
                output_next = 2'b10;
            end else begin
                state_next = BELOW_S1;
                output_next = 2'b11;
            end
        end
        default: begin
            state_next = ABOVE_S3;
            output_next = 2'b00;
        end
    endcase
end

// Define output assignments
assign fr3 = output_reg[1];
assign fr2 = output_reg[0];
assign fr1 = output_reg[1] | output_reg[0];
assign dfr = (state_reg == BETWEEN_S2_S1) ? 1'b1 : 1'b0;

endmodule
",-1.0,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
typedef enum logic[2:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1
} state_t;

// Define outputs
output reg fr3;
output reg fr2;
output reg fr1;
output reg dfr;

// Define state register
reg [2:0] state_reg, state_next;

// Define output register
reg [1:0] output_reg, output_next;

// Define state transition and output logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= BELOW_S1;
        output_reg <= 2'b11;
    end else begin
        state_reg <= state_next;
        output_reg <= output_next;
    end
end

always_comb begin
    case(state_reg)
        ABOVE_S3: begin
            if (s[2]) begin
                state_next = BETWEEN_S3_S2;
                output_next = 2'b01;
            end else begin
                state_next = ABOVE_S3;
                output_next = 2'b00;
            end
        end
        BETWEEN_S3_S2: begin
            if (s[1]) begin
                state_next = BETWEEN_S2_S1;
                output_next = 2'b01;
            end else if (!s[2]) begin
                state_next = ABOVE_S3;
                output_next = 2'b00;
            end else begin
                state_next = BETWEEN_S3_S2;
                output_next = 2'b01;
            end
        end
        BETWEEN_S2_S1: begin
            if (s[0]) begin
                state_next = BELOW_S1;
                output_next = 2'b01;
            end else if (!s[1]) begin
                state_next = BETWEEN_S3_S2;
                output_next = 2'b01;
            end else begin
                state_next = BETWEEN_S2_S1;
                output_next = 2'b10;
            end
        end
        BELOW_S1: begin
            if (!s[0]) begin
                state_next = BETWEEN_S2_S1;
                output_next = 2'b10;
            end else begin
                state_next = BELOW_S1;
                output_next = 2'b11;
            end
        end
        default: begin
            state_next = ABOVE_S3;
            output_next = 2'b00;
        end
    endcase
end

// Define output assignments
assign fr3 = output_reg[1];
assign fr2 = output_reg[0];
assign fr1 = output_reg[1] | output_reg[0];
assign dfr = (state_reg == BETWEEN_S2_S1) ? 1'b1 : 1'b0;

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
typedef enum logic[2:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1
} state_t;

// Define outputs
output reg fr3;
output reg fr2;
output reg fr1;
output reg dfr;

// Define state register
reg [2:0] state_reg, state_next;

// Define output register
reg [1:0] output_reg, output_next;

// Define state transition and output logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= BELOW_S1;
        output_reg <= 2'b11;
    end else begin
        state_reg <= state_next;
        output_reg <= output_next;
    end
end

always_comb begin
    case(state_reg)
        ABOVE_S3: begin
            if (s[2]) begin
                state_next = BETWEEN_S3_S2;
                output_next = 2'b01;
            end else begin
                state_next = ABOVE_S3;
                output_next = 2'b00;
            end
        end
        BETWEEN_S3_S2: begin
            if (s[1]) begin
                state_next = BETWEEN_S2_S1;
                output_next = 2'b01;
            end else if (!s[2]) begin
                state_next = ABOVE_S3;
                output_next = 2'b00;
            end else begin
                state_next = BETWEEN_S3_S2;
                output_next = 2'b01;
            end
        end
        BETWEEN_S2_S1: begin
            if (s[0]) begin
                state_next = BELOW_S1;
                output_next = 2'b01;
            end else if (!s[1]) begin
                state_next = BETWEEN_S3_S2;
                output_next = 2'b01;
            end else begin
                state_next = BETWEEN_S2_S1;
                output_next = 2'b10;
            end
        end
        BELOW_S1: begin
            if (!s[0]) begin
                state_next = BETWEEN_S2_S1;
                output_next = 2'b10;
            end else begin
                state_next = BELOW_S1;
                output_next = 2'b11;
            end
        end
        default: begin
            state_next = ABOVE_S3;
            output_next = 2'b00;
        end
    endcase
end

// Define output assignments
assign fr3 = output_reg[1];
assign fr2 = output_reg[0];
assign fr1 = output_reg[1] | output_reg[0];
assign dfr = (state_reg == BETWEEN_S2_S1) ? 1'b1 : 1'b0;

endmodule
"
"    // Define states
    typedef enum logic [2:0] {
        ABOVE_S3,
        BETWEEN_S3_S2,
        BETWEEN_S2_S1,
        BELOW_S1,
        RESET_STATE
    } state_t;

    // Define outputs
    output reg fr3;
    output reg fr2;
    output reg fr1;
    output reg dfr;

    // Define state register
    state_t state, next_state;

    // Define Moore model
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= RESET_STATE;
        end else begin
            state <= next_state;
        end
    end

    // Define next state logic and outputs
    always @* begin
        case (state)
            ABOVE_S3: begin
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 1;
                end
            end
            BETWEEN_S3_S2: begin
                // Define outputs and next state logic for this state
            end
            BETWEEN_S2_S1: begin
                // Define outputs and next state logic for this state
            end
            BELOW_S1: begin
                // Define outputs and next state logic for this state
            end
            RESET_STATE: begin
                // Define outputs and next state logic for reset state
            end
        endcase
    end

endmodule
",-1.0,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

    // Define states
    typedef enum logic [2:0] {
        ABOVE_S3,
        BETWEEN_S3_S2,
        BETWEEN_S2_S1,
        BELOW_S1,
        RESET_STATE
    } state_t;

    // Define outputs
    output reg fr3;
    output reg fr2;
    output reg fr1;
    output reg dfr;

    // Define state register
    state_t state, next_state;

    // Define Moore model
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= RESET_STATE;
        end else begin
            state <= next_state;
        end
    end

    // Define next state logic and outputs
    always @* begin
        case (state)
            ABOVE_S3: begin
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 1;
                end
            end
            BETWEEN_S3_S2: begin
                // Define outputs and next state logic for this state
            end
            BETWEEN_S2_S1: begin
                // Define outputs and next state logic for this state
            end
            BELOW_S1: begin
                // Define outputs and next state logic for this state
            end
            RESET_STATE: begin
                // Define outputs and next state logic for reset state
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

    // Define states
    typedef enum logic [2:0] {
        ABOVE_S3,
        BETWEEN_S3_S2,
        BETWEEN_S2_S1,
        BELOW_S1,
        RESET_STATE
    } state_t;

    // Define outputs
    output reg fr3;
    output reg fr2;
    output reg fr1;
    output reg dfr;

    // Define state register
    state_t state, next_state;

    // Define Moore model
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= RESET_STATE;
        end else begin
            state <= next_state;
        end
    end

    // Define next state logic and outputs
    always @* begin
        case (state)
            ABOVE_S3: begin
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 1;
                end
            end
            BETWEEN_S3_S2: begin
                // Define outputs and next state logic for this state
            end
            BETWEEN_S2_S1: begin
                // Define outputs and next state logic for this state
            end
            BELOW_S1: begin
                // Define outputs and next state logic for this state
            end
            RESET_STATE: begin
                // Define outputs and next state logic for reset state
            end
        endcase
    end

endmodule
"
"// Define states
typedef enum logic [3:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1,
    RESET_STATE
} state_t;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [3:0] state_reg, next_state;

// Define Moore state transition and output logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= RESET_STATE;
    end else begin
        state_reg <= next_state;
    end
end

// Define next state logic
always @* begin
    case(state_reg)
        ABOVE_S3: begin
            if (s[3]) begin
                next_state = ABOVE_S3;
            end else if (s[2]) begin
                next_state = BETWEEN_S3_S2;
            end else if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BETWEEN_S3_S2: begin
            if (s[2]) begin
                next_state = BETWEEN_S3_S2;
            end else if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BETWEEN_S2_S1: begin
            if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BELOW_S1: begin
            if (!s[1]) begin
                next_state = BELOW_S1;
            end else if (!s[2]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BETWEEN_S3_S2;
            end
        end
        RESET_STATE: begin
            next_state = BELOW_S1;
        end
    endcase
end

// Define output logic
always @* begin
    case(state_reg)
        ABOVE_S3: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 0;
            dfr = 0;
        end
        BETWEEN_S3_S2: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 1;
            dfr = 0;
        end
        BETWEEN_S2_S1: begin
            fr3 = 0;
            fr2 = 1;
            fr1 = 1;
            dfr = 0;
        end
        BELOW_S1: begin
            fr3 = 1;
            fr2 = 1;
            fr1 = 1;
            dfr = 1;
        end
        default: begin
            fr3 = 1;
            fr2 = 1;
            fr1 = 1;
            dfr = 1;
        end
    endcase
end

endmodule
",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
typedef enum logic [3:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1,
    RESET_STATE
} state_t;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [3:0] state_reg, next_state;

// Define Moore state transition and output logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= RESET_STATE;
    end else begin
        state_reg <= next_state;
    end
end

// Define next state logic
always @* begin
    case(state_reg)
        ABOVE_S3: begin
            if (s[3]) begin
                next_state = ABOVE_S3;
            end else if (s[2]) begin
                next_state = BETWEEN_S3_S2;
            end else if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BETWEEN_S3_S2: begin
            if (s[2]) begin
                next_state = BETWEEN_S3_S2;
            end else if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BETWEEN_S2_S1: begin
            if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BELOW_S1: begin
            if (!s[1]) begin
                next_state = BELOW_S1;
            end else if (!s[2]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BETWEEN_S3_S2;
            end
        end
        RESET_STATE: begin
            next_state = BELOW_S1;
        end
    endcase
end

// Define output logic
always @* begin
    case(state_reg)
        ABOVE_S3: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 0;
            dfr = 0;
        end
        BETWEEN_S3_S2: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 1;
            dfr = 0;
        end
        BETWEEN_S2_S1: begin
            fr3 = 0;
            fr2 = 1;
            fr1 = 1;
            dfr = 0;
        end
        BELOW_S1: begin
            fr3 = 1;
            fr2 = 1;
            fr1 = 1;
            dfr = 1;
        end
        default: begin
            fr3 = 1;
            fr2 = 1;
            fr1 = 1;
            dfr = 1;
        end
    endcase
end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
typedef enum logic [3:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1,
    RESET_STATE
} state_t;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [3:0] state_reg, next_state;

// Define Moore state transition and output logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= RESET_STATE;
    end else begin
        state_reg <= next_state;
    end
end

// Define next state logic
always @* begin
    case(state_reg)
        ABOVE_S3: begin
            if (s[3]) begin
                next_state = ABOVE_S3;
            end else if (s[2]) begin
                next_state = BETWEEN_S3_S2;
            end else if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BETWEEN_S3_S2: begin
            if (s[2]) begin
                next_state = BETWEEN_S3_S2;
            end else if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BETWEEN_S2_S1: begin
            if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BELOW_S1: begin
            if (!s[1]) begin
                next_state = BELOW_S1;
            end else if (!s[2]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BETWEEN_S3_S2;
            end
        end
        RESET_STATE: begin
            next_state = BELOW_S1;
        end
    endcase
end

// Define output logic
always @* begin
    case(state_reg)
        ABOVE_S3: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 0;
            dfr = 0;
        end
        BETWEEN_S3_S2: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 1;
            dfr = 0;
        end
        BETWEEN_S2_S1: begin
            fr3 = 0;
            fr2 = 1;
            fr1 = 1;
            dfr = 0;
        end
        BELOW_S1: begin
            fr3 = 1;
            fr2 = 1;
            fr1 = 1;
            dfr = 1;
        end
        default: begin
            fr3 = 1;
            fr2 = 1;
            fr1 = 1;
            dfr = 1;
        end
    endcase
end

endmodule
"
"    // State encoding:
    // S0: Water level low for a long time
    // S1: Between S3 and S2
    // S2: Between S2 and S1
    // S3: Water level above S3
    
    reg [1:0] state, next_state;
    reg fr3, fr2, fr1, dfr;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 2'b00; // Reset to state S0
            fr3 <= 1'b1;    // All outputs asserted
            fr2 <= 1'b1;
            fr1 <= 1'b1;
            dfr <= 1'b1;
        end else begin
            state <= next_state;
            fr3 <= (state == 2'b00) ? 1'b1 : 1'b0; // FR3 asserted only in state S0
            fr2 <= (state == 2'b00) ? 1'b1 : 1'b0; // FR2 asserted only in state S0
            fr1 <= (state == 2'b00) ? 1'b1 : 1'b0; // FR1 asserted only in state S0
            dfr <= (state == 2'b00) ? 1'b1 : 1'b0; // Delta FR asserted only in state S0
        end
    end
    
    always @* begin
        case (state)
            2'b00: begin // State S0
                if (s == 3'b000) begin
                    next_state = 2'b00; // Stay in state S0
                end else if (s == 3'b001) begin
                    next_state = 2'b01; // Transition to state S1
                end else if (s == 3'b010) begin
                    next_state = 2'b10; // Transition to state S2
                end else if (s == 3'b011) begin
                    next_state = 2'b11; // Transition to state S3
                end
            end
            2'b01: begin // State S1
                if (s == 3'b001) begin
                    next_state = 2'b01; // Stay in state S1
                end else if (s == 3'b010) begin
                    next_state = 2'b10; // Transition to state S2
                end else if (s == 3'b011) begin
                    next_state = 2'b11; // Transition to state S3
                end
            end
            2'b10: begin // State S2
                if (s == 3'b010) begin
                    next_state = 2'b10; // Stay in state S2
                end else if (s == 3'b011) begin
                    next_state = 2'b11; // Transition to state S3
                end
            end
            2'b11: begin // State S3
                if (s == 3'b011) begin
                    next_state = 2'b11; // Stay in state S3
                end else begin
                    next_state = 2'b00; // Transition back to state S0
                end
            end
        endcase
    end
endmodule
",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

    // State encoding:
    // S0: Water level low for a long time
    // S1: Between S3 and S2
    // S2: Between S2 and S1
    // S3: Water level above S3
    
    reg [1:0] state, next_state;
    reg fr3, fr2, fr1, dfr;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 2'b00; // Reset to state S0
            fr3 <= 1'b1;    // All outputs asserted
            fr2 <= 1'b1;
            fr1 <= 1'b1;
            dfr <= 1'b1;
        end else begin
            state <= next_state;
            fr3 <= (state == 2'b00) ? 1'b1 : 1'b0; // FR3 asserted only in state S0
            fr2 <= (state == 2'b00) ? 1'b1 : 1'b0; // FR2 asserted only in state S0
            fr1 <= (state == 2'b00) ? 1'b1 : 1'b0; // FR1 asserted only in state S0
            dfr <= (state == 2'b00) ? 1'b1 : 1'b0; // Delta FR asserted only in state S0
        end
    end
    
    always @* begin
        case (state)
            2'b00: begin // State S0
                if (s == 3'b000) begin
                    next_state = 2'b00; // Stay in state S0
                end else if (s == 3'b001) begin
                    next_state = 2'b01; // Transition to state S1
                end else if (s == 3'b010) begin
                    next_state = 2'b10; // Transition to state S2
                end else if (s == 3'b011) begin
                    next_state = 2'b11; // Transition to state S3
                end
            end
            2'b01: begin // State S1
                if (s == 3'b001) begin
                    next_state = 2'b01; // Stay in state S1
                end else if (s == 3'b010) begin
                    next_state = 2'b10; // Transition to state S2
                end else if (s == 3'b011) begin
                    next_state = 2'b11; // Transition to state S3
                end
            end
            2'b10: begin // State S2
                if (s == 3'b010) begin
                    next_state = 2'b10; // Stay in state S2
                end else if (s == 3'b011) begin
                    next_state = 2'b11; // Transition to state S3
                end
            end
            2'b11: begin // State S3
                if (s == 3'b011) begin
                    next_state = 2'b11; // Stay in state S3
                end else begin
                    next_state = 2'b00; // Transition back to state S0
                end
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

    // State encoding:
    // S0: Water level low for a long time
    // S1: Between S3 and S2
    // S2: Between S2 and S1
    // S3: Water level above S3
    
    reg [1:0] state, next_state;
    reg fr3, fr2, fr1, dfr;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 2'b00; // Reset to state S0
            fr3 <= 1'b1;    // All outputs asserted
            fr2 <= 1'b1;
            fr1 <= 1'b1;
            dfr <= 1'b1;
        end else begin
            state <= next_state;
            fr3 <= (state == 2'b00) ? 1'b1 : 1'b0; // FR3 asserted only in state S0
            fr2 <= (state == 2'b00) ? 1'b1 : 1'b0; // FR2 asserted only in state S0
            fr1 <= (state == 2'b00) ? 1'b1 : 1'b0; // FR1 asserted only in state S0
            dfr <= (state == 2'b00) ? 1'b1 : 1'b0; // Delta FR asserted only in state S0
        end
    end
    
    always @* begin
        case (state)
            2'b00: begin // State S0
                if (s == 3'b000) begin
                    next_state = 2'b00; // Stay in state S0
                end else if (s == 3'b001) begin
                    next_state = 2'b01; // Transition to state S1
                end else if (s == 3'b010) begin
                    next_state = 2'b10; // Transition to state S2
                end else if (s == 3'b011) begin
                    next_state = 2'b11; // Transition to state S3
                end
            end
            2'b01: begin // State S1
                if (s == 3'b001) begin
                    next_state = 2'b01; // Stay in state S1
                end else if (s == 3'b010) begin
                    next_state = 2'b10; // Transition to state S2
                end else if (s == 3'b011) begin
                    next_state = 2'b11; // Transition to state S3
                end
            end
            2'b10: begin // State S2
                if (s == 3'b010) begin
                    next_state = 2'b10; // Stay in state S2
                end else if (s == 3'b011) begin
                    next_state = 2'b11; // Transition to state S3
                end
            end
            2'b11: begin // State S3
                if (s == 3'b011) begin
                    next_state = 2'b11; // Stay in state S3
                end else begin
                    next_state = 2'b00; // Transition back to state S0
                end
            end
        endcase
    end
endmodule
"
"// Define states
typedef enum logic [3:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1
} state_t;

// Define outputs
output reg fr3;
output reg fr2;
output reg fr1;
output reg dfr;

// Define state register
reg [3:0] state_reg, next_state;

// Moore state machine
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= BELOW_S1;
        fr3 <= 1'b1;
        fr2 <= 1'b1;
        fr1 <= 1'b1;
        dfr <= 1'b1;
    end else begin
        state_reg <= next_state;
        case (state_reg)
            ABOVE_S3: begin
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            end
            BETWEEN_S3_S2: begin
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
            BETWEEN_S2_S1: begin
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
            BELOW_S1: begin
                fr3 <= 1'b1;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
        endcase
    end
end

// Next state logic
always @(*) begin
    case (state_reg)
        ABOVE_S3: begin
            if (s == 3'b100)
                next_state = ABOVE_S3;
            else if (s == 3'b011)
                next_state = BETWEEN_S3_S2;
        end
        BETWEEN_S3_S2: begin
            if (s == 3'b011)
                next_state = BETWEEN_S3_S2;
            else if (s == 3'b010)
                next_state = BETWEEN_S2_S1;
            else if (s == 3'b001)
                next_state = BELOW_S1;
        end
        BETWEEN_S2_S1: begin
            if (s == 3'b010)
                next_state = BETWEEN_S2_S1;
            else if (s == 3'b001)
                next_state = BELOW_S1;
        end
        BELOW_S1: begin
            if (s == 3'b001)
                next_state = BELOW_S1;
            else if (s == 3'b011)
                next_state = BETWEEN_S3_S2;
        end
    endcase
end

endmodule
",-1.0,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
typedef enum logic [3:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1
} state_t;

// Define outputs
output reg fr3;
output reg fr2;
output reg fr1;
output reg dfr;

// Define state register
reg [3:0] state_reg, next_state;

// Moore state machine
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= BELOW_S1;
        fr3 <= 1'b1;
        fr2 <= 1'b1;
        fr1 <= 1'b1;
        dfr <= 1'b1;
    end else begin
        state_reg <= next_state;
        case (state_reg)
            ABOVE_S3: begin
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            end
            BETWEEN_S3_S2: begin
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
            BETWEEN_S2_S1: begin
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
            BELOW_S1: begin
                fr3 <= 1'b1;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
        endcase
    end
end

// Next state logic
always @(*) begin
    case (state_reg)
        ABOVE_S3: begin
            if (s == 3'b100)
                next_state = ABOVE_S3;
            else if (s == 3'b011)
                next_state = BETWEEN_S3_S2;
        end
        BETWEEN_S3_S2: begin
            if (s == 3'b011)
                next_state = BETWEEN_S3_S2;
            else if (s == 3'b010)
                next_state = BETWEEN_S2_S1;
            else if (s == 3'b001)
                next_state = BELOW_S1;
        end
        BETWEEN_S2_S1: begin
            if (s == 3'b010)
                next_state = BETWEEN_S2_S1;
            else if (s == 3'b001)
                next_state = BELOW_S1;
        end
        BELOW_S1: begin
            if (s == 3'b001)
                next_state = BELOW_S1;
            else if (s == 3'b011)
                next_state = BETWEEN_S3_S2;
        end
    endcase
end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
typedef enum logic [3:0] {
    ABOVE_S3,
    BETWEEN_S3_S2,
    BETWEEN_S2_S1,
    BELOW_S1
} state_t;

// Define outputs
output reg fr3;
output reg fr2;
output reg fr1;
output reg dfr;

// Define state register
reg [3:0] state_reg, next_state;

// Moore state machine
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= BELOW_S1;
        fr3 <= 1'b1;
        fr2 <= 1'b1;
        fr1 <= 1'b1;
        dfr <= 1'b1;
    end else begin
        state_reg <= next_state;
        case (state_reg)
            ABOVE_S3: begin
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b0;
                dfr <= 1'b0;
            end
            BETWEEN_S3_S2: begin
                fr3 <= 1'b0;
                fr2 <= 1'b0;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
            BETWEEN_S2_S1: begin
                fr3 <= 1'b0;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
            BELOW_S1: begin
                fr3 <= 1'b1;
                fr2 <= 1'b1;
                fr1 <= 1'b1;
                dfr <= 1'b0;
            end
        endcase
    end
end

// Next state logic
always @(*) begin
    case (state_reg)
        ABOVE_S3: begin
            if (s == 3'b100)
                next_state = ABOVE_S3;
            else if (s == 3'b011)
                next_state = BETWEEN_S3_S2;
        end
        BETWEEN_S3_S2: begin
            if (s == 3'b011)
                next_state = BETWEEN_S3_S2;
            else if (s == 3'b010)
                next_state = BETWEEN_S2_S1;
            else if (s == 3'b001)
                next_state = BELOW_S1;
        end
        BETWEEN_S2_S1: begin
            if (s == 3'b010)
                next_state = BETWEEN_S2_S1;
            else if (s == 3'b001)
                next_state = BELOW_S1;
        end
        BELOW_S1: begin
            if (s == 3'b001)
                next_state = BELOW_S1;
            else if (s == 3'b011)
                next_state = BETWEEN_S3_S2;
        end
    endcase
end

endmodule
"
"    // Define states
    typedef enum logic [2:0] {
        ABOVE_S3,
        BETWEEN_S3_S2,
        BETWEEN_S2_S1,
        BELOW_S1,
        RESET_STATE
    } state_t;

    // Define outputs
    reg fr3, fr2, fr1, dfr;

    // Define state register
    reg [2:0] state, next_state;

    // State transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= RESET_STATE;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case (state)
            ABOVE_S3:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            BETWEEN_S3_S2:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            BETWEEN_S2_S1:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            BELOW_S1:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            RESET_STATE:
                next_state = BELOW_S1;
                fr3 = 1;
                fr2 = 1;
                fr1 = 1;
                dfr = 0;
        endcase
    end

endmodule
",-1.0,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

    // Define states
    typedef enum logic [2:0] {
        ABOVE_S3,
        BETWEEN_S3_S2,
        BETWEEN_S2_S1,
        BELOW_S1,
        RESET_STATE
    } state_t;

    // Define outputs
    reg fr3, fr2, fr1, dfr;

    // Define state register
    reg [2:0] state, next_state;

    // State transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= RESET_STATE;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case (state)
            ABOVE_S3:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            BETWEEN_S3_S2:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            BETWEEN_S2_S1:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            BELOW_S1:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            RESET_STATE:
                next_state = BELOW_S1;
                fr3 = 1;
                fr2 = 1;
                fr1 = 1;
                dfr = 0;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

    // Define states
    typedef enum logic [2:0] {
        ABOVE_S3,
        BETWEEN_S3_S2,
        BETWEEN_S2_S1,
        BELOW_S1,
        RESET_STATE
    } state_t;

    // Define outputs
    reg fr3, fr2, fr1, dfr;

    // Define state register
    reg [2:0] state, next_state;

    // State transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= RESET_STATE;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case (state)
            ABOVE_S3:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            BETWEEN_S3_S2:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            BETWEEN_S2_S1:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            BELOW_S1:
                if (s == 3'b111) begin
                    next_state = ABOVE_S3;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 0;
                    dfr = 0;
                end else if (s == 3'b110) begin
                    next_state = BETWEEN_S3_S2;
                    fr3 = 0;
                    fr2 = 0;
                    fr1 = 1;
                    dfr = 0;
                end else if (s == 3'b100) begin
                    next_state = BETWEEN_S2_S1;
                    fr3 = 0;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end else begin
                    next_state = BELOW_S1;
                    fr3 = 1;
                    fr2 = 1;
                    fr1 = 1;
                    dfr = 0;
                end
            RESET_STATE:
                next_state = BELOW_S1;
                fr3 = 1;
                fr2 = 1;
                fr1 = 1;
                dfr = 0;
        endcase
    end

endmodule
"
"// Define states
parameter ABOVE_S3 = 3'b000;
parameter BETWEEN_S3_S2 = 3'b001;
parameter BETWEEN_S2_S1 = 3'b010;
parameter BELOW_S1 = 3'b011;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [2:0] state, next_state;

always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= BELOW_S1;
    end else begin
        state <= next_state;
    end
end

// Define output logic
always @ (*) begin
    case (state)
        ABOVE_S3: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 0;
            dfr = 0;
        end
        BETWEEN_S3_S2: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 1;
            dfr = 0;
        end
        BETWEEN_S2_S1: begin
            fr3 = 0;
            fr2 = 1;
            fr1 = 1;
            dfr = 0;
        end
        BELOW_S1: begin
            fr3 = 1;
            fr2 = 1;
            fr1 = 1;
            dfr = 0;
        end
    endcase
end

// Define next state logic
always @ (*) begin
    case (state)
        ABOVE_S3: begin
            if (s[2] && s[1] && s[0]) begin
                next_state = ABOVE_S3;
            end else if (s[2] && s[1]) begin
                next_state = BETWEEN_S3_S2;
            end else if (s[2]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BETWEEN_S3_S2: begin
            if (s[2] && s[1]) begin
                next_state = BETWEEN_S3_S2;
            end else begin
                next_state = ABOVE_S3;
            end
        end
        BETWEEN_S2_S1: begin
            if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = ABOVE_S3;
            end
        end
        BELOW_S1: begin
            if (!s[2] && !s[1] && !s[0]) begin
                next_state = BELOW_S1;
            end else if (!s[2] && !s[1]) begin
                next_state = BETWEEN_S3_S2;
            end else if (!s[2]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = ABOVE_S3;
            end
        end
    endcase
end

endmodule
",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
parameter ABOVE_S3 = 3'b000;
parameter BETWEEN_S3_S2 = 3'b001;
parameter BETWEEN_S2_S1 = 3'b010;
parameter BELOW_S1 = 3'b011;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [2:0] state, next_state;

always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= BELOW_S1;
    end else begin
        state <= next_state;
    end
end

// Define output logic
always @ (*) begin
    case (state)
        ABOVE_S3: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 0;
            dfr = 0;
        end
        BETWEEN_S3_S2: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 1;
            dfr = 0;
        end
        BETWEEN_S2_S1: begin
            fr3 = 0;
            fr2 = 1;
            fr1 = 1;
            dfr = 0;
        end
        BELOW_S1: begin
            fr3 = 1;
            fr2 = 1;
            fr1 = 1;
            dfr = 0;
        end
    endcase
end

// Define next state logic
always @ (*) begin
    case (state)
        ABOVE_S3: begin
            if (s[2] && s[1] && s[0]) begin
                next_state = ABOVE_S3;
            end else if (s[2] && s[1]) begin
                next_state = BETWEEN_S3_S2;
            end else if (s[2]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BETWEEN_S3_S2: begin
            if (s[2] && s[1]) begin
                next_state = BETWEEN_S3_S2;
            end else begin
                next_state = ABOVE_S3;
            end
        end
        BETWEEN_S2_S1: begin
            if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = ABOVE_S3;
            end
        end
        BELOW_S1: begin
            if (!s[2] && !s[1] && !s[0]) begin
                next_state = BELOW_S1;
            end else if (!s[2] && !s[1]) begin
                next_state = BETWEEN_S3_S2;
            end else if (!s[2]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = ABOVE_S3;
            end
        end
    endcase
end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);

// Define states
parameter ABOVE_S3 = 3'b000;
parameter BETWEEN_S3_S2 = 3'b001;
parameter BETWEEN_S2_S1 = 3'b010;
parameter BELOW_S1 = 3'b011;

// Define outputs
reg fr3, fr2, fr1, dfr;

// Define state register
reg [2:0] state, next_state;

always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= BELOW_S1;
    end else begin
        state <= next_state;
    end
end

// Define output logic
always @ (*) begin
    case (state)
        ABOVE_S3: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 0;
            dfr = 0;
        end
        BETWEEN_S3_S2: begin
            fr3 = 0;
            fr2 = 0;
            fr1 = 1;
            dfr = 0;
        end
        BETWEEN_S2_S1: begin
            fr3 = 0;
            fr2 = 1;
            fr1 = 1;
            dfr = 0;
        end
        BELOW_S1: begin
            fr3 = 1;
            fr2 = 1;
            fr1 = 1;
            dfr = 0;
        end
    endcase
end

// Define next state logic
always @ (*) begin
    case (state)
        ABOVE_S3: begin
            if (s[2] && s[1] && s[0]) begin
                next_state = ABOVE_S3;
            end else if (s[2] && s[1]) begin
                next_state = BETWEEN_S3_S2;
            end else if (s[2]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = BELOW_S1;
            end
        end
        BETWEEN_S3_S2: begin
            if (s[2] && s[1]) begin
                next_state = BETWEEN_S3_S2;
            end else begin
                next_state = ABOVE_S3;
            end
        end
        BETWEEN_S2_S1: begin
            if (s[1]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = ABOVE_S3;
            end
        end
        BELOW_S1: begin
            if (!s[2] && !s[1] && !s[0]) begin
                next_state = BELOW_S1;
            end else if (!s[2] && !s[1]) begin
                next_state = BETWEEN_S3_S2;
            end else if (!s[2]) begin
                next_state = BETWEEN_S2_S1;
            end else begin
                next_state = ABOVE_S3;
            end
        end
    endcase
end

endmodule
"
"    wire d;
    wire q_old;

    assign d = (j & ~q_old) | (~k & q_old);

    d_flip_flop d_ff (
        .clk(clk),
        .d(d),
        .q(Q),
    );

    assign q_old = Q;
endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire d;
    wire q_old;

    assign d = (j & ~q_old) | (~k & q_old);

    d_flip_flop d_ff (
        .clk(clk),
        .d(d),
        .q(Q),
    );

    assign q_old = Q;
endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire d;
    wire q_old;

    assign d = (j & ~q_old) | (~k & q_old);

    d_flip_flop d_ff (
        .clk(clk),
        .d(d),
        .q(Q),
    );

    assign q_old = Q;
endmodule
"
"    wire Qold;
    wire not_Qold;
    
    assign not_Qold = ~Qold;
    
    d_flipflop d_ff (
        .clk(clk),
        .d(not_Qold),
        .q(Qold)
    );
    
    assign Q = (j & not_Qold) | (k & Qold);
endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire Qold;
    wire not_Qold;
    
    assign not_Qold = ~Qold;
    
    d_flipflop d_ff (
        .clk(clk),
        .d(not_Qold),
        .q(Qold)
    );
    
    assign Q = (j & not_Qold) | (k & Qold);
endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire Qold;
    wire not_Qold;
    
    assign not_Qold = ~Qold;
    
    d_flipflop d_ff (
        .clk(clk),
        .d(not_Qold),
        .q(Qold)
    );
    
    assign Q = (j & not_Qold) | (k & Qold);
endmodule
"
"    wire not_Qold;
    wire D;
    wire Qold;

    assign not_Qold = ~Qold;
    assign D = (j & not_Qold) | (k & Qold);

    always @(posedge clk) begin
        Qold <= D;
    end

    assign Q = Qold;
endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire D;
    wire Qold;

    assign not_Qold = ~Qold;
    assign D = (j & not_Qold) | (k & Qold);

    always @(posedge clk) begin
        Qold <= D;
    end

    assign Q = Qold;
endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire D;
    wire Qold;

    assign not_Qold = ~Qold;
    assign D = (j & not_Qold) | (k & Qold);

    always @(posedge clk) begin
        Qold <= D;
    end

    assign Q = Qold;
endmodule
"
"    wire q_old;
    wire not_q_old;
    wire d_input;

    assign not_q_old = ~q_old;

    // D flip-flop
    always @(posedge clk) begin
        if (j & k) begin
            d_input <= not_q_old;
        end else if (j) begin
            d_input <= 1'b1;
        end else if (k) begin
            d_input <= 1'b0;
        end else begin
            d_input <= q_old;
        end
    end

    assign Q = q_old;

endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire q_old;
    wire not_q_old;
    wire d_input;

    assign not_q_old = ~q_old;

    // D flip-flop
    always @(posedge clk) begin
        if (j & k) begin
            d_input <= not_q_old;
        end else if (j) begin
            d_input <= 1'b1;
        end else if (k) begin
            d_input <= 1'b0;
        end else begin
            d_input <= q_old;
        end
    end

    assign Q = q_old;

endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire q_old;
    wire not_q_old;
    wire d_input;

    assign not_q_old = ~q_old;

    // D flip-flop
    always @(posedge clk) begin
        if (j & k) begin
            d_input <= not_q_old;
        end else if (j) begin
            d_input <= 1'b1;
        end else if (k) begin
            d_input <= 1'b0;
        end else begin
            d_input <= q_old;
        end
    end

    assign Q = q_old;

endmodule
"
"    reg Q_reg, Q_next;

    always @(posedge clk) begin
        if (j & ~k)
            Q_next <= 1;
        else if (~j & k)
            Q_next <= 0;
        else if (j & k)
            Q_next <= ~Q_reg;
        else
            Q_next <= Q_reg;
    end

    assign Q = Q_reg;

    always @(posedge clk) begin
        Q_reg <= Q_next;
    end
endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    reg Q_reg, Q_next;

    always @(posedge clk) begin
        if (j & ~k)
            Q_next <= 1;
        else if (~j & k)
            Q_next <= 0;
        else if (j & k)
            Q_next <= ~Q_reg;
        else
            Q_next <= Q_reg;
    end

    assign Q = Q_reg;

    always @(posedge clk) begin
        Q_reg <= Q_next;
    end
endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    reg Q_reg, Q_next;

    always @(posedge clk) begin
        if (j & ~k)
            Q_next <= 1;
        else if (~j & k)
            Q_next <= 0;
        else if (j & k)
            Q_next <= ~Q_reg;
        else
            Q_next <= Q_reg;
    end

    assign Q = Q_reg;

    always @(posedge clk) begin
        Q_reg <= Q_next;
    end
endmodule
"
"    wire not_Qold;
    wire D_input;

    // Implementing the NOT gate for ~Qold
    assign not_Qold = ~Q;

    // Implementing the logic for D input based on J, K, and Qold
    assign D_input = (j & ~Q) | (k & Q);

    // Implementing D flip-flop
    always @(posedge clk) begin
        Q <= D_input;
    end

endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire D_input;

    // Implementing the NOT gate for ~Qold
    assign not_Qold = ~Q;

    // Implementing the logic for D input based on J, K, and Qold
    assign D_input = (j & ~Q) | (k & Q);

    // Implementing D flip-flop
    always @(posedge clk) begin
        Q <= D_input;
    end

endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire D_input;

    // Implementing the NOT gate for ~Qold
    assign not_Qold = ~Q;

    // Implementing the logic for D input based on J, K, and Qold
    assign D_input = (j & ~Q) | (k & Q);

    // Implementing D flip-flop
    always @(posedge clk) begin
        Q <= D_input;
    end

endmodule
"
"    wire d;
    wire not_qold;
    
    assign d = (j & ~Q) | (k & Q);
    assign not_qold = ~Q;
    
    d_flip_flop d_ff (
        .clk(clk),
        .d(d),
        .Q(Q)
    );
    
    not_gate not_g (
        .in(Q),
        .out(not_qold)
    );
endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire d;
    wire not_qold;
    
    assign d = (j & ~Q) | (k & Q);
    assign not_qold = ~Q;
    
    d_flip_flop d_ff (
        .clk(clk),
        .d(d),
        .Q(Q)
    );
    
    not_gate not_g (
        .in(Q),
        .out(not_qold)
    );
endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire d;
    wire not_qold;
    
    assign d = (j & ~Q) | (k & Q);
    assign not_qold = ~Q;
    
    d_flip_flop d_ff (
        .clk(clk),
        .d(d),
        .Q(Q)
    );
    
    not_gate not_g (
        .in(Q),
        .out(not_qold)
    );
endmodule
"
"    wire not_Qold;
    wire d_input;
    wire Qold;

    assign not_Qold = ~Qold;

    // Implementing the JK flip-flop using a D flip-flop and gates
    assign d_input = (j & not_Qold) | (k & Qold);

    d_flip_flop d_ff (
        .clk(clk),
        .d(d_input),
        .q(Qold)
    );

    assign Q = Qold;
endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire d_input;
    wire Qold;

    assign not_Qold = ~Qold;

    // Implementing the JK flip-flop using a D flip-flop and gates
    assign d_input = (j & not_Qold) | (k & Qold);

    d_flip_flop d_ff (
        .clk(clk),
        .d(d_input),
        .q(Qold)
    );

    assign Q = Qold;
endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire d_input;
    wire Qold;

    assign not_Qold = ~Qold;

    // Implementing the JK flip-flop using a D flip-flop and gates
    assign d_input = (j & not_Qold) | (k & Qold);

    d_flip_flop d_ff (
        .clk(clk),
        .d(d_input),
        .q(Qold)
    );

    assign Q = Qold;
endmodule
"
"    wire not_Qold;
    wire D;

    assign not_Qold = ~Q;

    // Implementing the JK flip-flop using a D flip-flop and gates
    assign D = (j & not_Qold) | (k & Q);
    
    always @(posedge clk) begin
        Q <= D;
    end
endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire D;

    assign not_Qold = ~Q;

    // Implementing the JK flip-flop using a D flip-flop and gates
    assign D = (j & not_Qold) | (k & Q);
    
    always @(posedge clk) begin
        Q <= D;
    end
endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire D;

    assign not_Qold = ~Q;

    // Implementing the JK flip-flop using a D flip-flop and gates
    assign D = (j & not_Qold) | (k & Q);
    
    always @(posedge clk) begin
        Q <= D;
    end
endmodule
"
"    wire not_Qold;
    wire D_input;

    // Invert Qold
    assign not_Qold = ~Q;

    // Implement JK flip-flop using D flip-flop and gates
    assign D_input = (j & not_Qold) | (k & Q);
    
    d_flip_flop d_ff (
        .clk(clk),
        .D(D_input),
        .Q(Q)
    );
    
endmodule
",-1.0,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire D_input;

    // Invert Qold
    assign not_Qold = ~Q;

    // Implement JK flip-flop using D flip-flop and gates
    assign D_input = (j & not_Qold) | (k & Q);
    
    d_flip_flop d_ff (
        .clk(clk),
        .D(D_input),
        .Q(Q)
    );
    
endmodule
","module top_module (
    input clk,
    input j,
    input k,
    output Q);

    wire not_Qold;
    wire D_input;

    // Invert Qold
    assign not_Qold = ~Q;

    // Implement JK flip-flop using D flip-flop and gates
    assign D_input = (j & not_Qold) | (k & Q);
    
    d_flip_flop d_ff (
        .clk(clk),
        .D(D_input),
        .Q(Q)
    );
    
endmodule
"
"
    reg [8:0] temp; // create a 9-bit temporary variable to store the result of addition
    assign temp = a + b; // perform addition of a and b
    
    // check for overflow by comparing the signs of a, b, and s
    always @* begin
        if ((a[7] == b[7]) && (a[7] != temp[7])) begin
            overflow = 1; // overflow has occurred
        end else begin
            overflow = 0; // no overflow
        end
    end
    
    assign s = temp[7:0]; // assign the lower 8 bits of temp to s
endmodule
",-1.0,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] temp; // create a 9-bit temporary variable to store the result of addition
    assign temp = a + b; // perform addition of a and b
    
    // check for overflow by comparing the signs of a, b, and s
    always @* begin
        if ((a[7] == b[7]) && (a[7] != temp[7])) begin
            overflow = 1; // overflow has occurred
        end else begin
            overflow = 0; // no overflow
        end
    end
    
    assign s = temp[7:0]; // assign the lower 8 bits of temp to s
endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] temp; // create a 9-bit temporary variable to store the result of addition
    assign temp = a + b; // perform addition of a and b
    
    // check for overflow by comparing the signs of a, b, and s
    always @* begin
        if ((a[7] == b[7]) && (a[7] != temp[7])) begin
            overflow = 1; // overflow has occurred
        end else begin
            overflow = 0; // no overflow
        end
    end
    
    assign s = temp[7:0]; // assign the lower 8 bits of temp to s
endmodule
"
"

    reg [8:0] sum;
    
    always @(*) begin
        sum = a + b;
        overflow = (a[7] & b[7] & ~sum[7]) | (~a[7] & ~b[7] & sum[7]);
        s = sum[7:0];
    end
    
endmodule
",-1.0,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //


    reg [8:0] sum;
    
    always @(*) begin
        sum = a + b;
        overflow = (a[7] & b[7] & ~sum[7]) | (~a[7] & ~b[7] & sum[7]);
        s = sum[7:0];
    end
    
endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //


    reg [8:0] sum;
    
    always @(*) begin
        sum = a + b;
        overflow = (a[7] & b[7] & ~sum[7]) | (~a[7] & ~b[7] & sum[7]);
        s = sum[7:0];
    end
    
endmodule
"
"
    reg [8:0] sum;

    always @* begin
        sum = a + b; // Perform addition
        if ((a[7] == b[7]) && (a[7] != sum[7])) begin
            overflow = 1; // Overflow has occurred
        end else begin
            overflow = 0; // No overflow
        end
        s = sum[7:0]; // Output the result
    end

endmodule
",-1.0,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum;

    always @* begin
        sum = a + b; // Perform addition
        if ((a[7] == b[7]) && (a[7] != sum[7])) begin
            overflow = 1; // Overflow has occurred
        end else begin
            overflow = 0; // No overflow
        end
        s = sum[7:0]; // Output the result
    end

endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum;

    always @* begin
        sum = a + b; // Perform addition
        if ((a[7] == b[7]) && (a[7] != sum[7])) begin
            overflow = 1; // Overflow has occurred
        end else begin
            overflow = 0; // No overflow
        end
        s = sum[7:0]; // Output the result
    end

endmodule
"
"
    reg [8:0] sum;
    
    always @* begin
        sum = a + b;
        s = sum[7:0]; // Extracting the lower 8 bits of the sum
        
        // Detecting overflow
        if ((a[7] == b[7]) && (a[7] != sum[8])) // If the signs of a and b are the same, but different from the sign of the sum
            overflow = 1;
        else
            overflow = 0;
    end
    
endmodule
",-1.0,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum;
    
    always @* begin
        sum = a + b;
        s = sum[7:0]; // Extracting the lower 8 bits of the sum
        
        // Detecting overflow
        if ((a[7] == b[7]) && (a[7] != sum[8])) // If the signs of a and b are the same, but different from the sign of the sum
            overflow = 1;
        else
            overflow = 0;
    end
    
endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum;
    
    always @* begin
        sum = a + b;
        s = sum[7:0]; // Extracting the lower 8 bits of the sum
        
        // Detecting overflow
        if ((a[7] == b[7]) && (a[7] != sum[8])) // If the signs of a and b are the same, but different from the sign of the sum
            overflow = 1;
        else
            overflow = 0;
    end
    
endmodule
"
"
    reg [8:0] temp; // temp variable to store the sum with an extra bit for overflow detection

    always @(*) begin
        temp = a + b; // perform addition
    end

    assign s = temp[7:0]; // output sum

    // Detect overflow by comparing signs of input and output numbers
    assign overflow = (a[7] & b[7] & !temp[8]) | (!a[7] & !b[7] & temp[8]);
endmodule
",-0.5,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] temp; // temp variable to store the sum with an extra bit for overflow detection

    always @(*) begin
        temp = a + b; // perform addition
    end

    assign s = temp[7:0]; // output sum

    // Detect overflow by comparing signs of input and output numbers
    assign overflow = (a[7] & b[7] & !temp[8]) | (!a[7] & !b[7] & temp[8]);
endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] temp; // temp variable to store the sum with an extra bit for overflow detection

    always @(*) begin
        temp = a + b; // perform addition
    end

    assign s = temp[7:0]; // output sum

    // Detect overflow by comparing signs of input and output numbers
    assign overflow = (a[7] & b[7] & !temp[8]) | (!a[7] & !b[7] & temp[8]);
endmodule
"
"
    reg [8:0] sum; // 9-bit sum to account for overflow
    reg overflow;

    always @(*) begin
        sum = a + b;
        if ((a[7] == b[7]) && (a[7] != sum[7])) begin
            overflow = 1;
        end else begin
            overflow = 0;
        end
    end

    assign s = sum[7:0];

endmodule
",1.0,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum; // 9-bit sum to account for overflow
    reg overflow;

    always @(*) begin
        sum = a + b;
        if ((a[7] == b[7]) && (a[7] != sum[7])) begin
            overflow = 1;
        end else begin
            overflow = 0;
        end
    end

    assign s = sum[7:0];

endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum; // 9-bit sum to account for overflow
    reg overflow;

    always @(*) begin
        sum = a + b;
        if ((a[7] == b[7]) && (a[7] != sum[7])) begin
            overflow = 1;
        end else begin
            overflow = 0;
        end
    end

    assign s = sum[7:0];

endmodule
"
"
    reg [8:0] sum;
    
    always @* begin
        sum = a + b;
        if ((a[7] & b[7] & !sum[7]) | (!a[7] & !b[7] & sum[7])) begin
            overflow = 1;
        end else begin
            overflow = 0;
        end
        s = sum[7:0];
    end
    
endmodule
",-1.0,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum;
    
    always @* begin
        sum = a + b;
        if ((a[7] & b[7] & !sum[7]) | (!a[7] & !b[7] & sum[7])) begin
            overflow = 1;
        end else begin
            overflow = 0;
        end
        s = sum[7:0];
    end
    
endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum;
    
    always @* begin
        sum = a + b;
        if ((a[7] & b[7] & !sum[7]) | (!a[7] & !b[7] & sum[7])) begin
            overflow = 1;
        end else begin
            overflow = 0;
        end
        s = sum[7:0];
    end
    
endmodule
"
"
    reg [8:0] temp; // To store the sum of a and b along with the carry bit
    reg overflow; // Flag to indicate overflow
    
    always @(*) begin
        temp = a + b;
        if ((a[7] & b[7] & ~temp[7]) | (~a[7] & ~b[7] & temp[7])) begin
            overflow = 1; // Overflow has occurred
        end else begin
            overflow = 0; // No overflow
        end
    end
    
    assign s = temp[7:0]; // Output the sum without the carry bit
endmodule
",1.0,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] temp; // To store the sum of a and b along with the carry bit
    reg overflow; // Flag to indicate overflow
    
    always @(*) begin
        temp = a + b;
        if ((a[7] & b[7] & ~temp[7]) | (~a[7] & ~b[7] & temp[7])) begin
            overflow = 1; // Overflow has occurred
        end else begin
            overflow = 0; // No overflow
        end
    end
    
    assign s = temp[7:0]; // Output the sum without the carry bit
endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] temp; // To store the sum of a and b along with the carry bit
    reg overflow; // Flag to indicate overflow
    
    always @(*) begin
        temp = a + b;
        if ((a[7] & b[7] & ~temp[7]) | (~a[7] & ~b[7] & temp[7])) begin
            overflow = 1; // Overflow has occurred
        end else begin
            overflow = 0; // No overflow
        end
    end
    
    assign s = temp[7:0]; // Output the sum without the carry bit
endmodule
"
"
    reg [8:0] sum; // 9-bit sum to account for overflow
    reg overflow;
    
    always @* begin
        sum = a + b;
        if ((a[7] == b[7]) && (a[7] != sum[7])) // Check for overflow
            overflow = 1;
        else
            overflow = 0;
        
        s = sum[7:0]; // Output only the 8-bit sum
    end
    
endmodule
",-1.0,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum; // 9-bit sum to account for overflow
    reg overflow;
    
    always @* begin
        sum = a + b;
        if ((a[7] == b[7]) && (a[7] != sum[7])) // Check for overflow
            overflow = 1;
        else
            overflow = 0;
        
        s = sum[7:0]; // Output only the 8-bit sum
    end
    
endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    reg [8:0] sum; // 9-bit sum to account for overflow
    reg overflow;
    
    always @* begin
        sum = a + b;
        if ((a[7] == b[7]) && (a[7] != sum[7])) // Check for overflow
            overflow = 1;
        else
            overflow = 0;
        
        s = sum[7:0]; // Output only the 8-bit sum
    end
    
endmodule
"
"
    wire [8:0] sum;
    wire sign_a, sign_b, sign_s;
    
    assign sum = a + b;
    assign s = sum[7:0];
    
    assign sign_a = a[7];
    assign sign_b = b[7];
    assign sign_s = sum[8];
    
    assign overflow = (sign_a == sign_b) && (sign_a != sign_s);
endmodule
",-0.5,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    wire [8:0] sum;
    wire sign_a, sign_b, sign_s;
    
    assign sum = a + b;
    assign s = sum[7:0];
    
    assign sign_a = a[7];
    assign sign_b = b[7];
    assign sign_s = sum[8];
    
    assign overflow = (sign_a == sign_b) && (sign_a != sign_s);
endmodule
","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    wire [8:0] sum;
    wire sign_a, sign_b, sign_s;
    
    assign sum = a + b;
    assign s = sum[7:0];
    
    assign sign_a = a[7];
    assign sign_b = b[7];
    assign sign_s = sum[8];
    
    assign overflow = (sign_a == sign_b) && (sign_a != sign_s);
endmodule
"
"// Implementing the K-map using multiplexers

// 4-to-1 Multiplexer for selecting rows based on c and d inputs
module mux_4to1 (
    input [3:0] in0,
    input [3:0] in1,
    input [3:0] in2,
    input [3:0] in3,
    input [1:0] sel,
    output [3:0] out
);
    wire [3:0] mux_ab, mux_ab_bar;
    
    // 2-to-1 Multiplexers for selecting between a and a_bar
    mux_2to1 mux_a0 (in0, in1, sel[0], mux_ab[0]);
    mux_2to1 mux_a1 (in2, in3, sel[0], mux_ab[1]);
    mux_2to1 mux_a2 (in0, in1, sel[0], mux_ab[2]);
    mux_2to1 mux_a3 (in2, in3, sel[0], mux_ab[3]);
    
    // 2-to-1 Multiplexers for selecting between b and b_bar
    mux_2to1 mux_b0 (mux_ab[0], mux_ab[1], sel[1], mux_ab_bar[0]);
    mux_2to1 mux_b1 (mux_ab[2], mux_ab[3], sel[1], mux_ab_bar[1]);
    
    // 2-to-1 Multiplexer for selecting between rows based on c and d
    mux_2to1 mux_row (mux_ab_bar[0], mux_ab_bar[1], {c, d}, out);
endmodule
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// 4-to-1 Multiplexer for selecting rows based on c and d inputs
module mux_4to1 (
    input [3:0] in0,
    input [3:0] in1,
    input [3:0] in2,
    input [3:0] in3,
    input [1:0] sel,
    output [3:0] out
);
    wire [3:0] mux_ab, mux_ab_bar;
    
    // 2-to-1 Multiplexers for selecting between a and a_bar
    mux_2to1 mux_a0 (in0, in1, sel[0], mux_ab[0]);
    mux_2to1 mux_a1 (in2, in3, sel[0], mux_ab[1]);
    mux_2to1 mux_a2 (in0, in1, sel[0], mux_ab[2]);
    mux_2to1 mux_a3 (in2, in3, sel[0], mux_ab[3]);
    
    // 2-to-1 Multiplexers for selecting between b and b_bar
    mux_2to1 mux_b0 (mux_ab[0], mux_ab[1], sel[1], mux_ab_bar[0]);
    mux_2to1 mux_b1 (mux_ab[2], mux_ab[3], sel[1], mux_ab_bar[1]);
    
    // 2-to-1 Multiplexer for selecting between rows based on c and d
    mux_2to1 mux_row (mux_ab_bar[0], mux_ab_bar[1], {c, d}, out);
endmodule
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// 4-to-1 Multiplexer for selecting rows based on c and d inputs
module mux_4to1 (
    input [3:0] in0,
    input [3:0] in1,
    input [3:0] in2,
    input [3:0] in3,
    input [1:0] sel,
    output [3:0] out
);
    wire [3:0] mux_ab, mux_ab_bar;
    
    // 2-to-1 Multiplexers for selecting between a and a_bar
    mux_2to1 mux_a0 (in0, in1, sel[0], mux_ab[0]);
    mux_2to1 mux_a1 (in2, in3, sel[0], mux_ab[1]);
    mux_2to1 mux_a2 (in0, in1, sel[0], mux_ab[2]);
    mux_2to1 mux_a3 (in2, in3, sel[0], mux_ab[3]);
    
    // 2-to-1 Multiplexers for selecting between b and b_bar
    mux_2to1 mux_b0 (mux_ab[0], mux_ab[1], sel[1], mux_ab_bar[0]);
    mux_2to1 mux_b1 (mux_ab[2], mux_ab[3], sel[1], mux_ab_bar[1]);
    
    // 2-to-1 Multiplexer for selecting between rows based on c and d
    mux_2to1 mux_row (mux_ab_bar[0], mux_ab_bar[1], {c, d}, out);
endmodule
"
"
    wire [3:0] mux_out;

    // 4-to-1 multiplexer
    four_to_one_mux mux_4to1 (
        .a(c),
        .b(d),
        .x(mux_out[0]),
        .y(mux_out[1]),
        .z(mux_out[2]),
        .w(mux_out[3])
    );

    // 2-to-1 multiplexers
    two_to_one_mux mux_1 (
        .a(mux_out[0]),
        .b(mux_out[1]),
        .s(c),
        .out(mux_in[0])
    );

    two_to_one_mux mux_2 (
        .a(mux_out[2]),
        .b(mux_out[3]),
        .s(c),
        .out(mux_in[1])
    );

    two_to_one_mux mux_3 (
        .a(mux_out[0]),
        .b(mux_out[2]),
        .s(d),
        .out(mux_in[2])
    );

    two_to_one_mux mux_4 (
        .a(mux_out[1]),
        .b(mux_out[3]),
        .s(d),
        .out(mux_in[3])
    );
endmodule
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);


    wire [3:0] mux_out;

    // 4-to-1 multiplexer
    four_to_one_mux mux_4to1 (
        .a(c),
        .b(d),
        .x(mux_out[0]),
        .y(mux_out[1]),
        .z(mux_out[2]),
        .w(mux_out[3])
    );

    // 2-to-1 multiplexers
    two_to_one_mux mux_1 (
        .a(mux_out[0]),
        .b(mux_out[1]),
        .s(c),
        .out(mux_in[0])
    );

    two_to_one_mux mux_2 (
        .a(mux_out[2]),
        .b(mux_out[3]),
        .s(c),
        .out(mux_in[1])
    );

    two_to_one_mux mux_3 (
        .a(mux_out[0]),
        .b(mux_out[2]),
        .s(d),
        .out(mux_in[2])
    );

    two_to_one_mux mux_4 (
        .a(mux_out[1]),
        .b(mux_out[3]),
        .s(d),
        .out(mux_in[3])
    );
endmodule
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);


    wire [3:0] mux_out;

    // 4-to-1 multiplexer
    four_to_one_mux mux_4to1 (
        .a(c),
        .b(d),
        .x(mux_out[0]),
        .y(mux_out[1]),
        .z(mux_out[2]),
        .w(mux_out[3])
    );

    // 2-to-1 multiplexers
    two_to_one_mux mux_1 (
        .a(mux_out[0]),
        .b(mux_out[1]),
        .s(c),
        .out(mux_in[0])
    );

    two_to_one_mux mux_2 (
        .a(mux_out[2]),
        .b(mux_out[3]),
        .s(c),
        .out(mux_in[1])
    );

    two_to_one_mux mux_3 (
        .a(mux_out[0]),
        .b(mux_out[2]),
        .s(d),
        .out(mux_in[2])
    );

    two_to_one_mux mux_4 (
        .a(mux_out[1]),
        .b(mux_out[3]),
        .s(d),
        .out(mux_in[3])
    );
endmodule
"
"    wire [3:0] mux_out;

    // Implementing the K-map using 4-to-1 multiplexer
    // For c'd'
    wire [1:0] mux_cd_1;
    wire [1:0] mux_cd_2;
    wire mux_cd;
    assign mux_cd_1 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_2 = (d) ? 2'b10 : 2'b01;
    assign mux_cd = (c) ? mux_cd_2 : mux_cd_1;
    
    // For cd'
    wire [1:0] mux_cd_3;
    wire [1:0] mux_cd_4;
    wire mux_cd_5;
    assign mux_cd_3 = (d) ? 2'b10 : 2'b01;
    assign mux_cd_4 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_5 = (c) ? mux_cd_4 : mux_cd_3;
    
    // For c'd
    wire [1:0] mux_cd_6;
    wire [1:0] mux_cd_7;
    wire mux_cd_8;
    assign mux_cd_6 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_7 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_8 = (c) ? mux_cd_7 : mux_cd_6;
    
    // For c'd'
    wire [1:0] mux_cd_9;
    wire [1:0] mux_cd_10;
    wire mux_cd_11;
    assign mux_cd_9 = (d) ? 2'b10 : 2'b01;
    assign mux_cd_10 = (d) ? 2'b10 : 2'b01;
    assign mux_cd_11 = (c) ? mux_cd_10 : mux_cd_9;
    
    // Connecting the outputs of the 4-to-1 multiplexer
    assign mux_out[0] = (mux_cd) ? 1'b1 : 1'b0;
    assign mux_out[1] = (mux_cd_5) ? 1'b1 : 1'b0;
    assign mux_out[2] = (mux_cd_8) ? 1'b1 : 1'b0;
    assign mux_out[3] = (mux_cd_11) ? 1'b1 : 1'b0;

    // Output of the top module
    assign mux_in = mux_out;
endmodule
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

    wire [3:0] mux_out;

    // Implementing the K-map using 4-to-1 multiplexer
    // For c'd'
    wire [1:0] mux_cd_1;
    wire [1:0] mux_cd_2;
    wire mux_cd;
    assign mux_cd_1 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_2 = (d) ? 2'b10 : 2'b01;
    assign mux_cd = (c) ? mux_cd_2 : mux_cd_1;
    
    // For cd'
    wire [1:0] mux_cd_3;
    wire [1:0] mux_cd_4;
    wire mux_cd_5;
    assign mux_cd_3 = (d) ? 2'b10 : 2'b01;
    assign mux_cd_4 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_5 = (c) ? mux_cd_4 : mux_cd_3;
    
    // For c'd
    wire [1:0] mux_cd_6;
    wire [1:0] mux_cd_7;
    wire mux_cd_8;
    assign mux_cd_6 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_7 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_8 = (c) ? mux_cd_7 : mux_cd_6;
    
    // For c'd'
    wire [1:0] mux_cd_9;
    wire [1:0] mux_cd_10;
    wire mux_cd_11;
    assign mux_cd_9 = (d) ? 2'b10 : 2'b01;
    assign mux_cd_10 = (d) ? 2'b10 : 2'b01;
    assign mux_cd_11 = (c) ? mux_cd_10 : mux_cd_9;
    
    // Connecting the outputs of the 4-to-1 multiplexer
    assign mux_out[0] = (mux_cd) ? 1'b1 : 1'b0;
    assign mux_out[1] = (mux_cd_5) ? 1'b1 : 1'b0;
    assign mux_out[2] = (mux_cd_8) ? 1'b1 : 1'b0;
    assign mux_out[3] = (mux_cd_11) ? 1'b1 : 1'b0;

    // Output of the top module
    assign mux_in = mux_out;
endmodule
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

    wire [3:0] mux_out;

    // Implementing the K-map using 4-to-1 multiplexer
    // For c'd'
    wire [1:0] mux_cd_1;
    wire [1:0] mux_cd_2;
    wire mux_cd;
    assign mux_cd_1 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_2 = (d) ? 2'b10 : 2'b01;
    assign mux_cd = (c) ? mux_cd_2 : mux_cd_1;
    
    // For cd'
    wire [1:0] mux_cd_3;
    wire [1:0] mux_cd_4;
    wire mux_cd_5;
    assign mux_cd_3 = (d) ? 2'b10 : 2'b01;
    assign mux_cd_4 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_5 = (c) ? mux_cd_4 : mux_cd_3;
    
    // For c'd
    wire [1:0] mux_cd_6;
    wire [1:0] mux_cd_7;
    wire mux_cd_8;
    assign mux_cd_6 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_7 = (d) ? 2'b01 : 2'b10;
    assign mux_cd_8 = (c) ? mux_cd_7 : mux_cd_6;
    
    // For c'd'
    wire [1:0] mux_cd_9;
    wire [1:0] mux_cd_10;
    wire mux_cd_11;
    assign mux_cd_9 = (d) ? 2'b10 : 2'b01;
    assign mux_cd_10 = (d) ? 2'b10 : 2'b01;
    assign mux_cd_11 = (c) ? mux_cd_10 : mux_cd_9;
    
    // Connecting the outputs of the 4-to-1 multiplexer
    assign mux_out[0] = (mux_cd) ? 1'b1 : 1'b0;
    assign mux_out[1] = (mux_cd_5) ? 1'b1 : 1'b0;
    assign mux_out[2] = (mux_cd_8) ? 1'b1 : 1'b0;
    assign mux_out[3] = (mux_cd_11) ? 1'b1 : 1'b0;

    // Output of the top module
    assign mux_in = mux_out;
endmodule
"
"// Using the K-map, we can simplify the expression to:
// mux_in = c'd' + c'd + cd

// Implementing the simplified expression using multiplexers:

// 4-to-1 Mux input selection:
// a = c
// b = d

// 4-to-1 Mux output:
wire [3:0] mux_out;
wire [1:0] mux_out_2;

// 4-to-1 Mux
four_to_one_mux mux_4to1 (
    .a(c),
    .b(d),
    .sel(a),
    .out(mux_out)
);

// 2-to-1 Mux for c'd' and c'd
two_to_one_mux mux_2to1_1 (
    .a(mux_out[3]),
    .b(mux_out[2]),
    .sel(b),
    .out(mux_out_2[0])
);

// 2-to-1 Mux for cd
two_to_one_mux mux_2to1_2 (
    .a(mux_out[1]),
    .b(mux_out[0]),
    .sel(b),
    .out(mux_out_2[1])
);

assign mux_in = mux_out_2;
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Using the K-map, we can simplify the expression to:
// mux_in = c'd' + c'd + cd

// Implementing the simplified expression using multiplexers:

// 4-to-1 Mux input selection:
// a = c
// b = d

// 4-to-1 Mux output:
wire [3:0] mux_out;
wire [1:0] mux_out_2;

// 4-to-1 Mux
four_to_one_mux mux_4to1 (
    .a(c),
    .b(d),
    .sel(a),
    .out(mux_out)
);

// 2-to-1 Mux for c'd' and c'd
two_to_one_mux mux_2to1_1 (
    .a(mux_out[3]),
    .b(mux_out[2]),
    .sel(b),
    .out(mux_out_2[0])
);

// 2-to-1 Mux for cd
two_to_one_mux mux_2to1_2 (
    .a(mux_out[1]),
    .b(mux_out[0]),
    .sel(b),
    .out(mux_out_2[1])
);

assign mux_in = mux_out_2;
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Using the K-map, we can simplify the expression to:
// mux_in = c'd' + c'd + cd

// Implementing the simplified expression using multiplexers:

// 4-to-1 Mux input selection:
// a = c
// b = d

// 4-to-1 Mux output:
wire [3:0] mux_out;
wire [1:0] mux_out_2;

// 4-to-1 Mux
four_to_one_mux mux_4to1 (
    .a(c),
    .b(d),
    .sel(a),
    .out(mux_out)
);

// 2-to-1 Mux for c'd' and c'd
two_to_one_mux mux_2to1_1 (
    .a(mux_out[3]),
    .b(mux_out[2]),
    .sel(b),
    .out(mux_out_2[0])
);

// 2-to-1 Mux for cd
two_to_one_mux mux_2to1_2 (
    .a(mux_out[1]),
    .b(mux_out[0]),
    .sel(b),
    .out(mux_out_2[1])
);

assign mux_in = mux_out_2;
"
"// Implementing the K-map using multiplexers

// 2-to-1 multiplexer for c'd'
wire m0, m1, m2;
assign m0 = c & d;
assign m1 = c & ~d;
assign m2 = ~c & d;
assign mux_in[0] = m0 | m1 | m2;

// 2-to-1 multiplexer for c'd
wire m3, m4, m5;
assign m3 = c & d;
assign m4 = c & ~d;
assign m5 = ~c & d;
assign mux_in[1] = m3 | m4 | m5;

// 2-to-1 multiplexer for cd
wire m6, m7, m8;
assign m6 = c & d;
assign m7 = c & ~d;
assign m8 = ~c & d;
assign mux_in[2] = m6 | m7 | m8;

// 2-to-1 multiplexer for cd'
wire m9, m10, m11;
assign m9 = c & d;
assign m10 = c & ~d;
assign m11 = ~c & d;
assign mux_in[3] = m9 | m10 | m11;

endmodule
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// 2-to-1 multiplexer for c'd'
wire m0, m1, m2;
assign m0 = c & d;
assign m1 = c & ~d;
assign m2 = ~c & d;
assign mux_in[0] = m0 | m1 | m2;

// 2-to-1 multiplexer for c'd
wire m3, m4, m5;
assign m3 = c & d;
assign m4 = c & ~d;
assign m5 = ~c & d;
assign mux_in[1] = m3 | m4 | m5;

// 2-to-1 multiplexer for cd
wire m6, m7, m8;
assign m6 = c & d;
assign m7 = c & ~d;
assign m8 = ~c & d;
assign mux_in[2] = m6 | m7 | m8;

// 2-to-1 multiplexer for cd'
wire m9, m10, m11;
assign m9 = c & d;
assign m10 = c & ~d;
assign m11 = ~c & d;
assign mux_in[3] = m9 | m10 | m11;

endmodule
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// 2-to-1 multiplexer for c'd'
wire m0, m1, m2;
assign m0 = c & d;
assign m1 = c & ~d;
assign m2 = ~c & d;
assign mux_in[0] = m0 | m1 | m2;

// 2-to-1 multiplexer for c'd
wire m3, m4, m5;
assign m3 = c & d;
assign m4 = c & ~d;
assign m5 = ~c & d;
assign mux_in[1] = m3 | m4 | m5;

// 2-to-1 multiplexer for cd
wire m6, m7, m8;
assign m6 = c & d;
assign m7 = c & ~d;
assign m8 = ~c & d;
assign mux_in[2] = m6 | m7 | m8;

// 2-to-1 multiplexer for cd'
wire m9, m10, m11;
assign m9 = c & d;
assign m10 = c & ~d;
assign m11 = ~c & d;
assign mux_in[3] = m9 | m10 | m11;

endmodule
"
"// Implementing the K-map using multiplexers

// Using 4-to-1 mux for each row of the K-map
module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// First row of the K-map
wire [1:0] mux1_out;
wire [1:0] mux2_out;

// Second row of the K-map
wire [1:0] mux3_out;
wire [1:0] mux4_out;

// Third row of the K-map
wire [1:0] mux5_out;
wire [1:0] mux6_out;

// Fourth row of the K-map
wire [1:0] mux7_out;
wire [1:0] mux8_out;

// Implementing 4-to-1 mux for each row
four_to_one_mux mux1 (.a(c), .b(d), .sel({1'b0, 1'b0}), .out(mux1_out[0]));
four_to_one_mux mux2 (.a(c), .b(d), .sel({1'b0, 1'b1}), .out(mux1_out[1]));

four_to_one_mux mux3 (.a(c), .b(d), .sel({1'b1, 1'b0}), .out(mux2_out[0]));
four_to_one_mux mux4 (.a(c), .b(d), .sel({1'b1, 1'b1}), .out(mux2_out[1]));

four_to_one_mux mux5 (.a(c), .b(d), .sel({1'b0, 1'b0}), .out(mux3_out[0]));
four_to_one_mux mux6 (.a(c), .b(d), .sel({1'b0, 1'b1}), .out(mux3_out[1]));

four_to_one_mux mux7 (.a(c), .b(d), .sel({1'b1, 1'b0}), .out(mux4_out[0]));
four_to_one_mux mux8 (.a(c), .b(d), .sel({1'b1, 1'b1}), .out(mux4_out[1]));

// Implementing 2-to-1 mux to select the correct row output
two_to_one_mux mux9 (.a(mux1_out[0]), .b(mux2_out[0]), .sel(d), .out(mux5_out[0]));
two_to_one_mux mux10 (.a(mux1_out[1]), .b(mux2_out[1]), .sel(d), .out(mux5_out[1]));

two_to_one_mux mux11 (.a(mux3_out[0]), .b(mux4_out[0]), .sel(d), .out(mux6_out[0]));
two_to_one_mux mux12 (.a(mux3_out[1]), .b(mux4_out[1]), .sel(d), .out(mux6_out[1]));

two_to_one_mux mux13 (.a(mux5_out[0]), .b(mux6_out[0]), .sel(c), .out(mux7_out[0]));
two_to_one_mux mux14 (.a(mux5_out[1]), .b(mux6_out[1]), .sel(c), .out(mux7_out[1]));

two_to_one_mux mux15 (.a(mux7_out[0]), .b(mux8_out[0]), .sel(c), .out(mux_in[0]));
two_to_one_mux mux16 (.a(mux7_out[1]), .b(mux8_out[1]), .sel(c), .out(mux_in[1]));

endmodule
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// Using 4-to-1 mux for each row of the K-map
module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// First row of the K-map
wire [1:0] mux1_out;
wire [1:0] mux2_out;

// Second row of the K-map
wire [1:0] mux3_out;
wire [1:0] mux4_out;

// Third row of the K-map
wire [1:0] mux5_out;
wire [1:0] mux6_out;

// Fourth row of the K-map
wire [1:0] mux7_out;
wire [1:0] mux8_out;

// Implementing 4-to-1 mux for each row
four_to_one_mux mux1 (.a(c), .b(d), .sel({1'b0, 1'b0}), .out(mux1_out[0]));
four_to_one_mux mux2 (.a(c), .b(d), .sel({1'b0, 1'b1}), .out(mux1_out[1]));

four_to_one_mux mux3 (.a(c), .b(d), .sel({1'b1, 1'b0}), .out(mux2_out[0]));
four_to_one_mux mux4 (.a(c), .b(d), .sel({1'b1, 1'b1}), .out(mux2_out[1]));

four_to_one_mux mux5 (.a(c), .b(d), .sel({1'b0, 1'b0}), .out(mux3_out[0]));
four_to_one_mux mux6 (.a(c), .b(d), .sel({1'b0, 1'b1}), .out(mux3_out[1]));

four_to_one_mux mux7 (.a(c), .b(d), .sel({1'b1, 1'b0}), .out(mux4_out[0]));
four_to_one_mux mux8 (.a(c), .b(d), .sel({1'b1, 1'b1}), .out(mux4_out[1]));

// Implementing 2-to-1 mux to select the correct row output
two_to_one_mux mux9 (.a(mux1_out[0]), .b(mux2_out[0]), .sel(d), .out(mux5_out[0]));
two_to_one_mux mux10 (.a(mux1_out[1]), .b(mux2_out[1]), .sel(d), .out(mux5_out[1]));

two_to_one_mux mux11 (.a(mux3_out[0]), .b(mux4_out[0]), .sel(d), .out(mux6_out[0]));
two_to_one_mux mux12 (.a(mux3_out[1]), .b(mux4_out[1]), .sel(d), .out(mux6_out[1]));

two_to_one_mux mux13 (.a(mux5_out[0]), .b(mux6_out[0]), .sel(c), .out(mux7_out[0]));
two_to_one_mux mux14 (.a(mux5_out[1]), .b(mux6_out[1]), .sel(c), .out(mux7_out[1]));

two_to_one_mux mux15 (.a(mux7_out[0]), .b(mux8_out[0]), .sel(c), .out(mux_in[0]));
two_to_one_mux mux16 (.a(mux7_out[1]), .b(mux8_out[1]), .sel(c), .out(mux_in[1]));

endmodule
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// Using 4-to-1 mux for each row of the K-map
module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// First row of the K-map
wire [1:0] mux1_out;
wire [1:0] mux2_out;

// Second row of the K-map
wire [1:0] mux3_out;
wire [1:0] mux4_out;

// Third row of the K-map
wire [1:0] mux5_out;
wire [1:0] mux6_out;

// Fourth row of the K-map
wire [1:0] mux7_out;
wire [1:0] mux8_out;

// Implementing 4-to-1 mux for each row
four_to_one_mux mux1 (.a(c), .b(d), .sel({1'b0, 1'b0}), .out(mux1_out[0]));
four_to_one_mux mux2 (.a(c), .b(d), .sel({1'b0, 1'b1}), .out(mux1_out[1]));

four_to_one_mux mux3 (.a(c), .b(d), .sel({1'b1, 1'b0}), .out(mux2_out[0]));
four_to_one_mux mux4 (.a(c), .b(d), .sel({1'b1, 1'b1}), .out(mux2_out[1]));

four_to_one_mux mux5 (.a(c), .b(d), .sel({1'b0, 1'b0}), .out(mux3_out[0]));
four_to_one_mux mux6 (.a(c), .b(d), .sel({1'b0, 1'b1}), .out(mux3_out[1]));

four_to_one_mux mux7 (.a(c), .b(d), .sel({1'b1, 1'b0}), .out(mux4_out[0]));
four_to_one_mux mux8 (.a(c), .b(d), .sel({1'b1, 1'b1}), .out(mux4_out[1]));

// Implementing 2-to-1 mux to select the correct row output
two_to_one_mux mux9 (.a(mux1_out[0]), .b(mux2_out[0]), .sel(d), .out(mux5_out[0]));
two_to_one_mux mux10 (.a(mux1_out[1]), .b(mux2_out[1]), .sel(d), .out(mux5_out[1]));

two_to_one_mux mux11 (.a(mux3_out[0]), .b(mux4_out[0]), .sel(d), .out(mux6_out[0]));
two_to_one_mux mux12 (.a(mux3_out[1]), .b(mux4_out[1]), .sel(d), .out(mux6_out[1]));

two_to_one_mux mux13 (.a(mux5_out[0]), .b(mux6_out[0]), .sel(c), .out(mux7_out[0]));
two_to_one_mux mux14 (.a(mux5_out[1]), .b(mux6_out[1]), .sel(c), .out(mux7_out[1]));

two_to_one_mux mux15 (.a(mux7_out[0]), .b(mux8_out[0]), .sel(c), .out(mux_in[0]));
two_to_one_mux mux16 (.a(mux7_out[1]), .b(mux8_out[1]), .sel(c), .out(mux_in[1]));

endmodule
"
"// Implementing the K-map using multiplexers

// 4-to-1 multiplexer
module mux4to1 (
    input [3:0] in,
    input [1:0] sel,
    output out
);

// 2-to-1 multiplexer
module mux2to1 (
    input [1:0] in,
    input sel,
    output out
);

// Instantiate 4-to-1 mux
mux4to1 mux4 (
    .in({1'b1, c'd', c'd, c'd'}),
    .sel({c, d}),
    .out(mux_in)
);

// Instantiate 2-to-1 muxes for further reduction
mux2to1 mux_ab (
    .in({mux_in[3], mux_in[2]}),
    .sel(a),
    .out(mux_out1)
);

mux2to1 mux_cd (
    .in({mux_in[1], mux_in[0]}),
    .sel(b),
    .out(mux_out2)
);

assign mux_in = (mux_out1 << 2) | mux_out2;

endmodule
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// 4-to-1 multiplexer
module mux4to1 (
    input [3:0] in,
    input [1:0] sel,
    output out
);

// 2-to-1 multiplexer
module mux2to1 (
    input [1:0] in,
    input sel,
    output out
);

// Instantiate 4-to-1 mux
mux4to1 mux4 (
    .in({1'b1, c'd', c'd, c'd'}),
    .sel({c, d}),
    .out(mux_in)
);

// Instantiate 2-to-1 muxes for further reduction
mux2to1 mux_ab (
    .in({mux_in[3], mux_in[2]}),
    .sel(a),
    .out(mux_out1)
);

mux2to1 mux_cd (
    .in({mux_in[1], mux_in[0]}),
    .sel(b),
    .out(mux_out2)
);

assign mux_in = (mux_out1 << 2) | mux_out2;

endmodule
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// 4-to-1 multiplexer
module mux4to1 (
    input [3:0] in,
    input [1:0] sel,
    output out
);

// 2-to-1 multiplexer
module mux2to1 (
    input [1:0] in,
    input sel,
    output out
);

// Instantiate 4-to-1 mux
mux4to1 mux4 (
    .in({1'b1, c'd', c'd, c'd'}),
    .sel({c, d}),
    .out(mux_in)
);

// Instantiate 2-to-1 muxes for further reduction
mux2to1 mux_ab (
    .in({mux_in[3], mux_in[2]}),
    .sel(a),
    .out(mux_out1)
);

mux2to1 mux_cd (
    .in({mux_in[1], mux_in[0]}),
    .sel(b),
    .out(mux_out2)
);

assign mux_in = (mux_out1 << 2) | mux_out2;

endmodule
"
"```verilog
module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

wire [3:0] m0, m1, m2, m3;

// Implementing the K-map using 2-to-1 multiplexers
// For m0
assign m0 = d ? 4'b1110 : 4'b0010;
// For m1
assign m1 = d ? 4'b1101 : 4'b0000;
// For m2
assign m2 = d ? 4'b1010 : 4'b1001;
// For m3
assign m3 = d ? 4'b0110 : 4'b0101;

// Using a 4-to-1 multiplexer to select the correct output based on c
// Output of the 4-to-1 mux is mux_in
// Inputs to the 4-to-1 mux are m0, m1, m2, m3
four_to_one_mux_4bit mux (
    .a({m0, m1, m2, m3}),
    .b({c, c, c, c}),
    .mux_out(mux_in)
);

endmodule
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

```verilog
module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

wire [3:0] m0, m1, m2, m3;

// Implementing the K-map using 2-to-1 multiplexers
// For m0
assign m0 = d ? 4'b1110 : 4'b0010;
// For m1
assign m1 = d ? 4'b1101 : 4'b0000;
// For m2
assign m2 = d ? 4'b1010 : 4'b1001;
// For m3
assign m3 = d ? 4'b0110 : 4'b0101;

// Using a 4-to-1 multiplexer to select the correct output based on c
// Output of the 4-to-1 mux is mux_in
// Inputs to the 4-to-1 mux are m0, m1, m2, m3
four_to_one_mux_4bit mux (
    .a({m0, m1, m2, m3}),
    .b({c, c, c, c}),
    .mux_out(mux_in)
);

endmodule
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

```verilog
module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

wire [3:0] m0, m1, m2, m3;

// Implementing the K-map using 2-to-1 multiplexers
// For m0
assign m0 = d ? 4'b1110 : 4'b0010;
// For m1
assign m1 = d ? 4'b1101 : 4'b0000;
// For m2
assign m2 = d ? 4'b1010 : 4'b1001;
// For m3
assign m3 = d ? 4'b0110 : 4'b0101;

// Using a 4-to-1 multiplexer to select the correct output based on c
// Output of the 4-to-1 mux is mux_in
// Inputs to the 4-to-1 mux are m0, m1, m2, m3
four_to_one_mux_4bit mux (
    .a({m0, m1, m2, m3}),
    .b({c, c, c, c}),
    .mux_out(mux_in)
);

endmodule
"
"
    wire [3:0] mux_out;
    
    // Implementing the K-map using 4-to-1 multiplexer and 2-to-1 multiplexers
    // First stage of 2-to-1 multiplexers
    wire [1:0] m0, m1, m2, m3;
    wire [1:0] n0, n1, n2, n3;
    
    // Second stage of 2-to-1 multiplexers
    wire [1:0] p0, p1;
    wire [1:0] q0;
    
    // Connecting the 4-to-1 multiplexer
    four_to_one_mux mux (
        .a(a),
        .b(b),
        .x({m0[0], m1[0], m2[0], m3[0]}),
        .y(mux_out[0])
    );
    
    // Implementing the first stage of 2-to-1 multiplexers
    two_to_one_mux mux0 (
        .a(c),
        .b(d),
        .x({m0[1], m1[1], m2[1], m3[1]}),
        .y({n0[0], n1[0], n2[0], n3[0]})
    );
    
    // Implementing the second stage of 2-to-1 multiplexers
    two_to_one_mux mux1 (
        .a(n0[0]),
        .b(n1[0]),
        .x({p0[0], p1[0]}),
        .y({q0[0]})
    );
    
    // Final output
    assign mux_in = mux_out;
endmodule
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);


    wire [3:0] mux_out;
    
    // Implementing the K-map using 4-to-1 multiplexer and 2-to-1 multiplexers
    // First stage of 2-to-1 multiplexers
    wire [1:0] m0, m1, m2, m3;
    wire [1:0] n0, n1, n2, n3;
    
    // Second stage of 2-to-1 multiplexers
    wire [1:0] p0, p1;
    wire [1:0] q0;
    
    // Connecting the 4-to-1 multiplexer
    four_to_one_mux mux (
        .a(a),
        .b(b),
        .x({m0[0], m1[0], m2[0], m3[0]}),
        .y(mux_out[0])
    );
    
    // Implementing the first stage of 2-to-1 multiplexers
    two_to_one_mux mux0 (
        .a(c),
        .b(d),
        .x({m0[1], m1[1], m2[1], m3[1]}),
        .y({n0[0], n1[0], n2[0], n3[0]})
    );
    
    // Implementing the second stage of 2-to-1 multiplexers
    two_to_one_mux mux1 (
        .a(n0[0]),
        .b(n1[0]),
        .x({p0[0], p1[0]}),
        .y({q0[0]})
    );
    
    // Final output
    assign mux_in = mux_out;
endmodule
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);


    wire [3:0] mux_out;
    
    // Implementing the K-map using 4-to-1 multiplexer and 2-to-1 multiplexers
    // First stage of 2-to-1 multiplexers
    wire [1:0] m0, m1, m2, m3;
    wire [1:0] n0, n1, n2, n3;
    
    // Second stage of 2-to-1 multiplexers
    wire [1:0] p0, p1;
    wire [1:0] q0;
    
    // Connecting the 4-to-1 multiplexer
    four_to_one_mux mux (
        .a(a),
        .b(b),
        .x({m0[0], m1[0], m2[0], m3[0]}),
        .y(mux_out[0])
    );
    
    // Implementing the first stage of 2-to-1 multiplexers
    two_to_one_mux mux0 (
        .a(c),
        .b(d),
        .x({m0[1], m1[1], m2[1], m3[1]}),
        .y({n0[0], n1[0], n2[0], n3[0]})
    );
    
    // Implementing the second stage of 2-to-1 multiplexers
    two_to_one_mux mux1 (
        .a(n0[0]),
        .b(n1[0]),
        .x({p0[0], p1[0]}),
        .y({q0[0]})
    );
    
    // Final output
    assign mux_in = mux_out;
endmodule
"
"// Implementing the K-map using multiplexers

// 2-to-1 Mux for c'd'
wire mux_cd_d = d ? 1'b1 : 1'b0;
wire mux_cd_c = c ? mux_cd_d : 1'b1;

// 2-to-1 Mux for c'd
wire mux_cd_not_d = ~d ? 1'b1 : 1'b0;
wire mux_cd_not_c = c ? 1'b0 : mux_cd_not_d;

// 2-to-1 Mux for cd
wire mux_c_not_d = ~d ? 1'b1 : 1'b0;
wire mux_c_not_c = ~c ? 1'b0 : mux_c_not_d;

// 2-to-1 Mux for cd'
wire mux_c_d = d ? 1'b0 : 1'b1;
wire mux_c_not_d2 = ~d ? 1'b1 : 1'b0;
wire mux_c_c = ~c ? mux_c_not_d2 : mux_c_d;

// 4-to-1 Mux for selecting between c'd', c'd, cd, and cd'
wire [3:0] mux_in = {mux_cd_c, mux_cd_not_c, mux_c_not_c, mux_c_c};

endmodule
",-1.0,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// 2-to-1 Mux for c'd'
wire mux_cd_d = d ? 1'b1 : 1'b0;
wire mux_cd_c = c ? mux_cd_d : 1'b1;

// 2-to-1 Mux for c'd
wire mux_cd_not_d = ~d ? 1'b1 : 1'b0;
wire mux_cd_not_c = c ? 1'b0 : mux_cd_not_d;

// 2-to-1 Mux for cd
wire mux_c_not_d = ~d ? 1'b1 : 1'b0;
wire mux_c_not_c = ~c ? 1'b0 : mux_c_not_d;

// 2-to-1 Mux for cd'
wire mux_c_d = d ? 1'b0 : 1'b1;
wire mux_c_not_d2 = ~d ? 1'b1 : 1'b0;
wire mux_c_c = ~c ? mux_c_not_d2 : mux_c_d;

// 4-to-1 Mux for selecting between c'd', c'd, cd, and cd'
wire [3:0] mux_in = {mux_cd_c, mux_cd_not_c, mux_c_not_c, mux_c_c};

endmodule
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);

// Implementing the K-map using multiplexers

// 2-to-1 Mux for c'd'
wire mux_cd_d = d ? 1'b1 : 1'b0;
wire mux_cd_c = c ? mux_cd_d : 1'b1;

// 2-to-1 Mux for c'd
wire mux_cd_not_d = ~d ? 1'b1 : 1'b0;
wire mux_cd_not_c = c ? 1'b0 : mux_cd_not_d;

// 2-to-1 Mux for cd
wire mux_c_not_d = ~d ? 1'b1 : 1'b0;
wire mux_c_not_c = ~c ? 1'b0 : mux_c_not_d;

// 2-to-1 Mux for cd'
wire mux_c_d = d ? 1'b0 : 1'b1;
wire mux_c_not_d2 = ~d ? 1'b1 : 1'b0;
wire mux_c_c = ~c ? mux_c_not_d2 : mux_c_d;

// 4-to-1 Mux for selecting between c'd', c'd, cd, and cd'
wire [3:0] mux_in = {mux_cd_c, mux_cd_not_c, mux_c_not_c, mux_c_c};

endmodule
"
"
    // Define states
    typedef enum logic [1:0] {
        IDLE,
        CONVERT
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define output register
    reg z_reg;
    
    // Define internal signals
    reg x_reg;
    
    // Define 2's complement logic
    always @* begin
        if (x_reg) begin
            z_reg <= ~x_reg + 1;
        end
    end
    
    // Define state machine logic
    always @(posedge clk or negedge areset) begin
        if (!areset) begin
            state <= IDLE;
            x_reg <= 1'b0;
            z_reg <= 1'b0;
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            IDLE: begin
                if (!areset && !x) begin
                    next_state = IDLE;
                    x_reg <= x;
                end else if (!areset && x) begin
                    next_state = CONVERT;
                    x_reg <= x;
                end else begin
                    next_state = IDLE;
                end
            end
            CONVERT: begin
                if (!areset && x) begin
                    next_state = CONVERT;
                    x_reg <= x;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end
    
    // Assign output
    assign z = z_reg;
endmodule
",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    // Define states
    typedef enum logic [1:0] {
        IDLE,
        CONVERT
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define output register
    reg z_reg;
    
    // Define internal signals
    reg x_reg;
    
    // Define 2's complement logic
    always @* begin
        if (x_reg) begin
            z_reg <= ~x_reg + 1;
        end
    end
    
    // Define state machine logic
    always @(posedge clk or negedge areset) begin
        if (!areset) begin
            state <= IDLE;
            x_reg <= 1'b0;
            z_reg <= 1'b0;
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            IDLE: begin
                if (!areset && !x) begin
                    next_state = IDLE;
                    x_reg <= x;
                end else if (!areset && x) begin
                    next_state = CONVERT;
                    x_reg <= x;
                end else begin
                    next_state = IDLE;
                end
            end
            CONVERT: begin
                if (!areset && x) begin
                    next_state = CONVERT;
                    x_reg <= x;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end
    
    // Assign output
    assign z = z_reg;
endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    // Define states
    typedef enum logic [1:0] {
        IDLE,
        CONVERT
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define output register
    reg z_reg;
    
    // Define internal signals
    reg x_reg;
    
    // Define 2's complement logic
    always @* begin
        if (x_reg) begin
            z_reg <= ~x_reg + 1;
        end
    end
    
    // Define state machine logic
    always @(posedge clk or negedge areset) begin
        if (!areset) begin
            state <= IDLE;
            x_reg <= 1'b0;
            z_reg <= 1'b0;
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            IDLE: begin
                if (!areset && !x) begin
                    next_state = IDLE;
                    x_reg <= x;
                end else if (!areset && x) begin
                    next_state = CONVERT;
                    x_reg <= x;
                end else begin
                    next_state = IDLE;
                end
            end
            CONVERT: begin
                if (!areset && x) begin
                    next_state = CONVERT;
                    x_reg <= x;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end
    
    // Assign output
    assign z = z_reg;
endmodule
"
"
    // Define states for the Moore state machine
    typedef enum logic [2:0] {
        IDLE,
        CONVERTING,
        DONE
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define output register
    reg z_reg;

    // Define internal signals
    reg signed [7:0] input_reg;
    reg signed [7:0] output_reg;

    // State machine logic
    always_ff @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= IDLE;
            input_reg <= 0;
            output_reg <= 0;
            z_reg <= 0;
        end else begin
            state <= next_state;
            input_reg <= x ? {input_reg[6:0], x} : input_reg;
            case (state)
                IDLE: next_state = x ? CONVERTING : IDLE;
                CONVERTING: next_state = x ? CONVERTING : DONE;
                DONE: next_state = x ? CONVERTING : IDLE;
            endcase
        end
    end

    // Output logic
    always_comb begin
        case (state)
            IDLE: z_reg = 0;
            CONVERTING: z_reg = ~input_reg + 1;
            DONE: z_reg = ~input_reg + 1;
        endcase
    end

    assign z = z_reg;

endmodule
",-1.0,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    // Define states for the Moore state machine
    typedef enum logic [2:0] {
        IDLE,
        CONVERTING,
        DONE
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define output register
    reg z_reg;

    // Define internal signals
    reg signed [7:0] input_reg;
    reg signed [7:0] output_reg;

    // State machine logic
    always_ff @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= IDLE;
            input_reg <= 0;
            output_reg <= 0;
            z_reg <= 0;
        end else begin
            state <= next_state;
            input_reg <= x ? {input_reg[6:0], x} : input_reg;
            case (state)
                IDLE: next_state = x ? CONVERTING : IDLE;
                CONVERTING: next_state = x ? CONVERTING : DONE;
                DONE: next_state = x ? CONVERTING : IDLE;
            endcase
        end
    end

    // Output logic
    always_comb begin
        case (state)
            IDLE: z_reg = 0;
            CONVERTING: z_reg = ~input_reg + 1;
            DONE: z_reg = ~input_reg + 1;
        endcase
    end

    assign z = z_reg;

endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    // Define states for the Moore state machine
    typedef enum logic [2:0] {
        IDLE,
        CONVERTING,
        DONE
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define output register
    reg z_reg;

    // Define internal signals
    reg signed [7:0] input_reg;
    reg signed [7:0] output_reg;

    // State machine logic
    always_ff @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= IDLE;
            input_reg <= 0;
            output_reg <= 0;
            z_reg <= 0;
        end else begin
            state <= next_state;
            input_reg <= x ? {input_reg[6:0], x} : input_reg;
            case (state)
                IDLE: next_state = x ? CONVERTING : IDLE;
                CONVERTING: next_state = x ? CONVERTING : DONE;
                DONE: next_state = x ? CONVERTING : IDLE;
            endcase
        end
    end

    // Output logic
    always_comb begin
        case (state)
            IDLE: z_reg = 0;
            CONVERTING: z_reg = ~input_reg + 1;
            DONE: z_reg = ~input_reg + 1;
        endcase
    end

    assign z = z_reg;

endmodule
"
"
    // State declaration
    enum {S0, S1, S2} state;
    reg [1:0] next_state;
    
    // Output declaration
    reg z;
    
    // State register
    always @(posedge clk or negedge areset) begin
        if (!areset) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case(state)
            S0: begin
                if (areset) begin
                    next_state = S0;
                end else begin
                    next_state = S1;
                end
            end
            S1: begin
                if (areset) begin
                    next_state = S0;
                end else if (x == 1'b1) begin
                    next_state = S2;
                end else begin
                    next_state = S1;
                end
            end
            S2: begin
                if (areset) begin
                    next_state = S0;
                end else begin
                    next_state = S2;
                end
            end
        endcase
    end
    
    // Output logic
    always @(*) begin
        case(state)
            S0: begin
                z = 1'b0;
            end
            S1: begin
                z = x;
            end
            S2: begin
                z = ~x + 1'b1;
            end
        endcase
    end
endmodule
",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    // State declaration
    enum {S0, S1, S2} state;
    reg [1:0] next_state;
    
    // Output declaration
    reg z;
    
    // State register
    always @(posedge clk or negedge areset) begin
        if (!areset) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case(state)
            S0: begin
                if (areset) begin
                    next_state = S0;
                end else begin
                    next_state = S1;
                end
            end
            S1: begin
                if (areset) begin
                    next_state = S0;
                end else if (x == 1'b1) begin
                    next_state = S2;
                end else begin
                    next_state = S1;
                end
            end
            S2: begin
                if (areset) begin
                    next_state = S0;
                end else begin
                    next_state = S2;
                end
            end
        endcase
    end
    
    // Output logic
    always @(*) begin
        case(state)
            S0: begin
                z = 1'b0;
            end
            S1: begin
                z = x;
            end
            S2: begin
                z = ~x + 1'b1;
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    // State declaration
    enum {S0, S1, S2} state;
    reg [1:0] next_state;
    
    // Output declaration
    reg z;
    
    // State register
    always @(posedge clk or negedge areset) begin
        if (!areset) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case(state)
            S0: begin
                if (areset) begin
                    next_state = S0;
                end else begin
                    next_state = S1;
                end
            end
            S1: begin
                if (areset) begin
                    next_state = S0;
                end else if (x == 1'b1) begin
                    next_state = S2;
                end else begin
                    next_state = S1;
                end
            end
            S2: begin
                if (areset) begin
                    next_state = S0;
                end else begin
                    next_state = S2;
                end
            end
        endcase
    end
    
    // Output logic
    always @(*) begin
        case(state)
            S0: begin
                z = 1'b0;
            end
            S1: begin
                z = x;
            end
            S2: begin
                z = ~x + 1'b1;
            end
        endcase
    end
endmodule
"
"
    reg [1:0] state;
    reg [1:0] next_state;
    reg [1:0] output_reg;
    
    always @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= 2'b00; // Initial state
            output_reg <= 2'b00; // Initial output
        end else begin
            state <= next_state;
            output_reg <= (state == 2'b10) ? ~x + 1 : output_reg; // 2's complement logic
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // Idle state
                next_state = (areset == 0) ? 2'b00 : x ? 2'b01 : 2'b00; // Transition to next state when input is detected
            end
            2'b01: begin // Processing state
                next_state = (areset == 0) ? 2'b00 : x ? 2'b01 : 2'b10; // Stay in processing state until input is complete
            end
            2'b10: begin // Output state
                next_state = (areset == 0) ? 2'b00 : 2'b00; // Reset to idle state on reset signal
            end
            default: next_state = 2'b00;
        endcase
    end
    
    assign z = output_reg[1]; // Output the most significant bit of the 2's complement
    
endmodule
",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    reg [1:0] state;
    reg [1:0] next_state;
    reg [1:0] output_reg;
    
    always @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= 2'b00; // Initial state
            output_reg <= 2'b00; // Initial output
        end else begin
            state <= next_state;
            output_reg <= (state == 2'b10) ? ~x + 1 : output_reg; // 2's complement logic
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // Idle state
                next_state = (areset == 0) ? 2'b00 : x ? 2'b01 : 2'b00; // Transition to next state when input is detected
            end
            2'b01: begin // Processing state
                next_state = (areset == 0) ? 2'b00 : x ? 2'b01 : 2'b10; // Stay in processing state until input is complete
            end
            2'b10: begin // Output state
                next_state = (areset == 0) ? 2'b00 : 2'b00; // Reset to idle state on reset signal
            end
            default: next_state = 2'b00;
        endcase
    end
    
    assign z = output_reg[1]; // Output the most significant bit of the 2's complement
    
endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    reg [1:0] state;
    reg [1:0] next_state;
    reg [1:0] output_reg;
    
    always @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= 2'b00; // Initial state
            output_reg <= 2'b00; // Initial output
        end else begin
            state <= next_state;
            output_reg <= (state == 2'b10) ? ~x + 1 : output_reg; // 2's complement logic
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // Idle state
                next_state = (areset == 0) ? 2'b00 : x ? 2'b01 : 2'b00; // Transition to next state when input is detected
            end
            2'b01: begin // Processing state
                next_state = (areset == 0) ? 2'b00 : x ? 2'b01 : 2'b10; // Stay in processing state until input is complete
            end
            2'b10: begin // Output state
                next_state = (areset == 0) ? 2'b00 : 2'b00; // Reset to idle state on reset signal
            end
            default: next_state = 2'b00;
        endcase
    end
    
    assign z = output_reg[1]; // Output the most significant bit of the 2's complement
    
endmodule
"
"
    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    
    reg [1:0] state, next_state;
    reg z_reg;
    
    always @ (posedge clk or negedge areset) begin
        if (areset) begin
            state <= S0;
            z_reg <= 1'b0;
        end else begin
            state <= next_state;
            z_reg <= z_reg;
        end
    end
    
    always @* begin
        next_state = state;
        case (state)
            S0: begin
                if (x == 1'b1)
                    next_state = S1;
            end
            S1: begin
                if (x == 1'b0) begin
                    next_state = S2;
                    z_reg = ~z_reg + 1'b1;
                end
            end
            S2: begin
                if (x == 1'b1)
                    next_state = S1;
            end
        endcase
    end
    
    assign z = z_reg;
    
endmodule
",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    
    reg [1:0] state, next_state;
    reg z_reg;
    
    always @ (posedge clk or negedge areset) begin
        if (areset) begin
            state <= S0;
            z_reg <= 1'b0;
        end else begin
            state <= next_state;
            z_reg <= z_reg;
        end
    end
    
    always @* begin
        next_state = state;
        case (state)
            S0: begin
                if (x == 1'b1)
                    next_state = S1;
            end
            S1: begin
                if (x == 1'b0) begin
                    next_state = S2;
                    z_reg = ~z_reg + 1'b1;
                end
            end
            S2: begin
                if (x == 1'b1)
                    next_state = S1;
            end
        endcase
    end
    
    assign z = z_reg;
    
endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    
    reg [1:0] state, next_state;
    reg z_reg;
    
    always @ (posedge clk or negedge areset) begin
        if (areset) begin
            state <= S0;
            z_reg <= 1'b0;
        end else begin
            state <= next_state;
            z_reg <= z_reg;
        end
    end
    
    always @* begin
        next_state = state;
        case (state)
            S0: begin
                if (x == 1'b1)
                    next_state = S1;
            end
            S1: begin
                if (x == 1'b0) begin
                    next_state = S2;
                    z_reg = ~z_reg + 1'b1;
                end
            end
            S2: begin
                if (x == 1'b1)
                    next_state = S1;
            end
        endcase
    end
    
    assign z = z_reg;
    
endmodule
"
"
    reg [1:0] state;
    reg [1:0] next_state;
    reg [1:0] complement;
    
    always @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= 2'b00;
            complement <= 2'b00;
        end else begin
            state <= next_state;
            complement <= x ? ~complement + 1 : complement;
        end
    end
    
    always @(*) begin
        case (state)
            2'b00: begin // Idle state
                if (areset == 0)
                    next_state = 2'b00;
                else if (x == 1)
                    next_state = 2'b01;
                else
                    next_state = 2'b00;
            end
            2'b01: begin // Complementing state
                if (areset == 0)
                    next_state = 2'b00;
                else if (x == 1)
                    next_state = 2'b01;
                else
                    next_state = 2'b00;
            end
        endcase
    end
    
    assign z = complement[1]; // Output the most significant bit of the complement
    
endmodule
",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    reg [1:0] state;
    reg [1:0] next_state;
    reg [1:0] complement;
    
    always @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= 2'b00;
            complement <= 2'b00;
        end else begin
            state <= next_state;
            complement <= x ? ~complement + 1 : complement;
        end
    end
    
    always @(*) begin
        case (state)
            2'b00: begin // Idle state
                if (areset == 0)
                    next_state = 2'b00;
                else if (x == 1)
                    next_state = 2'b01;
                else
                    next_state = 2'b00;
            end
            2'b01: begin // Complementing state
                if (areset == 0)
                    next_state = 2'b00;
                else if (x == 1)
                    next_state = 2'b01;
                else
                    next_state = 2'b00;
            end
        endcase
    end
    
    assign z = complement[1]; // Output the most significant bit of the complement
    
endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    reg [1:0] state;
    reg [1:0] next_state;
    reg [1:0] complement;
    
    always @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= 2'b00;
            complement <= 2'b00;
        end else begin
            state <= next_state;
            complement <= x ? ~complement + 1 : complement;
        end
    end
    
    always @(*) begin
        case (state)
            2'b00: begin // Idle state
                if (areset == 0)
                    next_state = 2'b00;
                else if (x == 1)
                    next_state = 2'b01;
                else
                    next_state = 2'b00;
            end
            2'b01: begin // Complementing state
                if (areset == 0)
                    next_state = 2'b00;
                else if (x == 1)
                    next_state = 2'b01;
                else
                    next_state = 2'b00;
            end
        endcase
    end
    
    assign z = complement[1]; // Output the most significant bit of the complement
    
endmodule
"
"// Define states for the Moore state machine
typedef enum logic [2:0] {
    IDLE,
    CONVERT,
    OUTPUT
} state_t;

// Define signals for the Moore state machine
state_t state, next_state;
reg z;

// Define the one-input one-output serial 2's complementer Moore state machine
always_ff @(posedge clk or negedge areset) begin
    if (areset == 0) begin
        state <= IDLE;
        z <= 0;
    end else begin
        state <= next_state;
    end
end

always_comb begin
    case (state)
        IDLE: begin
            if (areset == 0) begin
                next_state = IDLE;
            end else if (x == 1) begin
                next_state = CONVERT;
            end else begin
                next_state = IDLE;
            end
        end
        CONVERT: begin
            if (areset == 0) begin
                next_state = IDLE;
            end else if (x == 1) begin
                next_state = CONVERT;
            end else begin
                next_state = OUTPUT;
            end
        end
        OUTPUT: begin
            if (areset == 0) begin
                next_state = IDLE;
            end else begin
                next_state = IDLE;
            end
        end
    endcase
end

// Define the output logic
always_comb begin
    case (state)
        IDLE: begin
            z = 0;
        end
        CONVERT: begin
            z = ~x;
        end
        OUTPUT: begin
            z = z + 1;
        end
    endcase
end

endmodule
",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);
// Define states for the Moore state machine
typedef enum logic [2:0] {
    IDLE,
    CONVERT,
    OUTPUT
} state_t;

// Define signals for the Moore state machine
state_t state, next_state;
reg z;

// Define the one-input one-output serial 2's complementer Moore state machine
always_ff @(posedge clk or negedge areset) begin
    if (areset == 0) begin
        state <= IDLE;
        z <= 0;
    end else begin
        state <= next_state;
    end
end

always_comb begin
    case (state)
        IDLE: begin
            if (areset == 0) begin
                next_state = IDLE;
            end else if (x == 1) begin
                next_state = CONVERT;
            end else begin
                next_state = IDLE;
            end
        end
        CONVERT: begin
            if (areset == 0) begin
                next_state = IDLE;
            end else if (x == 1) begin
                next_state = CONVERT;
            end else begin
                next_state = OUTPUT;
            end
        end
        OUTPUT: begin
            if (areset == 0) begin
                next_state = IDLE;
            end else begin
                next_state = IDLE;
            end
        end
    endcase
end

// Define the output logic
always_comb begin
    case (state)
        IDLE: begin
            z = 0;
        end
        CONVERT: begin
            z = ~x;
        end
        OUTPUT: begin
            z = z + 1;
        end
    endcase
end

endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);
// Define states for the Moore state machine
typedef enum logic [2:0] {
    IDLE,
    CONVERT,
    OUTPUT
} state_t;

// Define signals for the Moore state machine
state_t state, next_state;
reg z;

// Define the one-input one-output serial 2's complementer Moore state machine
always_ff @(posedge clk or negedge areset) begin
    if (areset == 0) begin
        state <= IDLE;
        z <= 0;
    end else begin
        state <= next_state;
    end
end

always_comb begin
    case (state)
        IDLE: begin
            if (areset == 0) begin
                next_state = IDLE;
            end else if (x == 1) begin
                next_state = CONVERT;
            end else begin
                next_state = IDLE;
            end
        end
        CONVERT: begin
            if (areset == 0) begin
                next_state = IDLE;
            end else if (x == 1) begin
                next_state = CONVERT;
            end else begin
                next_state = OUTPUT;
            end
        end
        OUTPUT: begin
            if (areset == 0) begin
                next_state = IDLE;
            end else begin
                next_state = IDLE;
            end
        end
    endcase
end

// Define the output logic
always_comb begin
    case (state)
        IDLE: begin
            z = 0;
        end
        CONVERT: begin
            z = ~x;
        end
        OUTPUT: begin
            z = z + 1;
        end
    endcase
end

endmodule
"
"    // Define states for the Moore state machine
    typedef enum logic [2:0] {
        IDLE,
        CONVERTING
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;
    always_ff @(posedge clk or negedge areset) begin
        if (areset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Define output register
    reg z_reg;
    always_comb begin
        z = z_reg;
    end

    // Define state machine logic
    always_comb begin
        case(state)
            IDLE: begin
                if (!areset && x) begin
                    next_state = CONVERTING;
                end else begin
                    next_state = IDLE;
                end
            end
            CONVERTING: begin
                if (!areset && x) begin
                    z_reg = ~x + 1;
                    next_state = CONVERTING;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end
endmodule
",-1.0,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);
    // Define states for the Moore state machine
    typedef enum logic [2:0] {
        IDLE,
        CONVERTING
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;
    always_ff @(posedge clk or negedge areset) begin
        if (areset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Define output register
    reg z_reg;
    always_comb begin
        z = z_reg;
    end

    // Define state machine logic
    always_comb begin
        case(state)
            IDLE: begin
                if (!areset && x) begin
                    next_state = CONVERTING;
                end else begin
                    next_state = IDLE;
                end
            end
            CONVERTING: begin
                if (!areset && x) begin
                    z_reg = ~x + 1;
                    next_state = CONVERTING;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);
    // Define states for the Moore state machine
    typedef enum logic [2:0] {
        IDLE,
        CONVERTING
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;
    always_ff @(posedge clk or negedge areset) begin
        if (areset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Define output register
    reg z_reg;
    always_comb begin
        z = z_reg;
    end

    // Define state machine logic
    always_comb begin
        case(state)
            IDLE: begin
                if (!areset && x) begin
                    next_state = CONVERTING;
                end else begin
                    next_state = IDLE;
                end
            end
            CONVERTING: begin
                if (!areset && x) begin
                    z_reg = ~x + 1;
                    next_state = CONVERTING;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end
endmodule
"
"
    reg [1:0] state;
    reg [1:0] next_state;
    reg [1:0] output;
    
    always @(posedge clk or negedge areset) begin
        if (!areset) begin
            state <= 2'b00;
            output <= 2'b00;
        end else begin
            state <= next_state;
            output <= (state == 2'b01) ? ~x + 1 : output;
        end
    end
    
    always @* begin
        case (state)
            2'b00: begin
                next_state = x ? 2'b01 : 2'b00;
            end
            2'b01: begin
                next_state = x ? 2'b01 : 2'b10;
            end
            2'b10: begin
                next_state = 2'b10;
            end
        endcase
    end
    
    assign z = output;
endmodule
",-1.0,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    reg [1:0] state;
    reg [1:0] next_state;
    reg [1:0] output;
    
    always @(posedge clk or negedge areset) begin
        if (!areset) begin
            state <= 2'b00;
            output <= 2'b00;
        end else begin
            state <= next_state;
            output <= (state == 2'b01) ? ~x + 1 : output;
        end
    end
    
    always @* begin
        case (state)
            2'b00: begin
                next_state = x ? 2'b01 : 2'b00;
            end
            2'b01: begin
                next_state = x ? 2'b01 : 2'b10;
            end
            2'b10: begin
                next_state = 2'b10;
            end
        endcase
    end
    
    assign z = output;
endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    reg [1:0] state;
    reg [1:0] next_state;
    reg [1:0] output;
    
    always @(posedge clk or negedge areset) begin
        if (!areset) begin
            state <= 2'b00;
            output <= 2'b00;
        end else begin
            state <= next_state;
            output <= (state == 2'b01) ? ~x + 1 : output;
        end
    end
    
    always @* begin
        case (state)
            2'b00: begin
                next_state = x ? 2'b01 : 2'b00;
            end
            2'b01: begin
                next_state = x ? 2'b01 : 2'b10;
            end
            2'b10: begin
                next_state = 2'b10;
            end
        endcase
    end
    
    assign z = output;
endmodule
"
"
    // Define state enumeration
    typedef enum logic [2:0] {
        IDLE,
        CONVERTING
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define output register and next output logic
    reg z_reg;
    wire z_next;

    // Define internal signals
    reg x_reg;
    reg twos_comp;

    // State register and next state logic
    always_ff @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Output register and next output logic
    always_comb begin
        z = z_reg;
    end

    // State machine logic
    always_comb begin
        case(state)
            IDLE: begin
                if (areset == 0) begin
                    next_state = IDLE;
                    z_next = 0;
                end else if (x == 1) begin
                    next_state = CONVERTING;
                    x_reg = x;
                    twos_comp = 0;
                    z_next = 1;
                end else begin
                    next_state = IDLE;
                    z_next = 0;
                end
            end
            CONVERTING: begin
                if (x_reg == 0) begin
                    next_state = IDLE;
                    z_next = twos_comp;
                end else begin
                    next_state = CONVERTING;
                    x_reg = x_reg - 1;
                    twos_comp = ~twos_comp;
                    z_next = twos_comp;
                end
            end
        endcase
    end

    // Update output register
    always_ff @(posedge clk) begin
        z_reg <= z_next;
    end

endmodule
",-1.0,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    // Define state enumeration
    typedef enum logic [2:0] {
        IDLE,
        CONVERTING
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define output register and next output logic
    reg z_reg;
    wire z_next;

    // Define internal signals
    reg x_reg;
    reg twos_comp;

    // State register and next state logic
    always_ff @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Output register and next output logic
    always_comb begin
        z = z_reg;
    end

    // State machine logic
    always_comb begin
        case(state)
            IDLE: begin
                if (areset == 0) begin
                    next_state = IDLE;
                    z_next = 0;
                end else if (x == 1) begin
                    next_state = CONVERTING;
                    x_reg = x;
                    twos_comp = 0;
                    z_next = 1;
                end else begin
                    next_state = IDLE;
                    z_next = 0;
                end
            end
            CONVERTING: begin
                if (x_reg == 0) begin
                    next_state = IDLE;
                    z_next = twos_comp;
                end else begin
                    next_state = CONVERTING;
                    x_reg = x_reg - 1;
                    twos_comp = ~twos_comp;
                    z_next = twos_comp;
                end
            end
        endcase
    end

    // Update output register
    always_ff @(posedge clk) begin
        z_reg <= z_next;
    end

endmodule
","module top_module (
    input clk,
    input areset,
    input x,
    output z
);

    // Define state enumeration
    typedef enum logic [2:0] {
        IDLE,
        CONVERTING
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define output register and next output logic
    reg z_reg;
    wire z_next;

    // Define internal signals
    reg x_reg;
    reg twos_comp;

    // State register and next state logic
    always_ff @(posedge clk or negedge areset) begin
        if (areset == 0) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Output register and next output logic
    always_comb begin
        z = z_reg;
    end

    // State machine logic
    always_comb begin
        case(state)
            IDLE: begin
                if (areset == 0) begin
                    next_state = IDLE;
                    z_next = 0;
                end else if (x == 1) begin
                    next_state = CONVERTING;
                    x_reg = x;
                    twos_comp = 0;
                    z_next = 1;
                end else begin
                    next_state = IDLE;
                    z_next = 0;
                end
            end
            CONVERTING: begin
                if (x_reg == 0) begin
                    next_state = IDLE;
                    z_next = twos_comp;
                end else begin
                    next_state = CONVERTING;
                    x_reg = x_reg - 1;
                    twos_comp = ~twos_comp;
                    z_next = twos_comp;
                end
            end
        endcase
    end

    // Update output register
    always_ff @(posedge clk) begin
        z_reg <= z_next;
    end

endmodule
"
"// Instantiate the provided 4-bit binary counter module
count4 the_counter (
    .clk(clk),
    .enable(c_enable),
    .load(c_load),
    .d(c_d),
    .Q(Q)
);

reg [3:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 4'b0001; // Reset the counter to 1
    end else begin
        if (enable) begin
            count <= count + 1; // Increment the counter
        end
    end
end

assign c_enable = enable;
assign c_load = 1'b0; // We don't need to load values into the internal counter
assign c_d = count; // Pass the current count value to the internal counter

endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );
// Instantiate the provided 4-bit binary counter module
count4 the_counter (
    .clk(clk),
    .enable(c_enable),
    .load(c_load),
    .d(c_d),
    .Q(Q)
);

reg [3:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 4'b0001; // Reset the counter to 1
    end else begin
        if (enable) begin
            count <= count + 1; // Increment the counter
        end
    end
end

assign c_enable = enable;
assign c_load = 1'b0; // We don't need to load values into the internal counter
assign c_d = count; // Pass the current count value to the internal counter

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );
// Instantiate the provided 4-bit binary counter module
count4 the_counter (
    .clk(clk),
    .enable(c_enable),
    .load(c_load),
    .d(c_d),
    .Q(Q)
);

reg [3:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 4'b0001; // Reset the counter to 1
    end else begin
        if (enable) begin
            count <= count + 1; // Increment the counter
        end
    end
end

assign c_enable = enable;
assign c_load = 1'b0; // We don't need to load values into the internal counter
assign c_d = count; // Pass the current count value to the internal counter

endmodule
"
"// Instantiate the 4-bit binary counter module
count4 the_counter (
    .clk(clk),
    .enable(c_enable),
    .load(c_load),
    .d(c_d)
);

reg [3:0] Q_reg; // Register to hold the counter value

always @(posedge clk) begin
    if (reset) begin
        Q_reg <= 4'b0001; // Reset the counter value to 1
    end else begin
        if (enable) begin
            Q_reg <= Q_reg + 1; // Increment the counter value
        end
    end
end

assign Q = Q_reg;

endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );
// Instantiate the 4-bit binary counter module
count4 the_counter (
    .clk(clk),
    .enable(c_enable),
    .load(c_load),
    .d(c_d)
);

reg [3:0] Q_reg; // Register to hold the counter value

always @(posedge clk) begin
    if (reset) begin
        Q_reg <= 4'b0001; // Reset the counter value to 1
    end else begin
        if (enable) begin
            Q_reg <= Q_reg + 1; // Increment the counter value
        end
    end
end

assign Q = Q_reg;

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );
// Instantiate the 4-bit binary counter module
count4 the_counter (
    .clk(clk),
    .enable(c_enable),
    .load(c_load),
    .d(c_d)
);

reg [3:0] Q_reg; // Register to hold the counter value

always @(posedge clk) begin
    if (reset) begin
        Q_reg <= 4'b0001; // Reset the counter value to 1
    end else begin
        if (enable) begin
            Q_reg <= Q_reg + 1; // Increment the counter value
        end
    end
end

assign Q = Q_reg;

endmodule
"
"
    reg [3:0] Q;
    reg [3:0] c_d;
    reg c_enable, c_load;

    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );

    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
        end else begin
            if (enable) begin
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                end else begin
                    Q <= Q + 4'b0001;
                end
            end
        end
    end

    always @* begin
        c_enable = enable;
        c_load = 1'b0;
        c_d = Q;
    end

endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg [3:0] c_d;
    reg c_enable, c_load;

    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );

    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
        end else begin
            if (enable) begin
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                end else begin
                    Q <= Q + 4'b0001;
                end
            end
        end
    end

    always @* begin
        c_enable = enable;
        c_load = 1'b0;
        c_d = Q;
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg [3:0] c_d;
    reg c_enable, c_load;

    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );

    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
        end else begin
            if (enable) begin
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                end else begin
                    Q <= Q + 4'b0001;
                end
            end
        end
    end

    always @* begin
        c_enable = enable;
        c_load = 1'b0;
        c_d = Q;
    end

endmodule
"
"

    reg [3:0] count;
    reg [3:0] next_count;
    
    // Instantiate the 4-bit binary counter
    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );
    
    // Reset logic
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else if (enable) begin
            count <= next_count;
        end
    end
    
    // Counter logic
    always @(*) begin
        if (reset) begin
            next_count = 4'b0001;
        end else if (enable) begin
            if (count == 4'b1100) begin
                next_count = 4'b0001;
            end else begin
                next_count = count + 4'b0001;
            end
        end
    end
    
    assign Q = count;
    
endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );


    reg [3:0] count;
    reg [3:0] next_count;
    
    // Instantiate the 4-bit binary counter
    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );
    
    // Reset logic
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else if (enable) begin
            count <= next_count;
        end
    end
    
    // Counter logic
    always @(*) begin
        if (reset) begin
            next_count = 4'b0001;
        end else if (enable) begin
            if (count == 4'b1100) begin
                next_count = 4'b0001;
            end else begin
                next_count = count + 4'b0001;
            end
        end
    end
    
    assign Q = count;
    
endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );


    reg [3:0] count;
    reg [3:0] next_count;
    
    // Instantiate the 4-bit binary counter
    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );
    
    // Reset logic
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0001;
        end else if (enable) begin
            count <= next_count;
        end
    end
    
    // Counter logic
    always @(*) begin
        if (reset) begin
            next_count = 4'b0001;
        end else if (enable) begin
            if (count == 4'b1100) begin
                next_count = 4'b0001;
            end else begin
                next_count = count + 4'b0001;
            end
        end
    end
    
    assign Q = count;
    
endmodule
"
"
    reg [3:0] Q;
    reg c_enable, c_load;
    reg [3:0] c_d;
    
    // Instantiate the 4-bit binary counter module
    count4 the_counter (clk, c_enable, c_load, c_d);
    
    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
            c_enable <= 1'b0;
            c_load <= 1'b0;
            c_d <= 4'b0001;
        end else begin
            if (enable) begin
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                end else begin
                    Q <= Q + 4'b0001;
                end
                c_enable <= 1'b1;
                c_load <= 1'b0;
                c_d <= Q + 4'b0001;
            end else begin
                c_enable <= 1'b0;
                c_load <= 1'b0;
                c_d <= Q;
            end
        end
    end
endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg c_enable, c_load;
    reg [3:0] c_d;
    
    // Instantiate the 4-bit binary counter module
    count4 the_counter (clk, c_enable, c_load, c_d);
    
    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
            c_enable <= 1'b0;
            c_load <= 1'b0;
            c_d <= 4'b0001;
        end else begin
            if (enable) begin
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                end else begin
                    Q <= Q + 4'b0001;
                end
                c_enable <= 1'b1;
                c_load <= 1'b0;
                c_d <= Q + 4'b0001;
            end else begin
                c_enable <= 1'b0;
                c_load <= 1'b0;
                c_d <= Q;
            end
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg c_enable, c_load;
    reg [3:0] c_d;
    
    // Instantiate the 4-bit binary counter module
    count4 the_counter (clk, c_enable, c_load, c_d);
    
    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
            c_enable <= 1'b0;
            c_load <= 1'b0;
            c_d <= 4'b0001;
        end else begin
            if (enable) begin
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                end else begin
                    Q <= Q + 4'b0001;
                end
                c_enable <= 1'b1;
                c_load <= 1'b0;
                c_d <= Q + 4'b0001;
            end else begin
                c_enable <= 1'b0;
                c_load <= 1'b0;
                c_d <= Q;
            end
        end
    end
endmodule
"
"
    reg [3:0] counter_value;
    reg [3:0] next_counter_value;
    
    // Instantiate the 4-bit binary counter
    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );
    
    // Reset logic
    always @(posedge clk) begin
        if (reset) begin
            counter_value <= 4'b0001;
            next_counter_value <= 4'b0001;
        end else if (enable) begin
            counter_value <= next_counter_value;
        end
    end
    
    // Counter logic
    always @* begin
        if (reset) begin
            next_counter_value = 4'b0001;
        end else if (enable) begin
            if (counter_value == 4'b1100) begin
                next_counter_value = 4'b0001;
            end else begin
                next_counter_value = counter_value + 4'b0001;
            end
        end
    end
    
    assign Q = counter_value;
endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] counter_value;
    reg [3:0] next_counter_value;
    
    // Instantiate the 4-bit binary counter
    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );
    
    // Reset logic
    always @(posedge clk) begin
        if (reset) begin
            counter_value <= 4'b0001;
            next_counter_value <= 4'b0001;
        end else if (enable) begin
            counter_value <= next_counter_value;
        end
    end
    
    // Counter logic
    always @* begin
        if (reset) begin
            next_counter_value = 4'b0001;
        end else if (enable) begin
            if (counter_value == 4'b1100) begin
                next_counter_value = 4'b0001;
            end else begin
                next_counter_value = counter_value + 4'b0001;
            end
        end
    end
    
    assign Q = counter_value;
endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] counter_value;
    reg [3:0] next_counter_value;
    
    // Instantiate the 4-bit binary counter
    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );
    
    // Reset logic
    always @(posedge clk) begin
        if (reset) begin
            counter_value <= 4'b0001;
            next_counter_value <= 4'b0001;
        end else if (enable) begin
            counter_value <= next_counter_value;
        end
    end
    
    // Counter logic
    always @* begin
        if (reset) begin
            next_counter_value = 4'b0001;
        end else if (enable) begin
            if (counter_value == 4'b1100) begin
                next_counter_value = 4'b0001;
            end else begin
                next_counter_value = counter_value + 4'b0001;
            end
        end
    end
    
    assign Q = counter_value;
endmodule
"
"
    reg [3:0] Q;
    reg c_enable, c_load;
    reg [3:0] c_d;

    count4 the_counter (clk, c_enable, c_load, c_d);

    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
        end else begin
            if (enable) begin
                Q <= Q + 4'b0001;
            end
        end
    end

    always @* begin
        c_enable = enable;
        c_load = 1'b0; // Load is not used in this design
        c_d = Q;
    end

endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg c_enable, c_load;
    reg [3:0] c_d;

    count4 the_counter (clk, c_enable, c_load, c_d);

    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
        end else begin
            if (enable) begin
                Q <= Q + 4'b0001;
            end
        end
    end

    always @* begin
        c_enable = enable;
        c_load = 1'b0; // Load is not used in this design
        c_d = Q;
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg c_enable, c_load;
    reg [3:0] c_d;

    count4 the_counter (clk, c_enable, c_load, c_d);

    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
        end else begin
            if (enable) begin
                Q <= Q + 4'b0001;
            end
        end
    end

    always @* begin
        c_enable = enable;
        c_load = 1'b0; // Load is not used in this design
        c_d = Q;
    end

endmodule
"
"
    reg [3:0] Q;
    reg [3:0] c_d;
    reg c_enable, c_load;

    // Instantiate the provided 4-bit binary counter module
    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );

    // Reset logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            Q <= 4'b0001;
            c_enable <= 0;
            c_load <= 0;
        end else begin
            // Counter operation
            if (enable) begin
                c_enable <= 1;
                c_load <= 0;
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                    c_load <= 1;
                end else begin
                    Q <= Q + 1;
                end
            end else begin
                c_enable <= 0;
                c_load <= 0;
            end
        end
    end

endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg [3:0] c_d;
    reg c_enable, c_load;

    // Instantiate the provided 4-bit binary counter module
    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );

    // Reset logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            Q <= 4'b0001;
            c_enable <= 0;
            c_load <= 0;
        end else begin
            // Counter operation
            if (enable) begin
                c_enable <= 1;
                c_load <= 0;
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                    c_load <= 1;
                end else begin
                    Q <= Q + 1;
                end
            end else begin
                c_enable <= 0;
                c_load <= 0;
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg [3:0] c_d;
    reg c_enable, c_load;

    // Instantiate the provided 4-bit binary counter module
    count4 the_counter (
        .clk(clk),
        .enable(c_enable),
        .load(c_load),
        .d(c_d)
    );

    // Reset logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            Q <= 4'b0001;
            c_enable <= 0;
            c_load <= 0;
        end else begin
            // Counter operation
            if (enable) begin
                c_enable <= 1;
                c_load <= 0;
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                    c_load <= 1;
                end else begin
                    Q <= Q + 1;
                end
            end else begin
                c_enable <= 0;
                c_load <= 0;
            end
        end
    end

endmodule
"
"

    reg [3:0] Q;
    reg [3:0] c_d;
    reg c_enable, c_load;
    
    count4 the_counter (clk, c_enable, c_load, c_d);
    
    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
        end else begin
            if (enable) begin
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                end else begin
                    Q <= Q + 1;
                end
            end
        end
    end
    
    always @* begin
        c_enable = enable;
        c_load = 1'b0;
        c_d = Q;
    end
    
endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );


    reg [3:0] Q;
    reg [3:0] c_d;
    reg c_enable, c_load;
    
    count4 the_counter (clk, c_enable, c_load, c_d);
    
    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
        end else begin
            if (enable) begin
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                end else begin
                    Q <= Q + 1;
                end
            end
        end
    end
    
    always @* begin
        c_enable = enable;
        c_load = 1'b0;
        c_d = Q;
    end
    
endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );


    reg [3:0] Q;
    reg [3:0] c_d;
    reg c_enable, c_load;
    
    count4 the_counter (clk, c_enable, c_load, c_d);
    
    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
        end else begin
            if (enable) begin
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                end else begin
                    Q <= Q + 1;
                end
            end
        end
    end
    
    always @* begin
        c_enable = enable;
        c_load = 1'b0;
        c_d = Q;
    end
    
endmodule
"
"
    reg [3:0] Q;
    reg c_enable, c_load;
    reg [3:0] c_d;

    count4 the_counter (clk, c_enable, c_load, c_d);

    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
            c_enable <= 0;
            c_load <= 1;
            c_d <= 4'b0001;
        end else begin
            if (enable) begin
                c_enable <= 1;
                c_load <= 0;
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                    c_d <= 4'b0001;
                end else begin
                    Q <= Q + 1;
                    c_d <= Q + 1;
                end
            end else begin
                c_enable <= 0;
                c_load <= 0;
                c_d <= Q;
            end
        end
    end
endmodule
",-1.0,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg c_enable, c_load;
    reg [3:0] c_d;

    count4 the_counter (clk, c_enable, c_load, c_d);

    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
            c_enable <= 0;
            c_load <= 1;
            c_d <= 4'b0001;
        end else begin
            if (enable) begin
                c_enable <= 1;
                c_load <= 0;
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                    c_d <= 4'b0001;
                end else begin
                    Q <= Q + 1;
                    c_d <= Q + 1;
                end
            end else begin
                c_enable <= 0;
                c_load <= 0;
                c_d <= Q;
            end
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );

    reg [3:0] Q;
    reg c_enable, c_load;
    reg [3:0] c_d;

    count4 the_counter (clk, c_enable, c_load, c_d);

    always @(posedge clk) begin
        if (reset) begin
            Q <= 4'b0001;
            c_enable <= 0;
            c_load <= 1;
            c_d <= 4'b0001;
        end else begin
            if (enable) begin
                c_enable <= 1;
                c_load <= 0;
                if (Q == 4'b1100) begin
                    Q <= 4'b0001;
                    c_d <= 4'b0001;
                end else begin
                    Q <= Q + 1;
                    c_d <= Q + 1;
                end
            end else begin
                c_enable <= 0;
                c_load <= 0;
                c_d <= Q;
            end
        end
    end
endmodule
"
"
    bcdcount counter1 (clk, reset, c_enable[1]/*, ... */);
    bcdcount counter2 (clk, reset, c_enable[2]/*, ... */);

    reg [9:0] count = 0;

    always @ (posedge clk) begin
        if (reset) begin
            count <= 0;
            OneHertz <= 0;
        end else begin
            count <= count + 1;
            if (count == 999) begin
                count <= 0;
                OneHertz <= 1;
            end else begin
                OneHertz <= 0;
            end
        end
    end
endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);

    bcdcount counter1 (clk, reset, c_enable[1]/*, ... */);
    bcdcount counter2 (clk, reset, c_enable[2]/*, ... */);

    reg [9:0] count = 0;

    always @ (posedge clk) begin
        if (reset) begin
            count <= 0;
            OneHertz <= 0;
        end else begin
            count <= count + 1;
            if (count == 999) begin
                count <= 0;
                OneHertz <= 1;
            end else begin
                OneHertz <= 0;
            end
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);

    bcdcount counter1 (clk, reset, c_enable[1]/*, ... */);
    bcdcount counter2 (clk, reset, c_enable[2]/*, ... */);

    reg [9:0] count = 0;

    always @ (posedge clk) begin
        if (reset) begin
            count <= 0;
            OneHertz <= 0;
        end else begin
            count <= count + 1;
            if (count == 999) begin
                count <= 0;
                OneHertz <= 1;
            end else begin
                OneHertz <= 0;
            end
        end
    end
endmodule
"
"
    bcdcount counter0 (clk, reset, c_enable[0]);
    bcdcount counter1 (clk, reset & c_enable[0], c_enable[1]);
    bcdcount counter2 (clk, reset & c_enable[0] & c_enable[1], c_enable[2]);
    
    reg [9:0] counter = 10'd0;
    reg OneHertz = 1'b0;
    
    always @(posedge clk) begin
        if (reset) begin
            counter <= 10'd0;
            OneHertz <= 1'b0;
        end else begin
            counter <= counter + 1;
            if (counter == 1000) begin
                counter <= 10'd0;
                OneHertz <= 1'b1;
            end else begin
                OneHertz <= 1'b0;
            end
        end
    end
endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);

    bcdcount counter0 (clk, reset, c_enable[0]);
    bcdcount counter1 (clk, reset & c_enable[0], c_enable[1]);
    bcdcount counter2 (clk, reset & c_enable[0] & c_enable[1], c_enable[2]);
    
    reg [9:0] counter = 10'd0;
    reg OneHertz = 1'b0;
    
    always @(posedge clk) begin
        if (reset) begin
            counter <= 10'd0;
            OneHertz <= 1'b0;
        end else begin
            counter <= counter + 1;
            if (counter == 1000) begin
                counter <= 10'd0;
                OneHertz <= 1'b1;
            end else begin
                OneHertz <= 1'b0;
            end
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);

    bcdcount counter0 (clk, reset, c_enable[0]);
    bcdcount counter1 (clk, reset & c_enable[0], c_enable[1]);
    bcdcount counter2 (clk, reset & c_enable[0] & c_enable[1], c_enable[2]);
    
    reg [9:0] counter = 10'd0;
    reg OneHertz = 1'b0;
    
    always @(posedge clk) begin
        if (reset) begin
            counter <= 10'd0;
            OneHertz <= 1'b0;
        end else begin
            counter <= counter + 1;
            if (counter == 1000) begin
                counter <= 10'd0;
                OneHertz <= 1'b1;
            end else begin
                OneHertz <= 1'b0;
            end
        end
    end
endmodule
"
"module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        counter <= 0;
        OneHertz <= 0;
        c_enable <= 3'b111;
    end
    else begin
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end
        else begin
            counter <= counter + 1;
            OneHertz <= 0;
        end
        
        if (counter % 10 == 0) begin
            c_enable <= c_enable & 3'b110;
        end
    end
end

endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        counter <= 0;
        OneHertz <= 0;
        c_enable <= 3'b111;
    end
    else begin
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end
        else begin
            counter <= counter + 1;
            OneHertz <= 0;
        end
        
        if (counter % 10 == 0) begin
            c_enable <= c_enable & 3'b110;
        end
    end
end

endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        counter <= 0;
        OneHertz <= 0;
        c_enable <= 3'b111;
    end
    else begin
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end
        else begin
            counter <= counter + 1;
            OneHertz <= 0;
        end
        
        if (counter % 10 == 0) begin
            c_enable <= c_enable & 3'b110;
        end
    end
end

endmodule
"
"module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] count;
reg OneHertz;

always @(posedge clk) begin
    if (reset) begin
        count <= 0;
        OneHertz <= 0;
        c_enable <= 3'b000;
    end else begin
        count <= count + 1;
        if (count == 999) begin
            OneHertz <= 1;
            count <= 0;
            c_enable <= 3'b111;
        end else begin
            OneHertz <= 0;
            c_enable <= 3'b000;
        end
    end
end

endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] count;
reg OneHertz;

always @(posedge clk) begin
    if (reset) begin
        count <= 0;
        OneHertz <= 0;
        c_enable <= 3'b000;
    end else begin
        count <= count + 1;
        if (count == 999) begin
            OneHertz <= 1;
            count <= 0;
            c_enable <= 3'b111;
        end else begin
            OneHertz <= 0;
            c_enable <= 3'b000;
        end
    end
end

endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] count;
reg OneHertz;

always @(posedge clk) begin
    if (reset) begin
        count <= 0;
        OneHertz <= 0;
        c_enable <= 3'b000;
    end else begin
        count <= count + 1;
        if (count == 999) begin
            OneHertz <= 1;
            count <= 0;
            c_enable <= 3'b111;
        end else begin
            OneHertz <= 0;
            c_enable <= 3'b000;
        end
    end
end

endmodule
"
"module top_module (
    input clk,
    input reset,
    output reg OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg [3:0] bcd_out;
reg [3:0] bcd_out_next;
reg enable_divider;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        counter <= 0;
        bcd_out <= 0;
        bcd_out_next <= 0;
        enable_divider <= 0;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            enable_divider <= ~enable_divider;
        end
    end
end

always @* begin
    if (enable_divider) begin
        bcd_out_next = bcd_out + 1;
        if (bcd_out == 9) begin
            bcd_out_next = 0;
        end
    end else begin
        bcd_out_next = bcd_out;
    end
end

assign c_enable = {enable_divider, enable_divider, enable_divider};
assign OneHertz = enable_divider;

endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output reg OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg [3:0] bcd_out;
reg [3:0] bcd_out_next;
reg enable_divider;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        counter <= 0;
        bcd_out <= 0;
        bcd_out_next <= 0;
        enable_divider <= 0;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            enable_divider <= ~enable_divider;
        end
    end
end

always @* begin
    if (enable_divider) begin
        bcd_out_next = bcd_out + 1;
        if (bcd_out == 9) begin
            bcd_out_next = 0;
        end
    end else begin
        bcd_out_next = bcd_out;
    end
end

assign c_enable = {enable_divider, enable_divider, enable_divider};
assign OneHertz = enable_divider;

endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output reg OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg [3:0] bcd_out;
reg [3:0] bcd_out_next;
reg enable_divider;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        counter <= 0;
        bcd_out <= 0;
        bcd_out_next <= 0;
        enable_divider <= 0;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            enable_divider <= ~enable_divider;
        end
    end
end

always @* begin
    if (enable_divider) begin
        bcd_out_next = bcd_out + 1;
        if (bcd_out == 9) begin
            bcd_out_next = 0;
        end
    end else begin
        bcd_out_next = bcd_out;
    end
end

assign c_enable = {enable_divider, enable_divider, enable_divider};
assign OneHertz = enable_divider;

endmodule
"
"module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] count;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        count <= 0;
        OneHertz <= 0;
        c_enable <= 3'b111;
    end else begin
        count <= count + 1;
        if (count == 999) begin
            count <= 0;
            OneHertz <= ~OneHertz;
        end
        if (count % 10 == 0) begin
            c_enable <= c_enable << 1;
        end
    end
end

endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] count;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        count <= 0;
        OneHertz <= 0;
        c_enable <= 3'b111;
    end else begin
        count <= count + 1;
        if (count == 999) begin
            count <= 0;
            OneHertz <= ~OneHertz;
        end
        if (count % 10 == 0) begin
            c_enable <= c_enable << 1;
        end
    end
end

endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] count;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        count <= 0;
        OneHertz <= 0;
        c_enable <= 3'b111;
    end else begin
        count <= count + 1;
        if (count == 999) begin
            count <= 0;
            OneHertz <= ~OneHertz;
        end
        if (count % 10 == 0) begin
            c_enable <= c_enable << 1;
        end
    end
end

endmodule
"
"module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        counter <= 0;
        OneHertz <= 0;
        c_enable <= 3'b111;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end else begin
            OneHertz <= 0;
        end
    end
end

// BCD counters
bcdcount counter0 (clk, reset, c_enable[0]);
bcdcount counter1 (clk, reset, c_enable[1]);
bcdcount counter2 (clk, reset, c_enable[2]);

endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        counter <= 0;
        OneHertz <= 0;
        c_enable <= 3'b111;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end else begin
            OneHertz <= 0;
        end
    end
end

// BCD counters
bcdcount counter0 (clk, reset, c_enable[0]);
bcdcount counter1 (clk, reset, c_enable[1]);
bcdcount counter2 (clk, reset, c_enable[2]);

endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        counter <= 0;
        OneHertz <= 0;
        c_enable <= 3'b111;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end else begin
            OneHertz <= 0;
        end
    end
end

// BCD counters
bcdcount counter0 (clk, reset, c_enable[0]);
bcdcount counter1 (clk, reset, c_enable[1]);
bcdcount counter2 (clk, reset, c_enable[2]);

endmodule
"
"module top_module (
    input clk,
    input reset,
    output reg OneHertz,
    output reg [2:0] c_enable
);	

reg [9:0] counter;
reg [3:0] bcd_counter[2:0];

always @(posedge clk) begin
    if (reset) begin
        counter <= 0;
        bcd_counter[0] <= 0;
        bcd_counter[1] <= 0;
        bcd_counter[2] <= 0;
        OneHertz <= 0;
        c_enable <= 3'b000;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end else begin
            OneHertz <= 0;
        end
        
        if (bcd_counter[0] == 9) begin
            bcd_counter[0] <= 0;
            bcd_counter[1] <= bcd_counter[1] + 1;
        end else begin
            bcd_counter[0] <= bcd_counter[0] + 1;
        end
        
        if (bcd_counter[1] == 9) begin
            bcd_counter[1] <= 0;
            bcd_counter[2] <= bcd_counter[2] + 1;
        end else begin
            bcd_counter[1] <= bcd_counter[1] + 1;
        end
        
        if (bcd_counter[2] == 9) begin
            bcd_counter[2] <= 0;
        end else begin
            bcd_counter[2] <= bcd_counter[2] + 1;
        end
        
        c_enable <= {enable, enable, enable};
    end
end

endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output reg OneHertz,
    output reg [2:0] c_enable
);	

reg [9:0] counter;
reg [3:0] bcd_counter[2:0];

always @(posedge clk) begin
    if (reset) begin
        counter <= 0;
        bcd_counter[0] <= 0;
        bcd_counter[1] <= 0;
        bcd_counter[2] <= 0;
        OneHertz <= 0;
        c_enable <= 3'b000;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end else begin
            OneHertz <= 0;
        end
        
        if (bcd_counter[0] == 9) begin
            bcd_counter[0] <= 0;
            bcd_counter[1] <= bcd_counter[1] + 1;
        end else begin
            bcd_counter[0] <= bcd_counter[0] + 1;
        end
        
        if (bcd_counter[1] == 9) begin
            bcd_counter[1] <= 0;
            bcd_counter[2] <= bcd_counter[2] + 1;
        end else begin
            bcd_counter[1] <= bcd_counter[1] + 1;
        end
        
        if (bcd_counter[2] == 9) begin
            bcd_counter[2] <= 0;
        end else begin
            bcd_counter[2] <= bcd_counter[2] + 1;
        end
        
        c_enable <= {enable, enable, enable};
    end
end

endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output reg OneHertz,
    output reg [2:0] c_enable
);	

reg [9:0] counter;
reg [3:0] bcd_counter[2:0];

always @(posedge clk) begin
    if (reset) begin
        counter <= 0;
        bcd_counter[0] <= 0;
        bcd_counter[1] <= 0;
        bcd_counter[2] <= 0;
        OneHertz <= 0;
        c_enable <= 3'b000;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end else begin
            OneHertz <= 0;
        end
        
        if (bcd_counter[0] == 9) begin
            bcd_counter[0] <= 0;
            bcd_counter[1] <= bcd_counter[1] + 1;
        end else begin
            bcd_counter[0] <= bcd_counter[0] + 1;
        end
        
        if (bcd_counter[1] == 9) begin
            bcd_counter[1] <= 0;
            bcd_counter[2] <= bcd_counter[2] + 1;
        end else begin
            bcd_counter[1] <= bcd_counter[1] + 1;
        end
        
        if (bcd_counter[2] == 9) begin
            bcd_counter[2] <= 0;
        end else begin
            bcd_counter[2] <= bcd_counter[2] + 1;
        end
        
        c_enable <= {enable, enable, enable};
    end
end

endmodule
"
"
    bcdcount counter0 (clk, reset, c_enable[0]);
    bcdcount counter1 (clk, reset, c_enable[1]);
    bcdcount counter2 (clk, reset, c_enable[2]);

    reg [9:0] counter;
    reg OneHertz;

    always @ (posedge clk) begin
        if (reset) begin
            counter <= 0;
            OneHertz <= 0;
        end else begin
            counter <= counter + 1;
            if (counter == 999) begin
                counter <= 0;
                OneHertz <= 1;
            end else begin
                OneHertz <= 0;
            end
        end
    end

endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);

    bcdcount counter0 (clk, reset, c_enable[0]);
    bcdcount counter1 (clk, reset, c_enable[1]);
    bcdcount counter2 (clk, reset, c_enable[2]);

    reg [9:0] counter;
    reg OneHertz;

    always @ (posedge clk) begin
        if (reset) begin
            counter <= 0;
            OneHertz <= 0;
        end else begin
            counter <= counter + 1;
            if (counter == 999) begin
                counter <= 0;
                OneHertz <= 1;
            end else begin
                OneHertz <= 0;
            end
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);

    bcdcount counter0 (clk, reset, c_enable[0]);
    bcdcount counter1 (clk, reset, c_enable[1]);
    bcdcount counter2 (clk, reset, c_enable[2]);

    reg [9:0] counter;
    reg OneHertz;

    always @ (posedge clk) begin
        if (reset) begin
            counter <= 0;
            OneHertz <= 0;
        end else begin
            counter <= counter + 1;
            if (counter == 999) begin
                counter <= 0;
                OneHertz <= 1;
            end else begin
                OneHertz <= 0;
            end
        end
    end

endmodule
"
"module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg [3:0] bcd_out;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        counter <= 0;
        bcd_out <= 4'b0000;
        c_enable <= 3'b111;
        OneHertz <= 0;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end else begin
            OneHertz <= 0;
        end
        
        if (counter % 10 == 0) begin
            bcd_out <= bcd_out + 1;
        end
        
        if (bcd_out == 10) begin
            bcd_out <= 0;
            c_enable <= c_enable << 1;
            c_enable[0] <= 1;
        end
    end
end

bcdcount counter0 (clk, reset, c_enable[0], bcd_out[3:0]);
bcdcount counter1 (clk, reset, c_enable[1], bcd_out[3:0]);
bcdcount counter2 (clk, reset, c_enable[2], bcd_out[3:0]);

endmodule
",-1.0,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg [3:0] bcd_out;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        counter <= 0;
        bcd_out <= 4'b0000;
        c_enable <= 3'b111;
        OneHertz <= 0;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end else begin
            OneHertz <= 0;
        end
        
        if (counter % 10 == 0) begin
            bcd_out <= bcd_out + 1;
        end
        
        if (bcd_out == 10) begin
            bcd_out <= 0;
            c_enable <= c_enable << 1;
            c_enable[0] <= 1;
        end
    end
end

bcdcount counter0 (clk, reset, c_enable[0], bcd_out[3:0]);
bcdcount counter1 (clk, reset, c_enable[1], bcd_out[3:0]);
bcdcount counter2 (clk, reset, c_enable[2], bcd_out[3:0]);

endmodule
","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);

reg [9:0] counter;
reg [3:0] bcd_out;
reg OneHertz;

always @ (posedge clk) begin
    if (reset) begin
        counter <= 0;
        bcd_out <= 4'b0000;
        c_enable <= 3'b111;
        OneHertz <= 0;
    end else begin
        counter <= counter + 1;
        if (counter == 999) begin
            counter <= 0;
            OneHertz <= 1;
        end else begin
            OneHertz <= 0;
        end
        
        if (counter % 10 == 0) begin
            bcd_out <= bcd_out + 1;
        end
        
        if (bcd_out == 10) begin
            bcd_out <= 0;
            c_enable <= c_enable << 1;
            c_enable[0] <= 1;
        end
    end
end

bcdcount counter0 (clk, reset, c_enable[0], bcd_out[3:0]);
bcdcount counter1 (clk, reset, c_enable[1], bcd_out[3:0]);
bcdcount counter2 (clk, reset, c_enable[2], bcd_out[3:0]);

endmodule
"
"module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[1] & x[2]) | (x[1] & x[4]) | (x[2] & x[3]) | (x[3] & x[4]);

endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[1] & x[2]) | (x[1] & x[4]) | (x[2] & x[3]) | (x[3] & x[4]);

endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[1] & x[2]) | (x[1] & x[4]) | (x[2] & x[3]) | (x[3] & x[4]);

endmodule
"
"module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (x[1] & x[2]) | (x[1] & x[4]) | (x[2] & x[3]) | (x[3] & x[4]);
    
endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (x[1] & x[2]) | (x[1] & x[4]) | (x[2] & x[3]) | (x[3] & x[4]);
    
endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (x[1] & x[2]) | (x[1] & x[4]) | (x[2] & x[3]) | (x[3] & x[4]);
    
endmodule
"
"module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[4] & x[3] & x[1]) | (x[4] & x[2] & ~x[1]) | (x[3] & x[2] & ~x[1]) | (x[3] & ~x[2] & x[1]);
    
endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[4] & x[3] & x[1]) | (x[4] & x[2] & ~x[1]) | (x[3] & x[2] & ~x[1]) | (x[3] & ~x[2] & x[1]);
    
endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[4] & x[3] & x[1]) | (x[4] & x[2] & ~x[1]) | (x[3] & x[2] & ~x[1]) | (x[3] & ~x[2] & x[1]);
    
endmodule
"
"module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[4] & x[3] & !x[2] & !x[1]) | (!x[4] & x[3] & x[2] & x[1]) | (x[4] & !x[3] & x[2]) | (x[4] & x[3] & !x[2] & !x[1]);
    
endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[4] & x[3] & !x[2] & !x[1]) | (!x[4] & x[3] & x[2] & x[1]) | (x[4] & !x[3] & x[2]) | (x[4] & x[3] & !x[2] & !x[1]);
    
endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[4] & x[3] & !x[2] & !x[1]) | (!x[4] & x[3] & x[2] & x[1]) | (x[4] & !x[3] & x[2]) | (x[4] & x[3] & !x[2] & !x[1]);
    
endmodule
"
"module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1] & ~x[2] & x[3] & x[4]) | (~x[1] & x[2] & x[3]) | (x[1] & x[2] & ~x[4]) | (x[1] & x[2] & x[3] & ~x[4]);
    
endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1] & ~x[2] & x[3] & x[4]) | (~x[1] & x[2] & x[3]) | (x[1] & x[2] & ~x[4]) | (x[1] & x[2] & x[3] & ~x[4]);
    
endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1] & ~x[2] & x[3] & x[4]) | (~x[1] & x[2] & x[3]) | (x[1] & x[2] & ~x[4]) | (x[1] & x[2] & x[3] & ~x[4]);
    
endmodule
"
"module top_module (
    input [4:1] x, 
    output f );

    assign f = (~x[1] & ~x[2] & x[3] & x[4]) | 
                (~x[1] & x[2] & x[3]) | 
                (x[1] & x[2] & ~x[4]) | 
                (x[1] & x[2] & x[3] & ~x[4]);

endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (~x[1] & ~x[2] & x[3] & x[4]) | 
                (~x[1] & x[2] & x[3]) | 
                (x[1] & x[2] & ~x[4]) | 
                (x[1] & x[2] & x[3] & ~x[4]);

endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (~x[1] & ~x[2] & x[3] & x[4]) | 
                (~x[1] & x[2] & x[3]) | 
                (x[1] & x[2] & ~x[4]) | 
                (x[1] & x[2] & x[3] & ~x[4]);

endmodule
"
"module top_module (
    input [4:1] x, 
    output f );
    
    assign f = x[1] & x[2] | x[1] & x[3] & x[4] | x[2] & x[3] & x[4] | x[2] & x[4];
    
endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );
    
    assign f = x[1] & x[2] | x[1] & x[3] & x[4] | x[2] & x[3] & x[4] | x[2] & x[4];
    
endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );
    
    assign f = x[1] & x[2] | x[1] & x[3] & x[4] | x[2] & x[3] & x[4] | x[2] & x[4];
    
endmodule
"
"module top_module (
    input [4:1] x, 
    output f );

    assign f = x[1] & x[2] | x[3] & x[4] | x[1] & ~x[2] & ~x[3] | ~x[1] & x[2] & x[4];
    
endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = x[1] & x[2] | x[3] & x[4] | x[1] & ~x[2] & ~x[3] | ~x[1] & x[2] & x[4];
    
endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = x[1] & x[2] | x[3] & x[4] | x[1] & ~x[2] & ~x[3] | ~x[1] & x[2] & x[4];
    
endmodule
"
"module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (x[1] & x[2]) | (~x[1] & x[3]) | (x[2] & x[3] & ~x[4]) | (~x[1] & ~x[2] & x[4]);
    
endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (x[1] & x[2]) | (~x[1] & x[3]) | (x[2] & x[3] & ~x[4]) | (~x[1] & ~x[2] & x[4]);
    
endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (x[1] & x[2]) | (~x[1] & x[3]) | (x[2] & x[3] & ~x[4]) | (~x[1] & ~x[2] & x[4]);
    
endmodule
"
"module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[1] & x[2]) | (x[1] & ~x[3] & x[4]) | (~x[1] & x[2] & x[3]) | (~x[1] & ~x[2] & x[4]);
    
endmodule
",-1.0,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[1] & x[2]) | (x[1] & ~x[3] & x[4]) | (~x[1] & x[2] & x[3]) | (~x[1] & ~x[2] & x[4]);
    
endmodule
","module top_module (
    input [4:1] x, 
    output f );

module top_module (
    input [4:1] x, 
    output f );

    assign f = (x[1] & x[2]) | (x[1] & ~x[3] & x[4]) | (~x[1] & x[2] & x[3]) | (~x[1] & ~x[2] & x[4]);
    
endmodule
"
"reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
",-1.0,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
"
"reg q;

always @ (posedge ena) begin
    q <= d;
end

endmodule
",-0.5,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @ (posedge ena) begin
    q <= d;
end

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @ (posedge ena) begin
    q <= d;
end

endmodule
"
"reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
",-1.0,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
"
"reg q;

always @(posedge ena) begin
    q <= d;
end

endmodule
",-0.5,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena) begin
    q <= d;
end

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena) begin
    q <= d;
end

endmodule
"
"reg q;

always @(posedge ena)
begin
    q <= d;
end

endmodule
",-0.5,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    q <= d;
end

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    q <= d;
end

endmodule
"
"reg q;

always @(posedge ena)
begin
    q <= d;
end

endmodule
",-0.5,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    q <= d;
end

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    q <= d;
end

endmodule
"
"reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
",-1.0,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
"
"reg q;

always @ (posedge ena)
begin
    q <= d;
end

endmodule
",-0.5,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @ (posedge ena)
begin
    q <= d;
end

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @ (posedge ena)
begin
    q <= d;
end

endmodule
"
"reg q;

always @(posedge ena) begin
    q <= d;
end

endmodule
",-0.5,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena) begin
    q <= d;
end

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena) begin
    q <= d;
end

endmodule
"
"reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
",-1.0,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
","module top_module (
    input d, 
    input ena,
    output q);


reg q;

always @(posedge ena)
begin
    if (ena)
        q <= d;
end

assign q = q;

endmodule
"
"reg q;

always @(posedge clk or ar) begin
    if (ar) begin
        q <= 1'b0;   // asynchronous reset
    end else begin
        q <= d;
    end
end

assign q = q;  // output q

endmodule
",-1.0,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



reg q;

always @(posedge clk or ar) begin
    if (ar) begin
        q <= 1'b0;   // asynchronous reset
    end else begin
        q <= d;
    end
end

assign q = q;  // output q

endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



reg q;

always @(posedge clk or ar) begin
    if (ar) begin
        q <= 1'b0;   // asynchronous reset
    end else begin
        q <= d;
    end
end

assign q = q;  // output q

endmodule
"
"    reg q;

    always @(posedge clk or ar) begin
        if (ar) begin
            q <= 1'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



    reg q;

    always @(posedge clk or ar) begin
        if (ar) begin
            q <= 1'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



    reg q;

    always @(posedge clk or ar) begin
        if (ar) begin
            q <= 1'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"// D flip-flop with asynchronous reset
// This design uses a positive edge-triggered D flip-flop with an asynchronous reset

reg q;

always @(posedge clk or posedge ar) begin
    if (ar) begin
        q <= 1'b0; // asynchronous reset
    end else begin
        q <= d; // update q on positive clock edge
    end
end

assign q = q; // output q

endmodule
",-1.0,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
// This design uses a positive edge-triggered D flip-flop with an asynchronous reset

reg q;

always @(posedge clk or posedge ar) begin
    if (ar) begin
        q <= 1'b0; // asynchronous reset
    end else begin
        q <= d; // update q on positive clock edge
    end
end

assign q = q; // output q

endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
// This design uses a positive edge-triggered D flip-flop with an asynchronous reset

reg q;

always @(posedge clk or posedge ar) begin
    if (ar) begin
        q <= 1'b0; // asynchronous reset
    end else begin
        q <= d; // update q on positive clock edge
    end
end

assign q = q; // output q

endmodule
"
"// D flip-flop with asynchronous reset
module dff_async_reset (
    input clk,
    input d,
    input ar,
    output reg q
);

always @(posedge clk or negedge ar) begin
    if (!ar) begin
        q <= 1'b0; // reset the output
    end else begin
        q <= d; // update the output with input d
    end
end

endmodule
",-1.0,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
module dff_async_reset (
    input clk,
    input d,
    input ar,
    output reg q
);

always @(posedge clk or negedge ar) begin
    if (!ar) begin
        q <= 1'b0; // reset the output
    end else begin
        q <= d; // update the output with input d
    end
end

endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
module dff_async_reset (
    input clk,
    input d,
    input ar,
    output reg q
);

always @(posedge clk or negedge ar) begin
    if (!ar) begin
        q <= 1'b0; // reset the output
    end else begin
        q <= d; // update the output with input d
    end
end

endmodule
"
"reg q;

always @(posedge clk or ar) begin
    if (ar) begin
        q <= 1'b0;  // asynchronous reset
    end else begin
        q <= d;
    end
end

assign q = q;  // output q

endmodule
",-1.0,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



reg q;

always @(posedge clk or ar) begin
    if (ar) begin
        q <= 1'b0;  // asynchronous reset
    end else begin
        q <= d;
    end
end

assign q = q;  // output q

endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



reg q;

always @(posedge clk or ar) begin
    if (ar) begin
        q <= 1'b0;  // asynchronous reset
    end else begin
        q <= d;
    end
end

assign q = q;  // output q

endmodule
"
"
    reg q;

    always @(posedge clk or negedge ar) begin
        if (ar == 0) begin
            q <= 0;
        end else begin
            q <= d;
        end
    end

    assign q = q;
endmodule
",-1.0,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);




    reg q;

    always @(posedge clk or negedge ar) begin
        if (ar == 0) begin
            q <= 0;
        end else begin
            q <= d;
        end
    end

    assign q = q;
endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);




    reg q;

    always @(posedge clk or negedge ar) begin
        if (ar == 0) begin
            q <= 0;
        end else begin
            q <= d;
        end
    end

    assign q = q;
endmodule
"
"// D flip-flop with asynchronous reset
// This module implements a D flip-flop with an asynchronous reset

module d_flip_flop_with_async_reset (
    input clk,
    input d,
    input ar,
    output reg q
);

    always @(posedge clk or negedge ar) begin
        if (!ar) begin
            q <= 1'b0; // Reset the output to 0 when ar is low
        end else begin
            q <= d; // Update the output with the input d on the positive edge of the clock
        end
    end

endmodule
",-1.0,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
// This module implements a D flip-flop with an asynchronous reset

module d_flip_flop_with_async_reset (
    input clk,
    input d,
    input ar,
    output reg q
);

    always @(posedge clk or negedge ar) begin
        if (!ar) begin
            q <= 1'b0; // Reset the output to 0 when ar is low
        end else begin
            q <= d; // Update the output with the input d on the positive edge of the clock
        end
    end

endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
// This module implements a D flip-flop with an asynchronous reset

module d_flip_flop_with_async_reset (
    input clk,
    input d,
    input ar,
    output reg q
);

    always @(posedge clk or negedge ar) begin
        if (!ar) begin
            q <= 1'b0; // Reset the output to 0 when ar is low
        end else begin
            q <= d; // Update the output with the input d on the positive edge of the clock
        end
    end

endmodule
"
"// D flip-flop with asynchronous reset
// When ar is high, the output q is reset to 0

reg q;

always @(posedge clk or posedge ar) begin
    if (ar) begin
        q <= 1'b0;
    end else begin
        q <= d;
    end
end

assign q = q; // Output q

endmodule
",-1.0,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
// When ar is high, the output q is reset to 0

reg q;

always @(posedge clk or posedge ar) begin
    if (ar) begin
        q <= 1'b0;
    end else begin
        q <= d;
    end
end

assign q = q; // Output q

endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
// When ar is high, the output q is reset to 0

reg q;

always @(posedge clk or posedge ar) begin
    if (ar) begin
        q <= 1'b0;
    end else begin
        q <= d;
    end
end

assign q = q; // Output q

endmodule
"
"// D flip-flop with asynchronous reset
reg q;

always @(posedge clk or negedge ar) begin
    if (!ar) begin
        q <= 1'b0;  // asynchronous reset
    end else begin
        q <= d;
    end
end

assign q = q;  // output q is assigned the value of q

endmodule
",-1.0,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
reg q;

always @(posedge clk or negedge ar) begin
    if (!ar) begin
        q <= 1'b0;  // asynchronous reset
    end else begin
        q <= d;
    end
end

assign q = q;  // output q is assigned the value of q

endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
reg q;

always @(posedge clk or negedge ar) begin
    if (!ar) begin
        q <= 1'b0;  // asynchronous reset
    end else begin
        q <= d;
    end
end

assign q = q;  // output q is assigned the value of q

endmodule
"
"// D flip-flop with asynchronous reset
// D flip-flop changes its output q to the input d on the rising edge of the clock
// If ar is high, the output q is asynchronously reset to 0

reg q;

always @(posedge clk or posedge ar) begin
    if (ar) begin
        q <= 1'b0; // asynchronously reset q to 0
    end else begin
        q <= d; // update q with input d on clock edge
    end
end

assign q = q; // output q

endmodule
",-1.0,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
// D flip-flop changes its output q to the input d on the rising edge of the clock
// If ar is high, the output q is asynchronously reset to 0

reg q;

always @(posedge clk or posedge ar) begin
    if (ar) begin
        q <= 1'b0; // asynchronously reset q to 0
    end else begin
        q <= d; // update q with input d on clock edge
    end
end

assign q = q; // output q

endmodule
","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);



// D flip-flop with asynchronous reset
// D flip-flop changes its output q to the input d on the rising edge of the clock
// If ar is high, the output q is asynchronously reset to 0

reg q;

always @(posedge clk or posedge ar) begin
    if (ar) begin
        q <= 1'b0; // asynchronously reset q to 0
    end else begin
        q <= d; // update q with input d on clock edge
    end
end

assign q = q; // output q

endmodule
"
"
    reg q;

    always @(posedge clk) begin
        if (r == 1'b1) begin
            q <= 1'b0;
        end else begin
            q <= d;
        end
    end

endmodule
",-0.5,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    reg q;

    always @(posedge clk) begin
        if (r == 1'b1) begin
            q <= 1'b0;
        end else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    reg q;

    always @(posedge clk) begin
        if (r == 1'b1) begin
            q <= 1'b0;
        end else begin
            q <= d;
        end
    end

endmodule
"
"    reg q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_reg <= 1'b0;  // synchronous reset
        end else begin
            q_reg <= d;
        end
    end

    assign q = q_reg;

endmodule
",-0.5,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_reg <= 1'b0;  // synchronous reset
        end else begin
            q_reg <= d;
        end
    end

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_reg <= 1'b0;  // synchronous reset
        end else begin
            q_reg <= d;
        end
    end

    assign q = q_reg;

endmodule
"
"
    reg q_next, q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_reg <= 1'b0;  // reset
        else begin
            q_reg <= d;     // update q with d
        end
    end

    assign q = q_reg;
endmodule
",-1.0,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    reg q_next, q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_reg <= 1'b0;  // reset
        else begin
            q_reg <= d;     // update q with d
        end
    end

    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    reg q_next, q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_reg <= 1'b0;  // reset
        else begin
            q_reg <= d;     // update q with d
        end
    end

    assign q = q_reg;
endmodule
"
"    reg q_next, q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_next <= 1'b0;
        end else begin
            q_next <= d;
        end
    end

    always @(posedge clk) begin
        q_reg <= q_next;
    end

    assign q = q_reg;

endmodule
",-0.5,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q_next, q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_next <= 1'b0;
        end else begin
            q_next <= d;
        end
    end

    always @(posedge clk) begin
        q_reg <= q_next;
    end

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q_next, q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_next <= 1'b0;
        end else begin
            q_next <= d;
        end
    end

    always @(posedge clk) begin
        q_reg <= q_next;
    end

    assign q = q_reg;

endmodule
"
"    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;
        else begin
            q <= d;
        end
    end

endmodule
",-1.0,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;
        else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;
        else begin
            q <= d;
        end
    end

endmodule
"
"
    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;  // reset
        else begin
            q <= d;
        end
    end

endmodule
",-1.0,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;  // reset
        else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;  // reset
        else begin
            q <= d;
        end
    end

endmodule
"
"    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;
        else begin
            q <= d;
        end
    end

endmodule
",-1.0,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;
        else begin
            q <= d;
        end
    end

endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;
        else begin
            q <= d;
        end
    end

endmodule
"
"    reg q_next, q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_next <= 1'b0;
        end else begin
            q_next <= d;
        end
    end

    always @(posedge clk) begin
        q_reg <= q_next;
    end

    assign q = q_reg;

endmodule
",-0.5,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q_next, q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_next <= 1'b0;
        end else begin
            q_next <= d;
        end
    end

    always @(posedge clk) begin
        q_reg <= q_next;
    end

    assign q = q_reg;

endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q_next, q_reg;

    always @(posedge clk) begin
        if (r) begin
            q_next <= 1'b0;
        end else begin
            q_next <= d;
        end
    end

    always @(posedge clk) begin
        q_reg <= q_next;
    end

    assign q = q_reg;

endmodule
"
"
    reg q_next, q_reg;
    
    always @(posedge clk) begin
        if (r) begin
            q_next <= 1'b0;
        end else begin
            q_next <= d;
        end
    end
    
    always @(posedge clk) begin
        q_reg <= q_next;
    end
    
    assign q = q_reg;
endmodule
",-0.5,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    reg q_next, q_reg;
    
    always @(posedge clk) begin
        if (r) begin
            q_next <= 1'b0;
        end else begin
            q_next <= d;
        end
    end
    
    always @(posedge clk) begin
        q_reg <= q_next;
    end
    
    assign q = q_reg;
endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    reg q_next, q_reg;
    
    always @(posedge clk) begin
        if (r) begin
            q_next <= 1'b0;
        end else begin
            q_next <= d;
        end
    end
    
    always @(posedge clk) begin
        q_reg <= q_next;
    end
    
    assign q = q_reg;
endmodule
"
"    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;  // reset
        end else begin
            q <= d;  // update q with d on clock edge
        end
    end

    assign q = q;  // output q
endmodule
",-1.0,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;  // reset
        end else begin
            q <= d;  // update q with d on clock edge
        end
    end

    assign q = q;  // output q
endmodule
","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    reg q;

    always @(posedge clk) begin
        if (r) begin
            q <= 1'b0;  // reset
        end else begin
            q <= d;  // update q with d on clock edge
        end
    end

    assign q = q;  // output q
endmodule
"
"    assign out = in;
endmodule
",1.0,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = in;
endmodule
","module top_module (
    input in,
    output out);

    assign out = in;
endmodule
"
"    assign out = ~in;
endmodule
",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
","module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
"
"    assign out = ~in;
endmodule
",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
","module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
"
"    assign out = in;
endmodule
",1.0,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = in;
endmodule
","module top_module (
    input in,
    output out);

    assign out = in;
endmodule
"
"    assign out = ~in;
endmodule
",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
","module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
"
"    assign out = ~in;
endmodule
",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
","module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
"
"    assign out = in;
endmodule
",1.0,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = in;
endmodule
","module top_module (
    input in,
    output out);

    assign out = in;
endmodule
"
"    assign out = ~in;
endmodule
",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
","module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
"
"    assign out = ~in; // out is the inverse of in
endmodule
",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = ~in; // out is the inverse of in
endmodule
","module top_module (
    input in,
    output out);

    assign out = ~in; // out is the inverse of in
endmodule
"
"    assign out = ~in;
endmodule
",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
","module top_module (
    input in,
    output out);

    assign out = ~in;
endmodule
"
"    reg [9:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
        end else begin
            if (counter == 999) begin
                counter <= 0;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
        end else begin
            if (counter == 999) begin
                counter <= 0;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
        end else begin
            if (counter == 999) begin
                counter <= 0;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
"
"
    reg [9:0] counter;
    
    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
        end else begin
            counter <= counter + 1;
        end
    end
    
    assign q = counter;
endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);


    reg [9:0] counter;
    
    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
        end else begin
            counter <= counter + 1;
        end
    end
    
    assign q = counter;
endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);


    reg [9:0] counter;
    
    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
        end else begin
            counter <= counter + 1;
        end
    end
    
    assign q = counter;
endmodule
"
"    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
"
"reg [9:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 10'b0;
    end else begin
        if (count == 10'd999) begin
            count <= 10'b0;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);

reg [9:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 10'b0;
    end else begin
        if (count == 10'd999) begin
            count <= 10'b0;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

reg [9:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 10'b0;
    end else begin
        if (count == 10'd999) begin
            count <= 10'b0;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
"
"    reg [9:0] counter;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            counter <= 0;
        end else begin
            if (counter == 999) begin
                counter <= 0;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;
endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] counter;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            counter <= 0;
        end else begin
            if (counter == 999) begin
                counter <= 0;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;
endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] counter;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            counter <= 0;
        end else begin
            if (counter == 999) begin
                counter <= 0;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;
endmodule
"
"
    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);


    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);


    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            count <= count + 1;
        end
    end

    assign q = count;

endmodule
"
"reg [9:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 0;
    end else begin
        if (count == 999) begin
            count <= 0;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);

reg [9:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 0;
    end else begin
        if (count == 999) begin
            count <= 0;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

reg [9:0] count;

always @(posedge clk) begin
    if (reset) begin
        count <= 0;
    end else begin
        if (count == 999) begin
            count <= 0;
        end else begin
            count <= count + 1;
        end
    end
end

assign q = count;

endmodule
"
"    reg [9:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
        end else begin
            if (counter == 999) begin
                counter <= 0;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
        end else begin
            if (counter == 999) begin
                counter <= 0;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] counter;

    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
        end else begin
            if (counter == 999) begin
                counter <= 0;
            end else begin
                counter <= counter + 1;
            end
        end
    end

    assign q = counter;

endmodule
"
"    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            if (count == 999) begin
                count <= 0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            if (count == 999) begin
                count <= 0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            if (count == 999) begin
                count <= 0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"
    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            if (count == 999) begin
                count <= 0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
",-0.5,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);


    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            if (count == 999) begin
                count <= 0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
","module top_module (
    input clk,
    input reset,
    output [9:0] q);


    reg [9:0] count;

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end else begin
            if (count == 999) begin
                count <= 0;
            end else begin
                count <= count + 1;
            end
        end
    end

    assign q = count;
endmodule
"
"// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAIT_FOR_ACK
} state_t;

// Define the module
module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack
);

// Internal signals
state_t state, next_state;
logic [3:0] delay;
logic [3:0] remaining_time;
logic [3:0] counter;
logic start_pattern_detected;
logic [3:0] count_reg;

// Always block for state machine
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 4'b0;
        counter <= 4'b0;
        remaining_time <= 4'b0;
        start_pattern_detected <= 1'b0;
        count_reg <= 4'b0;
    end else begin
        state <= next_state;
    end
end

// Combinational logic for next state and outputs
always_comb begin
    counting = (state == COUNTING);
    done = (state == WAIT_FOR_ACK);
    count = (state == COUNTING) ? remaining_time : count_reg;
end

// State machine logic
always_comb begin
    case (state)
        IDLE:
            if (data == 4'b1101) begin
                start_pattern_detected = 1'b1;
                next_state = DETECT_PATTERN;
            end else begin
                start_pattern_detected = 1'b0;
                next_state = IDLE;
            end
        DETECT_PATTERN:
            next_state = SHIFT_IN_DELAY;
        SHIFT_IN_DELAY:
            delay = {delay[2:0], data};
            next_state = COUNTING;
        COUNTING:
            if (counter == delay) begin
                remaining_time = remaining_time - 1;
                counter <= 4'b0;
                if (remaining_time == 4'b0) begin
                    next_state = WAIT_FOR_ACK;
                    count_reg <= 4'b0;
                end else begin
                    next_state = COUNTING;
                    count_reg <= remaining_time;
                end
            end else begin
                counter <= counter + 1;
                next_state = COUNTING;
            end
        WAIT_FOR_ACK:
            if (ack) begin
                next_state = IDLE;
            end else begin
                next_state = WAIT_FOR_ACK;
            end
    endcase
end

endmodule
",-1.0,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAIT_FOR_ACK
} state_t;

// Define the module
module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack
);

// Internal signals
state_t state, next_state;
logic [3:0] delay;
logic [3:0] remaining_time;
logic [3:0] counter;
logic start_pattern_detected;
logic [3:0] count_reg;

// Always block for state machine
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 4'b0;
        counter <= 4'b0;
        remaining_time <= 4'b0;
        start_pattern_detected <= 1'b0;
        count_reg <= 4'b0;
    end else begin
        state <= next_state;
    end
end

// Combinational logic for next state and outputs
always_comb begin
    counting = (state == COUNTING);
    done = (state == WAIT_FOR_ACK);
    count = (state == COUNTING) ? remaining_time : count_reg;
end

// State machine logic
always_comb begin
    case (state)
        IDLE:
            if (data == 4'b1101) begin
                start_pattern_detected = 1'b1;
                next_state = DETECT_PATTERN;
            end else begin
                start_pattern_detected = 1'b0;
                next_state = IDLE;
            end
        DETECT_PATTERN:
            next_state = SHIFT_IN_DELAY;
        SHIFT_IN_DELAY:
            delay = {delay[2:0], data};
            next_state = COUNTING;
        COUNTING:
            if (counter == delay) begin
                remaining_time = remaining_time - 1;
                counter <= 4'b0;
                if (remaining_time == 4'b0) begin
                    next_state = WAIT_FOR_ACK;
                    count_reg <= 4'b0;
                end else begin
                    next_state = COUNTING;
                    count_reg <= remaining_time;
                end
            end else begin
                counter <= counter + 1;
                next_state = COUNTING;
            end
        WAIT_FOR_ACK:
            if (ack) begin
                next_state = IDLE;
            end else begin
                next_state = WAIT_FOR_ACK;
            end
    endcase
end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAIT_FOR_ACK
} state_t;

// Define the module
module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack
);

// Internal signals
state_t state, next_state;
logic [3:0] delay;
logic [3:0] remaining_time;
logic [3:0] counter;
logic start_pattern_detected;
logic [3:0] count_reg;

// Always block for state machine
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 4'b0;
        counter <= 4'b0;
        remaining_time <= 4'b0;
        start_pattern_detected <= 1'b0;
        count_reg <= 4'b0;
    end else begin
        state <= next_state;
    end
end

// Combinational logic for next state and outputs
always_comb begin
    counting = (state == COUNTING);
    done = (state == WAIT_FOR_ACK);
    count = (state == COUNTING) ? remaining_time : count_reg;
end

// State machine logic
always_comb begin
    case (state)
        IDLE:
            if (data == 4'b1101) begin
                start_pattern_detected = 1'b1;
                next_state = DETECT_PATTERN;
            end else begin
                start_pattern_detected = 1'b0;
                next_state = IDLE;
            end
        DETECT_PATTERN:
            next_state = SHIFT_IN_DELAY;
        SHIFT_IN_DELAY:
            delay = {delay[2:0], data};
            next_state = COUNTING;
        COUNTING:
            if (counter == delay) begin
                remaining_time = remaining_time - 1;
                counter <= 4'b0;
                if (remaining_time == 4'b0) begin
                    next_state = WAIT_FOR_ACK;
                    count_reg <= 4'b0;
                end else begin
                    next_state = COUNTING;
                    count_reg <= remaining_time;
                end
            end else begin
                counter <= counter + 1;
                next_state = COUNTING;
            end
        WAIT_FOR_ACK:
            if (ack) begin
                next_state = IDLE;
            end else begin
                next_state = WAIT_FOR_ACK;
            end
    endcase
end

endmodule
"
"// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    DONE
} state_t;

// Define module inputs and outputs
input clk;
input reset;
input data;
output [3:0] count;
output counting;
output done;
input ack;

// Define internal signals
reg [3:0] delay;
reg [3:0] count_reg;
reg [2:0] state;
reg counting_reg;
reg done_reg;

// State machine logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        counting_reg <= 0;
        done_reg <= 0;
        count_reg <= 0;
    end else begin
        case(state)
            IDLE: begin
                if (data == 4'b1101) begin
                    state <= DETECT_PATTERN;
                end
            end
            DETECT_PATTERN: begin
                delay <= data;
                state <= SHIFT_IN_DELAY;
            end
            SHIFT_IN_DELAY: begin
                count_reg <= delay;
                state <= COUNTING;
            end
            COUNTING: begin
                if (count_reg == 0) begin
                    state <= DONE;
                end else begin
                    count_reg <= count_reg - 1;
                end
            end
            DONE: begin
                if (ack) begin
                    state <= IDLE;
                end
            end
        endcase
    end
end

// Output logic
assign count = count_reg;
assign counting = (state == COUNTING) ? 1'b1 : 1'b0;
assign done = (state == DONE) ? 1'b1 : 1'b0;

endmodule
",-1.0,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    DONE
} state_t;

// Define module inputs and outputs
input clk;
input reset;
input data;
output [3:0] count;
output counting;
output done;
input ack;

// Define internal signals
reg [3:0] delay;
reg [3:0] count_reg;
reg [2:0] state;
reg counting_reg;
reg done_reg;

// State machine logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        counting_reg <= 0;
        done_reg <= 0;
        count_reg <= 0;
    end else begin
        case(state)
            IDLE: begin
                if (data == 4'b1101) begin
                    state <= DETECT_PATTERN;
                end
            end
            DETECT_PATTERN: begin
                delay <= data;
                state <= SHIFT_IN_DELAY;
            end
            SHIFT_IN_DELAY: begin
                count_reg <= delay;
                state <= COUNTING;
            end
            COUNTING: begin
                if (count_reg == 0) begin
                    state <= DONE;
                end else begin
                    count_reg <= count_reg - 1;
                end
            end
            DONE: begin
                if (ack) begin
                    state <= IDLE;
                end
            end
        endcase
    end
end

// Output logic
assign count = count_reg;
assign counting = (state == COUNTING) ? 1'b1 : 1'b0;
assign done = (state == DONE) ? 1'b1 : 1'b0;

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    DONE
} state_t;

// Define module inputs and outputs
input clk;
input reset;
input data;
output [3:0] count;
output counting;
output done;
input ack;

// Define internal signals
reg [3:0] delay;
reg [3:0] count_reg;
reg [2:0] state;
reg counting_reg;
reg done_reg;

// State machine logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        counting_reg <= 0;
        done_reg <= 0;
        count_reg <= 0;
    end else begin
        case(state)
            IDLE: begin
                if (data == 4'b1101) begin
                    state <= DETECT_PATTERN;
                end
            end
            DETECT_PATTERN: begin
                delay <= data;
                state <= SHIFT_IN_DELAY;
            end
            SHIFT_IN_DELAY: begin
                count_reg <= delay;
                state <= COUNTING;
            end
            COUNTING: begin
                if (count_reg == 0) begin
                    state <= DONE;
                end else begin
                    count_reg <= count_reg - 1;
                end
            end
            DONE: begin
                if (ack) begin
                    state <= IDLE;
                end
            end
        endcase
    end
end

// Output logic
assign count = count_reg;
assign counting = (state == COUNTING) ? 1'b1 : 1'b0;
assign done = (state == DONE) ? 1'b1 : 1'b0;

endmodule
"
"    reg [3:0] delay;
    reg [3:0] count_reg;
    reg [3:0] remaining_time;
    reg counting;
    reg done;
    reg start_detected;
    reg [3:0] shift_reg;
    reg [1:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            delay <= 0;
            count_reg <= 0;
            remaining_time <= 0;
            counting <= 0;
            done <= 0;
            start_detected <= 0;
            shift_reg <= 0;
            state <= 0;
        end else begin
            if (start_detected) begin
                case (state)
                    0: begin
                        if (data == 1 && shift_reg < 4) begin
                            shift_reg <= shift_reg << 1;
                            shift_reg[0] <= data;
                        end else if (shift_reg == 4) begin
                            delay <= shift_reg;
                            state <= 1;
                        end
                    end
                    1: begin
                        counting <= 1;
                        if (count_reg < delay) begin
                            count_reg <= count_reg + 1;
                            remaining_time <= delay - count_reg;
                        end else begin
                            counting <= 0;
                            done <= 1;
                            state <= 2;
                        end
                    end
                    2: begin
                        if (ack) begin
                            start_detected <= 0;
                            state <= 0;
                        end
                    end
                endcase
            end else begin
                if (data == 1 && shift_reg == 0) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                end else if (shift_reg == 1 && data == 1) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                end else if (shift_reg == 3 && data == 1) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                end else if (shift_reg == 7 && data == 1) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                    start_detected <= 1;
                end else begin
                    shift_reg <= 0;
                end
            end
        end
    end

    assign count = counting ? remaining_time : 4'bxxxx;
    assign done = done;
    assign counting = counting;

endmodule
",-1.0,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    reg [3:0] delay;
    reg [3:0] count_reg;
    reg [3:0] remaining_time;
    reg counting;
    reg done;
    reg start_detected;
    reg [3:0] shift_reg;
    reg [1:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            delay <= 0;
            count_reg <= 0;
            remaining_time <= 0;
            counting <= 0;
            done <= 0;
            start_detected <= 0;
            shift_reg <= 0;
            state <= 0;
        end else begin
            if (start_detected) begin
                case (state)
                    0: begin
                        if (data == 1 && shift_reg < 4) begin
                            shift_reg <= shift_reg << 1;
                            shift_reg[0] <= data;
                        end else if (shift_reg == 4) begin
                            delay <= shift_reg;
                            state <= 1;
                        end
                    end
                    1: begin
                        counting <= 1;
                        if (count_reg < delay) begin
                            count_reg <= count_reg + 1;
                            remaining_time <= delay - count_reg;
                        end else begin
                            counting <= 0;
                            done <= 1;
                            state <= 2;
                        end
                    end
                    2: begin
                        if (ack) begin
                            start_detected <= 0;
                            state <= 0;
                        end
                    end
                endcase
            end else begin
                if (data == 1 && shift_reg == 0) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                end else if (shift_reg == 1 && data == 1) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                end else if (shift_reg == 3 && data == 1) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                end else if (shift_reg == 7 && data == 1) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                    start_detected <= 1;
                end else begin
                    shift_reg <= 0;
                end
            end
        end
    end

    assign count = counting ? remaining_time : 4'bxxxx;
    assign done = done;
    assign counting = counting;

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    reg [3:0] delay;
    reg [3:0] count_reg;
    reg [3:0] remaining_time;
    reg counting;
    reg done;
    reg start_detected;
    reg [3:0] shift_reg;
    reg [1:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            delay <= 0;
            count_reg <= 0;
            remaining_time <= 0;
            counting <= 0;
            done <= 0;
            start_detected <= 0;
            shift_reg <= 0;
            state <= 0;
        end else begin
            if (start_detected) begin
                case (state)
                    0: begin
                        if (data == 1 && shift_reg < 4) begin
                            shift_reg <= shift_reg << 1;
                            shift_reg[0] <= data;
                        end else if (shift_reg == 4) begin
                            delay <= shift_reg;
                            state <= 1;
                        end
                    end
                    1: begin
                        counting <= 1;
                        if (count_reg < delay) begin
                            count_reg <= count_reg + 1;
                            remaining_time <= delay - count_reg;
                        end else begin
                            counting <= 0;
                            done <= 1;
                            state <= 2;
                        end
                    end
                    2: begin
                        if (ack) begin
                            start_detected <= 0;
                            state <= 0;
                        end
                    end
                endcase
            end else begin
                if (data == 1 && shift_reg == 0) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                end else if (shift_reg == 1 && data == 1) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                end else if (shift_reg == 3 && data == 1) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                end else if (shift_reg == 7 && data == 1) begin
                    shift_reg <= shift_reg << 1;
                    shift_reg[0] <= data;
                    start_detected <= 1;
                end else begin
                    shift_reg <= 0;
                end
            end
        end
    end

    assign count = counting ? remaining_time : 4'bxxxx;
    assign done = done;
    assign counting = counting;

endmodule
"
"// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN,
    COUNTING,
    DONE
} state_t;

// Define parameters for the timer
parameter DELAY_WIDTH = 4;
parameter CYCLES_PER_COUNT = 1000;

// Define registers for the state machine
reg [2:0] state, next_state;
reg [DELAY_WIDTH-1:0] delay;
reg [DELAY_WIDTH-1:0] count_reg;
reg [3:0] count;

// Define outputs
assign counting = (state == COUNTING);
assign done = (state == DONE);

// State machine logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
    end else begin
        state <= next_state;
        count <= count_reg;
    end
end

// State machine transitions
always @* begin
    next_state = state;
    case (state)
        IDLE: begin
            if (data == 4'b1101) begin
                next_state = DETECT_PATTERN;
            end
        end
        DETECT_PATTERN: begin
            next_state = SHIFT_IN;
        end
        SHIFT_IN: begin
            if (count_reg < DELAY_WIDTH) begin
                delay[count_reg] <= data;
                count_reg <= count_reg + 1;
            end else begin
                next_state = COUNTING;
            end
        end
        COUNTING: begin
            if (count_reg < (delay + 1)) begin
                count_reg <= count_reg + 1;
            end else begin
                next_state = DONE;
            end
        end
        DONE: begin
            if (ack) begin
                next_state = IDLE;
                delay <= 0;
                count_reg <= 0;
            end
        end
    endcase
end

// Reset logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
    end
end

endmodule
",-0.5,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN,
    COUNTING,
    DONE
} state_t;

// Define parameters for the timer
parameter DELAY_WIDTH = 4;
parameter CYCLES_PER_COUNT = 1000;

// Define registers for the state machine
reg [2:0] state, next_state;
reg [DELAY_WIDTH-1:0] delay;
reg [DELAY_WIDTH-1:0] count_reg;
reg [3:0] count;

// Define outputs
assign counting = (state == COUNTING);
assign done = (state == DONE);

// State machine logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
    end else begin
        state <= next_state;
        count <= count_reg;
    end
end

// State machine transitions
always @* begin
    next_state = state;
    case (state)
        IDLE: begin
            if (data == 4'b1101) begin
                next_state = DETECT_PATTERN;
            end
        end
        DETECT_PATTERN: begin
            next_state = SHIFT_IN;
        end
        SHIFT_IN: begin
            if (count_reg < DELAY_WIDTH) begin
                delay[count_reg] <= data;
                count_reg <= count_reg + 1;
            end else begin
                next_state = COUNTING;
            end
        end
        COUNTING: begin
            if (count_reg < (delay + 1)) begin
                count_reg <= count_reg + 1;
            end else begin
                next_state = DONE;
            end
        end
        DONE: begin
            if (ack) begin
                next_state = IDLE;
                delay <= 0;
                count_reg <= 0;
            end
        end
    endcase
end

// Reset logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
    end
end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN,
    COUNTING,
    DONE
} state_t;

// Define parameters for the timer
parameter DELAY_WIDTH = 4;
parameter CYCLES_PER_COUNT = 1000;

// Define registers for the state machine
reg [2:0] state, next_state;
reg [DELAY_WIDTH-1:0] delay;
reg [DELAY_WIDTH-1:0] count_reg;
reg [3:0] count;

// Define outputs
assign counting = (state == COUNTING);
assign done = (state == DONE);

// State machine logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
    end else begin
        state <= next_state;
        count <= count_reg;
    end
end

// State machine transitions
always @* begin
    next_state = state;
    case (state)
        IDLE: begin
            if (data == 4'b1101) begin
                next_state = DETECT_PATTERN;
            end
        end
        DETECT_PATTERN: begin
            next_state = SHIFT_IN;
        end
        SHIFT_IN: begin
            if (count_reg < DELAY_WIDTH) begin
                delay[count_reg] <= data;
                count_reg <= count_reg + 1;
            end else begin
                next_state = COUNTING;
            end
        end
        COUNTING: begin
            if (count_reg < (delay + 1)) begin
                count_reg <= count_reg + 1;
            end else begin
                next_state = DONE;
            end
        end
        DONE: begin
            if (ack) begin
                next_state = IDLE;
                delay <= 0;
                count_reg <= 0;
            end
        end
    endcase
end

// Reset logic
always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
    end
end

endmodule
"
"// Define states for the state machine
parameter IDLE = 2'b00;
parameter DETECT_PATTERN = 2'b01;
parameter COUNTING = 2'b10;
parameter WAIT_ACK = 2'b11;

reg [1:0] state;
reg [3:0] delay_counter;
reg [3:0] remaining_time;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay_counter <= 4'b0000;
        count <= 4'bxxxx;
        counting <= 1'b0;
        done <= 1'b0;
        remaining_time <= 4'b0000;
    end else begin
        case (state)
            IDLE: begin
                if (data == 4'b1101) begin
                    state <= DETECT_PATTERN;
                    delay_counter <= 4'b0000;
                end
            end
            DETECT_PATTERN: begin
                delay_counter <= {delay_counter[2:0], data};
                state <= COUNTING;
                counting <= 1'b1;
            end
            COUNTING: begin
                if (delay_counter == 4'b1111) begin
                    state <= WAIT_ACK;
                    counting <= 1'b0;
                    done <= 1'b1;
                end else begin
                    delay_counter <= delay_counter + 1;
                    remaining_time <= delay_counter;
                end
            end
            WAIT_ACK: begin
                if (ack) begin
                    state <= IDLE;
                    done <= 1'b0;
                end
            end
        endcase
    end
end

assign count = counting ? remaining_time : 4'bxxxx;

endmodule
",-1.0,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
parameter IDLE = 2'b00;
parameter DETECT_PATTERN = 2'b01;
parameter COUNTING = 2'b10;
parameter WAIT_ACK = 2'b11;

reg [1:0] state;
reg [3:0] delay_counter;
reg [3:0] remaining_time;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay_counter <= 4'b0000;
        count <= 4'bxxxx;
        counting <= 1'b0;
        done <= 1'b0;
        remaining_time <= 4'b0000;
    end else begin
        case (state)
            IDLE: begin
                if (data == 4'b1101) begin
                    state <= DETECT_PATTERN;
                    delay_counter <= 4'b0000;
                end
            end
            DETECT_PATTERN: begin
                delay_counter <= {delay_counter[2:0], data};
                state <= COUNTING;
                counting <= 1'b1;
            end
            COUNTING: begin
                if (delay_counter == 4'b1111) begin
                    state <= WAIT_ACK;
                    counting <= 1'b0;
                    done <= 1'b1;
                end else begin
                    delay_counter <= delay_counter + 1;
                    remaining_time <= delay_counter;
                end
            end
            WAIT_ACK: begin
                if (ack) begin
                    state <= IDLE;
                    done <= 1'b0;
                end
            end
        endcase
    end
end

assign count = counting ? remaining_time : 4'bxxxx;

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
parameter IDLE = 2'b00;
parameter DETECT_PATTERN = 2'b01;
parameter COUNTING = 2'b10;
parameter WAIT_ACK = 2'b11;

reg [1:0] state;
reg [3:0] delay_counter;
reg [3:0] remaining_time;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay_counter <= 4'b0000;
        count <= 4'bxxxx;
        counting <= 1'b0;
        done <= 1'b0;
        remaining_time <= 4'b0000;
    end else begin
        case (state)
            IDLE: begin
                if (data == 4'b1101) begin
                    state <= DETECT_PATTERN;
                    delay_counter <= 4'b0000;
                end
            end
            DETECT_PATTERN: begin
                delay_counter <= {delay_counter[2:0], data};
                state <= COUNTING;
                counting <= 1'b1;
            end
            COUNTING: begin
                if (delay_counter == 4'b1111) begin
                    state <= WAIT_ACK;
                    counting <= 1'b0;
                    done <= 1'b1;
                end else begin
                    delay_counter <= delay_counter + 1;
                    remaining_time <= delay_counter;
                end
            end
            WAIT_ACK: begin
                if (ack) begin
                    state <= IDLE;
                    done <= 1'b0;
                end
            end
        endcase
    end
end

assign count = counting ? remaining_time : 4'bxxxx;

endmodule
"
"// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN,
    COUNTING,
    DONE_WAIT_ACK
} state_t;

// Define parameters for the timer
parameter DELAY_BITS = 4;
parameter CYCLE_DELAY = 1000;

// Define registers for the state machine
reg [2:0] state_reg, state_next;
reg [DELAY_BITS-1:0] delay_reg, delay_next;
reg [DELAY_BITS-1:0] count_reg, count_next;
reg counting_reg, counting_next;
reg done_reg, done_next;

// Define internal signals
reg [3:0] remaining_time;

// State machine logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= IDLE;
        delay_reg <= 0;
        count_reg <= 0;
        counting_reg <= 0;
        done_reg <= 0;
    end else begin
        state_reg <= state_next;
        delay_reg <= delay_next;
        count_reg <= count_next;
        counting_reg <= counting_next;
        done_reg <= done_next;
    end
end

// State machine transitions and logic
always_comb begin
    state_next = state_reg;
    delay_next = delay_reg;
    count_next = count_reg;
    counting_next = counting_reg;
    done_next = done_reg;
    remaining_time = delay_reg;

    case (state_reg)
        IDLE: begin
            if (data == 4'b1101) begin
                state_next = DETECT_PATTERN;
            end
        end
        DETECT_PATTERN: begin
            state_next = SHIFT_IN;
        end
        SHIFT_IN: begin
            delay_next = data[3:0];
            state_next = COUNTING;
        end
        COUNTING: begin
            if (count_reg < delay_reg) begin
                count_next = count_reg + 1;
                counting_next = 1;
            end else begin
                count_next = 0;
                counting_next = 0;
                state_next = DONE_WAIT_ACK;
            end
        end
        DONE_WAIT_ACK: begin
            if (ack) begin
                done_next = 1;
                state_next = IDLE;
            end
        end
    endcase
end

// Output assignments
assign count = count_reg;
assign counting = counting_reg;
assign done = done_reg;
",-1.0,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN,
    COUNTING,
    DONE_WAIT_ACK
} state_t;

// Define parameters for the timer
parameter DELAY_BITS = 4;
parameter CYCLE_DELAY = 1000;

// Define registers for the state machine
reg [2:0] state_reg, state_next;
reg [DELAY_BITS-1:0] delay_reg, delay_next;
reg [DELAY_BITS-1:0] count_reg, count_next;
reg counting_reg, counting_next;
reg done_reg, done_next;

// Define internal signals
reg [3:0] remaining_time;

// State machine logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= IDLE;
        delay_reg <= 0;
        count_reg <= 0;
        counting_reg <= 0;
        done_reg <= 0;
    end else begin
        state_reg <= state_next;
        delay_reg <= delay_next;
        count_reg <= count_next;
        counting_reg <= counting_next;
        done_reg <= done_next;
    end
end

// State machine transitions and logic
always_comb begin
    state_next = state_reg;
    delay_next = delay_reg;
    count_next = count_reg;
    counting_next = counting_reg;
    done_next = done_reg;
    remaining_time = delay_reg;

    case (state_reg)
        IDLE: begin
            if (data == 4'b1101) begin
                state_next = DETECT_PATTERN;
            end
        end
        DETECT_PATTERN: begin
            state_next = SHIFT_IN;
        end
        SHIFT_IN: begin
            delay_next = data[3:0];
            state_next = COUNTING;
        end
        COUNTING: begin
            if (count_reg < delay_reg) begin
                count_next = count_reg + 1;
                counting_next = 1;
            end else begin
                count_next = 0;
                counting_next = 0;
                state_next = DONE_WAIT_ACK;
            end
        end
        DONE_WAIT_ACK: begin
            if (ack) begin
                done_next = 1;
                state_next = IDLE;
            end
        end
    endcase
end

// Output assignments
assign count = count_reg;
assign counting = counting_reg;
assign done = done_reg;
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN,
    COUNTING,
    DONE_WAIT_ACK
} state_t;

// Define parameters for the timer
parameter DELAY_BITS = 4;
parameter CYCLE_DELAY = 1000;

// Define registers for the state machine
reg [2:0] state_reg, state_next;
reg [DELAY_BITS-1:0] delay_reg, delay_next;
reg [DELAY_BITS-1:0] count_reg, count_next;
reg counting_reg, counting_next;
reg done_reg, done_next;

// Define internal signals
reg [3:0] remaining_time;

// State machine logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state_reg <= IDLE;
        delay_reg <= 0;
        count_reg <= 0;
        counting_reg <= 0;
        done_reg <= 0;
    end else begin
        state_reg <= state_next;
        delay_reg <= delay_next;
        count_reg <= count_next;
        counting_reg <= counting_next;
        done_reg <= done_next;
    end
end

// State machine transitions and logic
always_comb begin
    state_next = state_reg;
    delay_next = delay_reg;
    count_next = count_reg;
    counting_next = counting_reg;
    done_next = done_reg;
    remaining_time = delay_reg;

    case (state_reg)
        IDLE: begin
            if (data == 4'b1101) begin
                state_next = DETECT_PATTERN;
            end
        end
        DETECT_PATTERN: begin
            state_next = SHIFT_IN;
        end
        SHIFT_IN: begin
            delay_next = data[3:0];
            state_next = COUNTING;
        end
        COUNTING: begin
            if (count_reg < delay_reg) begin
                count_next = count_reg + 1;
                counting_next = 1;
            end else begin
                count_next = 0;
                counting_next = 0;
                state_next = DONE_WAIT_ACK;
            end
        end
        DONE_WAIT_ACK: begin
            if (ack) begin
                done_next = 1;
                state_next = IDLE;
            end
        end
    endcase
end

// Output assignments
assign count = count_reg;
assign counting = counting_reg;
assign done = done_reg;
"
"// Define states for the state machine
parameter IDLE = 2'b00;
parameter DETECT_PATTERN = 2'b01;
parameter SHIFT_IN_BITS = 2'b10;
parameter COUNTING = 2'b11;

reg [1:0] state, next_state;
reg [3:0] delay;
reg [3:0] counter;
reg [3:0] remaining_time;

always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        counter <= 4'b0;
        delay <= 4'b0;
        remaining_time <= 4'b0;
    end else begin
        state <= next_state;
        counter <= counter + 1;
        remaining_time <= delay - counter[3:0];
    end
end

always @ (*) begin
    case(state)
        IDLE: begin
            if (data == 1 && $past(data) == 1 && $past(past(data)) == 0 && $past(past(past(data))) == 1) begin
                next_state = DETECT_PATTERN;
            end else begin
                next_state = IDLE;
            end
        end
        DETECT_PATTERN: begin
            next_state = SHIFT_IN_BITS;
        end
        SHIFT_IN_BITS: begin
            if (counter < 4) begin
                delay[counter] = data;
                next_state = SHIFT_IN_BITS;
            end else begin
                next_state = COUNTING;
            end
        end
        COUNTING: begin
            if (counter == (delay + 1) * 1000) begin
                next_state = done;
            end else begin
                next_state = COUNTING;
            end
        end
        default: next_state = IDLE;
    endcase
end

assign count = counting ? remaining_time : 4'b0;
assign counting = (state == COUNTING);
assign done = (state == done);

endmodule
",-1.0,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
parameter IDLE = 2'b00;
parameter DETECT_PATTERN = 2'b01;
parameter SHIFT_IN_BITS = 2'b10;
parameter COUNTING = 2'b11;

reg [1:0] state, next_state;
reg [3:0] delay;
reg [3:0] counter;
reg [3:0] remaining_time;

always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        counter <= 4'b0;
        delay <= 4'b0;
        remaining_time <= 4'b0;
    end else begin
        state <= next_state;
        counter <= counter + 1;
        remaining_time <= delay - counter[3:0];
    end
end

always @ (*) begin
    case(state)
        IDLE: begin
            if (data == 1 && $past(data) == 1 && $past(past(data)) == 0 && $past(past(past(data))) == 1) begin
                next_state = DETECT_PATTERN;
            end else begin
                next_state = IDLE;
            end
        end
        DETECT_PATTERN: begin
            next_state = SHIFT_IN_BITS;
        end
        SHIFT_IN_BITS: begin
            if (counter < 4) begin
                delay[counter] = data;
                next_state = SHIFT_IN_BITS;
            end else begin
                next_state = COUNTING;
            end
        end
        COUNTING: begin
            if (counter == (delay + 1) * 1000) begin
                next_state = done;
            end else begin
                next_state = COUNTING;
            end
        end
        default: next_state = IDLE;
    endcase
end

assign count = counting ? remaining_time : 4'b0;
assign counting = (state == COUNTING);
assign done = (state == done);

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
parameter IDLE = 2'b00;
parameter DETECT_PATTERN = 2'b01;
parameter SHIFT_IN_BITS = 2'b10;
parameter COUNTING = 2'b11;

reg [1:0] state, next_state;
reg [3:0] delay;
reg [3:0] counter;
reg [3:0] remaining_time;

always @ (posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        counter <= 4'b0;
        delay <= 4'b0;
        remaining_time <= 4'b0;
    end else begin
        state <= next_state;
        counter <= counter + 1;
        remaining_time <= delay - counter[3:0];
    end
end

always @ (*) begin
    case(state)
        IDLE: begin
            if (data == 1 && $past(data) == 1 && $past(past(data)) == 0 && $past(past(past(data))) == 1) begin
                next_state = DETECT_PATTERN;
            end else begin
                next_state = IDLE;
            end
        end
        DETECT_PATTERN: begin
            next_state = SHIFT_IN_BITS;
        end
        SHIFT_IN_BITS: begin
            if (counter < 4) begin
                delay[counter] = data;
                next_state = SHIFT_IN_BITS;
            end else begin
                next_state = COUNTING;
            end
        end
        COUNTING: begin
            if (counter == (delay + 1) * 1000) begin
                next_state = done;
            end else begin
                next_state = COUNTING;
            end
        end
        default: next_state = IDLE;
    endcase
end

assign count = counting ? remaining_time : 4'b0;
assign counting = (state == COUNTING);
assign done = (state == done);

endmodule
"
"// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAITING_FOR_ACK
} state_t;

// Define signals for the state machine
state_t state, next_state;
logic [3:0] delay;
logic [3:0] count_reg;
logic [3:0] remaining_time;

// Define constants for the timer duration calculation
localparam COUNT_CYCLES = 1000;

// Define registers for the state machine
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        count_reg <= 4'b0;
        delay <= 4'b0;
        remaining_time <= 4'b0;
    end else begin
        state <= next_state;
        count_reg <= (state == COUNTING) ? count_reg - 1 : 4'b0;
        remaining_time <= (state == COUNTING) ? count_reg : 4'b0;
    end
end

// Define combinational logic for the state transitions
always_comb begin
    next_state = state;
    case(state)
        IDLE: begin
            if (data == 4'b1101) begin
                next_state = DETECT_PATTERN;
            end
        end
        DETECT_PATTERN: begin
            next_state = SHIFT_IN_DELAY;
        end
        SHIFT_IN_DELAY: begin
            delay = {data, delay[3:1]};
            next_state = COUNTING;
        end
        COUNTING: begin
            if (count_reg == 0) begin
                next_state = WAITING_FOR_ACK;
            end
        end
        WAITING_FOR_ACK: begin
            if (ack) begin
                next_state = IDLE;
            end
        end
    endcase
end

// Define output logic
assign count = count_reg;
assign counting = (state == COUNTING) ? 1 : 0;
assign done = (state == WAITING_FOR_ACK) ? 1 : 0;

endmodule
",-0.5,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAITING_FOR_ACK
} state_t;

// Define signals for the state machine
state_t state, next_state;
logic [3:0] delay;
logic [3:0] count_reg;
logic [3:0] remaining_time;

// Define constants for the timer duration calculation
localparam COUNT_CYCLES = 1000;

// Define registers for the state machine
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        count_reg <= 4'b0;
        delay <= 4'b0;
        remaining_time <= 4'b0;
    end else begin
        state <= next_state;
        count_reg <= (state == COUNTING) ? count_reg - 1 : 4'b0;
        remaining_time <= (state == COUNTING) ? count_reg : 4'b0;
    end
end

// Define combinational logic for the state transitions
always_comb begin
    next_state = state;
    case(state)
        IDLE: begin
            if (data == 4'b1101) begin
                next_state = DETECT_PATTERN;
            end
        end
        DETECT_PATTERN: begin
            next_state = SHIFT_IN_DELAY;
        end
        SHIFT_IN_DELAY: begin
            delay = {data, delay[3:1]};
            next_state = COUNTING;
        end
        COUNTING: begin
            if (count_reg == 0) begin
                next_state = WAITING_FOR_ACK;
            end
        end
        WAITING_FOR_ACK: begin
            if (ack) begin
                next_state = IDLE;
            end
        end
    endcase
end

// Define output logic
assign count = count_reg;
assign counting = (state == COUNTING) ? 1 : 0;
assign done = (state == WAITING_FOR_ACK) ? 1 : 0;

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAITING_FOR_ACK
} state_t;

// Define signals for the state machine
state_t state, next_state;
logic [3:0] delay;
logic [3:0] count_reg;
logic [3:0] remaining_time;

// Define constants for the timer duration calculation
localparam COUNT_CYCLES = 1000;

// Define registers for the state machine
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        count_reg <= 4'b0;
        delay <= 4'b0;
        remaining_time <= 4'b0;
    end else begin
        state <= next_state;
        count_reg <= (state == COUNTING) ? count_reg - 1 : 4'b0;
        remaining_time <= (state == COUNTING) ? count_reg : 4'b0;
    end
end

// Define combinational logic for the state transitions
always_comb begin
    next_state = state;
    case(state)
        IDLE: begin
            if (data == 4'b1101) begin
                next_state = DETECT_PATTERN;
            end
        end
        DETECT_PATTERN: begin
            next_state = SHIFT_IN_DELAY;
        end
        SHIFT_IN_DELAY: begin
            delay = {data, delay[3:1]};
            next_state = COUNTING;
        end
        COUNTING: begin
            if (count_reg == 0) begin
                next_state = WAITING_FOR_ACK;
            end
        end
        WAITING_FOR_ACK: begin
            if (ack) begin
                next_state = IDLE;
            end
        end
    endcase
end

// Define output logic
assign count = count_reg;
assign counting = (state == COUNTING) ? 1 : 0;
assign done = (state == WAITING_FOR_ACK) ? 1 : 0;

endmodule
"
"// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAIT_FOR_ACK
} state_t;

// Define parameters for the delay calculation
parameter CYCLES_PER_DELAY = 1000;

// Define registers for the state machine
reg [2:0] state, next_state;
reg [3:0] delay;
reg [3:0] count_reg;
reg counting_reg;
reg done_reg;

// Define counter for counting cycles
reg [11:0] cycle_counter;

// Define shift register for shifting in delay bits
reg [3:0] delay_shift_reg;
reg [3:0] delay_reg;

// Define shift register for input pattern detection
reg [3:0] pattern_reg;

always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
        counting_reg <= 0;
        done_reg <= 0;
        cycle_counter <= 0;
        delay_shift_reg <= 0;
        delay_reg <= 0;
        pattern_reg <= 0;
    end else begin
        state <= next_state;
        count_reg <= counting_reg ? count_reg - 1 : count_reg;
    end
end

always_comb begin
    case(state)
        IDLE: begin
            if (data == 4'b1101) begin
                next_state = DETECT_PATTERN;
            end else begin
                next_state = IDLE;
            end
        end
        DETECT_PATTERN: begin
            pattern_reg <= {pattern_reg[2:0], data};
            if (pattern_reg == 4'b1101) begin
                next_state = SHIFT_IN_DELAY;
            end else begin
                next_state = DETECT_PATTERN;
            end
        end
        SHIFT_IN_DELAY: begin
            delay_shift_reg <= {delay_shift_reg[2:0], data};
            if (delay_shift_reg == 4'b1111) begin
                delay_reg <= 0;
            end else begin
                delay_reg <= delay_shift_reg;
            end
            next_state = COUNTING;
        end
        COUNTING: begin
            if (cycle_counter < (delay_reg + 1) * CYCLES_PER_DELAY) begin
                counting_reg = 1;
                cycle_counter <= cycle_counter + 1;
            end else begin
                counting_reg = 0;
                done_reg = 1;
                next_state = WAIT_FOR_ACK;
            end
        end
        WAIT_FOR_ACK: begin
            if (ack) begin
                done_reg = 0;
                next_state = IDLE;
            end else begin
                next_state = WAIT_FOR_ACK;
            end
        end
    endcase
end

assign count = count_reg;
assign counting = counting_reg;
assign done = done_reg;
",-1.0,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAIT_FOR_ACK
} state_t;

// Define parameters for the delay calculation
parameter CYCLES_PER_DELAY = 1000;

// Define registers for the state machine
reg [2:0] state, next_state;
reg [3:0] delay;
reg [3:0] count_reg;
reg counting_reg;
reg done_reg;

// Define counter for counting cycles
reg [11:0] cycle_counter;

// Define shift register for shifting in delay bits
reg [3:0] delay_shift_reg;
reg [3:0] delay_reg;

// Define shift register for input pattern detection
reg [3:0] pattern_reg;

always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
        counting_reg <= 0;
        done_reg <= 0;
        cycle_counter <= 0;
        delay_shift_reg <= 0;
        delay_reg <= 0;
        pattern_reg <= 0;
    end else begin
        state <= next_state;
        count_reg <= counting_reg ? count_reg - 1 : count_reg;
    end
end

always_comb begin
    case(state)
        IDLE: begin
            if (data == 4'b1101) begin
                next_state = DETECT_PATTERN;
            end else begin
                next_state = IDLE;
            end
        end
        DETECT_PATTERN: begin
            pattern_reg <= {pattern_reg[2:0], data};
            if (pattern_reg == 4'b1101) begin
                next_state = SHIFT_IN_DELAY;
            end else begin
                next_state = DETECT_PATTERN;
            end
        end
        SHIFT_IN_DELAY: begin
            delay_shift_reg <= {delay_shift_reg[2:0], data};
            if (delay_shift_reg == 4'b1111) begin
                delay_reg <= 0;
            end else begin
                delay_reg <= delay_shift_reg;
            end
            next_state = COUNTING;
        end
        COUNTING: begin
            if (cycle_counter < (delay_reg + 1) * CYCLES_PER_DELAY) begin
                counting_reg = 1;
                cycle_counter <= cycle_counter + 1;
            end else begin
                counting_reg = 0;
                done_reg = 1;
                next_state = WAIT_FOR_ACK;
            end
        end
        WAIT_FOR_ACK: begin
            if (ack) begin
                done_reg = 0;
                next_state = IDLE;
            end else begin
                next_state = WAIT_FOR_ACK;
            end
        end
    endcase
end

assign count = count_reg;
assign counting = counting_reg;
assign done = done_reg;
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAIT_FOR_ACK
} state_t;

// Define parameters for the delay calculation
parameter CYCLES_PER_DELAY = 1000;

// Define registers for the state machine
reg [2:0] state, next_state;
reg [3:0] delay;
reg [3:0] count_reg;
reg counting_reg;
reg done_reg;

// Define counter for counting cycles
reg [11:0] cycle_counter;

// Define shift register for shifting in delay bits
reg [3:0] delay_shift_reg;
reg [3:0] delay_reg;

// Define shift register for input pattern detection
reg [3:0] pattern_reg;

always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
        counting_reg <= 0;
        done_reg <= 0;
        cycle_counter <= 0;
        delay_shift_reg <= 0;
        delay_reg <= 0;
        pattern_reg <= 0;
    end else begin
        state <= next_state;
        count_reg <= counting_reg ? count_reg - 1 : count_reg;
    end
end

always_comb begin
    case(state)
        IDLE: begin
            if (data == 4'b1101) begin
                next_state = DETECT_PATTERN;
            end else begin
                next_state = IDLE;
            end
        end
        DETECT_PATTERN: begin
            pattern_reg <= {pattern_reg[2:0], data};
            if (pattern_reg == 4'b1101) begin
                next_state = SHIFT_IN_DELAY;
            end else begin
                next_state = DETECT_PATTERN;
            end
        end
        SHIFT_IN_DELAY: begin
            delay_shift_reg <= {delay_shift_reg[2:0], data};
            if (delay_shift_reg == 4'b1111) begin
                delay_reg <= 0;
            end else begin
                delay_reg <= delay_shift_reg;
            end
            next_state = COUNTING;
        end
        COUNTING: begin
            if (cycle_counter < (delay_reg + 1) * CYCLES_PER_DELAY) begin
                counting_reg = 1;
                cycle_counter <= cycle_counter + 1;
            end else begin
                counting_reg = 0;
                done_reg = 1;
                next_state = WAIT_FOR_ACK;
            end
        end
        WAIT_FOR_ACK: begin
            if (ack) begin
                done_reg = 0;
                next_state = IDLE;
            end else begin
                next_state = WAIT_FOR_ACK;
            end
        end
    endcase
end

assign count = count_reg;
assign counting = counting_reg;
assign done = done_reg;
"
"// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAIT_FOR_ACK
} state_t;

// Define parameters
parameter PATTERN = 4'b1101;

// Define registers
reg [3:0] delay;
reg [3:0] count_reg;
reg [3:0] remaining_time;
reg [2:0] state;
reg counting;
reg done;

// Define state machine logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
        remaining_time <= 0;
        counting <= 0;
        done <= 0;
    end else begin
        case(state)
            IDLE: begin
                if (data == PATTERN) begin
                    state <= DETECT_PATTERN;
                end
            end
            DETECT_PATTERN: begin
                state <= SHIFT_IN_DELAY;
            end
            SHIFT_IN_DELAY: begin
                delay <= {data, delay[3:1]};
                state <= COUNTING;
            end
            COUNTING: begin
                if (count_reg == (delay + 1)) begin
                    state <= WAIT_FOR_ACK;
                    counting <= 0;
                end else begin
                    counting <= 1;
                    count_reg <= count_reg + 1;
                    if (remaining_time == 0) begin
                        remaining_time <= delay;
                    end else begin
                        remaining_time <= remaining_time - 1;
                    end
                end
            end
            WAIT_FOR_ACK: begin
                if (ack) begin
                    state <= IDLE;
                    done <= 1;
                end
            end
        endcase
    end
end

// Output logic
assign count = counting ? remaining_time : 4'bxxxx;
assign done = done;
",-1.0,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAIT_FOR_ACK
} state_t;

// Define parameters
parameter PATTERN = 4'b1101;

// Define registers
reg [3:0] delay;
reg [3:0] count_reg;
reg [3:0] remaining_time;
reg [2:0] state;
reg counting;
reg done;

// Define state machine logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
        remaining_time <= 0;
        counting <= 0;
        done <= 0;
    end else begin
        case(state)
            IDLE: begin
                if (data == PATTERN) begin
                    state <= DETECT_PATTERN;
                end
            end
            DETECT_PATTERN: begin
                state <= SHIFT_IN_DELAY;
            end
            SHIFT_IN_DELAY: begin
                delay <= {data, delay[3:1]};
                state <= COUNTING;
            end
            COUNTING: begin
                if (count_reg == (delay + 1)) begin
                    state <= WAIT_FOR_ACK;
                    counting <= 0;
                end else begin
                    counting <= 1;
                    count_reg <= count_reg + 1;
                    if (remaining_time == 0) begin
                        remaining_time <= delay;
                    end else begin
                        remaining_time <= remaining_time - 1;
                    end
                end
            end
            WAIT_FOR_ACK: begin
                if (ack) begin
                    state <= IDLE;
                    done <= 1;
                end
            end
        endcase
    end
end

// Output logic
assign count = counting ? remaining_time : 4'bxxxx;
assign done = done;
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

// Define states for the state machine
typedef enum logic [2:0] {
    IDLE,
    DETECT_PATTERN,
    SHIFT_IN_DELAY,
    COUNTING,
    WAIT_FOR_ACK
} state_t;

// Define parameters
parameter PATTERN = 4'b1101;

// Define registers
reg [3:0] delay;
reg [3:0] count_reg;
reg [3:0] remaining_time;
reg [2:0] state;
reg counting;
reg done;

// Define state machine logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        delay <= 0;
        count_reg <= 0;
        remaining_time <= 0;
        counting <= 0;
        done <= 0;
    end else begin
        case(state)
            IDLE: begin
                if (data == PATTERN) begin
                    state <= DETECT_PATTERN;
                end
            end
            DETECT_PATTERN: begin
                state <= SHIFT_IN_DELAY;
            end
            SHIFT_IN_DELAY: begin
                delay <= {data, delay[3:1]};
                state <= COUNTING;
            end
            COUNTING: begin
                if (count_reg == (delay + 1)) begin
                    state <= WAIT_FOR_ACK;
                    counting <= 0;
                end else begin
                    counting <= 1;
                    count_reg <= count_reg + 1;
                    if (remaining_time == 0) begin
                        remaining_time <= delay;
                    end else begin
                        remaining_time <= remaining_time - 1;
                    end
                end
            end
            WAIT_FOR_ACK: begin
                if (ack) begin
                    state <= IDLE;
                    done <= 1;
                end
            end
        endcase
    end
end

// Output logic
assign count = counting ? remaining_time : 4'bxxxx;
assign done = done;
"
"
    // Define states
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_FOR_COUNTERS,
        NOTIFY_USER,
        WAIT_FOR_ACK
    } state_t;

    // Define state and next_state variables
    state_t state, next_state;

    // Define internal signals
    reg [3:0] shift_counter;

    // State machine logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_counter <= 0;
        end else begin
            state <= next_state;
        end
    end

    // State transitions and outputs
    always @* begin
        shift_ena = 0;
        counting = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (data == 1 && $past(data) == 1 && $past($past(data)) == 0) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end

            DETECT_PATTERN: begin
                shift_ena = 1;
                next_state = SHIFT_DELAY;
            end

            SHIFT_DELAY: begin
                if (shift_counter < 4) begin
                    shift_counter <= shift_counter + 1;
                end else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            WAIT_FOR_COUNTERS: begin
                counting = 1;
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            NOTIFY_USER: begin
                done = 1;
                if (ack) begin
                    next_state = WAIT_FOR_ACK;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end

            WAIT_FOR_ACK: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = WAIT_FOR_ACK;
                end
            end
        endcase
    end
endmodule
",-1.0,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_FOR_COUNTERS,
        NOTIFY_USER,
        WAIT_FOR_ACK
    } state_t;

    // Define state and next_state variables
    state_t state, next_state;

    // Define internal signals
    reg [3:0] shift_counter;

    // State machine logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_counter <= 0;
        end else begin
            state <= next_state;
        end
    end

    // State transitions and outputs
    always @* begin
        shift_ena = 0;
        counting = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (data == 1 && $past(data) == 1 && $past($past(data)) == 0) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end

            DETECT_PATTERN: begin
                shift_ena = 1;
                next_state = SHIFT_DELAY;
            end

            SHIFT_DELAY: begin
                if (shift_counter < 4) begin
                    shift_counter <= shift_counter + 1;
                end else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            WAIT_FOR_COUNTERS: begin
                counting = 1;
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            NOTIFY_USER: begin
                done = 1;
                if (ack) begin
                    next_state = WAIT_FOR_ACK;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end

            WAIT_FOR_ACK: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = WAIT_FOR_ACK;
                end
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_FOR_COUNTERS,
        NOTIFY_USER,
        WAIT_FOR_ACK
    } state_t;

    // Define state and next_state variables
    state_t state, next_state;

    // Define internal signals
    reg [3:0] shift_counter;

    // State machine logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_counter <= 0;
        end else begin
            state <= next_state;
        end
    end

    // State transitions and outputs
    always @* begin
        shift_ena = 0;
        counting = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (data == 1 && $past(data) == 1 && $past($past(data)) == 0) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end

            DETECT_PATTERN: begin
                shift_ena = 1;
                next_state = SHIFT_DELAY;
            end

            SHIFT_DELAY: begin
                if (shift_counter < 4) begin
                    shift_counter <= shift_counter + 1;
                end else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            WAIT_FOR_COUNTERS: begin
                counting = 1;
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            NOTIFY_USER: begin
                done = 1;
                if (ack) begin
                    next_state = WAIT_FOR_ACK;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end

            WAIT_FOR_ACK: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = WAIT_FOR_ACK;
                end
            end
        endcase
    end
endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            case (state)
                3'b000: begin // Waiting for start sequence
                    if (data == 1 && $past(data) == 1 && $past($past(data)) == 0 && $past($past($past(data))) == 1) begin
                        state <= 3'b001; // Start sequence detected
                    end else begin
                        state <= 3'b000;
                    end
                end
                3'b001: begin // Shift in 4 more bits
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin // Wait for counters
                    shift_ena <= 0;
                    counting <= 1;
                    if (done_counting) begin
                        state <= 3'b011;
                    end
                end
                3'b011: begin // Notify user and wait for ack
                    done <= 1;
                    if (ack) begin
                        done <= 0;
                        counting <= 0;
                        state <= 3'b000;
                    end
                end
            endcase
        end
    end
endmodule
",-1.0,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            case (state)
                3'b000: begin // Waiting for start sequence
                    if (data == 1 && $past(data) == 1 && $past($past(data)) == 0 && $past($past($past(data))) == 1) begin
                        state <= 3'b001; // Start sequence detected
                    end else begin
                        state <= 3'b000;
                    end
                end
                3'b001: begin // Shift in 4 more bits
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin // Wait for counters
                    shift_ena <= 0;
                    counting <= 1;
                    if (done_counting) begin
                        state <= 3'b011;
                    end
                end
                3'b011: begin // Notify user and wait for ack
                    done <= 1;
                    if (ack) begin
                        done <= 0;
                        counting <= 0;
                        state <= 3'b000;
                    end
                end
            endcase
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            case (state)
                3'b000: begin // Waiting for start sequence
                    if (data == 1 && $past(data) == 1 && $past($past(data)) == 0 && $past($past($past(data))) == 1) begin
                        state <= 3'b001; // Start sequence detected
                    end else begin
                        state <= 3'b000;
                    end
                end
                3'b001: begin // Shift in 4 more bits
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin // Wait for counters
                    shift_ena <= 0;
                    counting <= 1;
                    if (done_counting) begin
                        state <= 3'b011;
                    end
                end
                3'b011: begin // Notify user and wait for ack
                    done <= 1;
                    if (ack) begin
                        done <= 0;
                        counting <= 0;
                        state <= 3'b000;
                    end
                end
            endcase
        end
    end
endmodule
"
"
    // Define the states of the state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_t;

    // Define the state register and next state logic
    state_t state_reg, state_next;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state_reg <= IDLE;
        end else begin
            state_reg <= state_next;
        end
    end

    // Define the state machine logic
    always_comb begin
        case (state_reg)
            IDLE: begin
                if (data == 4'b1101) begin
                    state_next = DETECT_PATTERN;
                end else begin
                    state_next = IDLE;
                end
            end
            DETECT_PATTERN: begin
                state_next = SHIFT_DELAY;
            end
            SHIFT_DELAY: begin
                if (shift_ena == 4) begin
                    state_next = WAIT_COUNTING;
                end else begin
                    state_next = SHIFT_DELAY;
                end
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    state_next = NOTIFY_USER;
                end else begin
                    state_next = WAIT_COUNTING;
                end
            end
            NOTIFY_USER: begin
                if (ack) begin
                    state_next = WAIT_ACK;
                end else begin
                    state_next = NOTIFY_USER;
                end
            end
            WAIT_ACK: begin
                if (ack) begin
                    state_next = IDLE;
                end else begin
                    state_next = WAIT_ACK;
                end
            end
        endcase
    end

    // Output logic
    assign shift_ena = (state_reg == SHIFT_DELAY);
    assign counting = (state_reg == WAIT_COUNTING);
    assign done = (state_reg == NOTIFY_USER);
endmodule
",-0.5,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define the states of the state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_t;

    // Define the state register and next state logic
    state_t state_reg, state_next;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state_reg <= IDLE;
        end else begin
            state_reg <= state_next;
        end
    end

    // Define the state machine logic
    always_comb begin
        case (state_reg)
            IDLE: begin
                if (data == 4'b1101) begin
                    state_next = DETECT_PATTERN;
                end else begin
                    state_next = IDLE;
                end
            end
            DETECT_PATTERN: begin
                state_next = SHIFT_DELAY;
            end
            SHIFT_DELAY: begin
                if (shift_ena == 4) begin
                    state_next = WAIT_COUNTING;
                end else begin
                    state_next = SHIFT_DELAY;
                end
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    state_next = NOTIFY_USER;
                end else begin
                    state_next = WAIT_COUNTING;
                end
            end
            NOTIFY_USER: begin
                if (ack) begin
                    state_next = WAIT_ACK;
                end else begin
                    state_next = NOTIFY_USER;
                end
            end
            WAIT_ACK: begin
                if (ack) begin
                    state_next = IDLE;
                end else begin
                    state_next = WAIT_ACK;
                end
            end
        endcase
    end

    // Output logic
    assign shift_ena = (state_reg == SHIFT_DELAY);
    assign counting = (state_reg == WAIT_COUNTING);
    assign done = (state_reg == NOTIFY_USER);
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define the states of the state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_t;

    // Define the state register and next state logic
    state_t state_reg, state_next;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state_reg <= IDLE;
        end else begin
            state_reg <= state_next;
        end
    end

    // Define the state machine logic
    always_comb begin
        case (state_reg)
            IDLE: begin
                if (data == 4'b1101) begin
                    state_next = DETECT_PATTERN;
                end else begin
                    state_next = IDLE;
                end
            end
            DETECT_PATTERN: begin
                state_next = SHIFT_DELAY;
            end
            SHIFT_DELAY: begin
                if (shift_ena == 4) begin
                    state_next = WAIT_COUNTING;
                end else begin
                    state_next = SHIFT_DELAY;
                end
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    state_next = NOTIFY_USER;
                end else begin
                    state_next = WAIT_COUNTING;
                end
            end
            NOTIFY_USER: begin
                if (ack) begin
                    state_next = WAIT_ACK;
                end else begin
                    state_next = NOTIFY_USER;
                end
            end
            WAIT_ACK: begin
                if (ack) begin
                    state_next = IDLE;
                end else begin
                    state_next = WAIT_ACK;
                end
            end
        endcase
    end

    // Output logic
    assign shift_ena = (state_reg == SHIFT_DELAY);
    assign counting = (state_reg == WAIT_COUNTING);
    assign done = (state_reg == NOTIFY_USER);
endmodule
"
"
    // Define states for the finite state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_t;

    // Define state and next_state variables
    state_t state, next_state;

    // Define internal registers
    reg [3:0] shift_counter;

    // Initialize state and internal registers
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_counter <= 4'b0;
        end else begin
            state <= next_state;
            shift_counter <= (state == SHIFT_DELAY) ? shift_counter + 1 : 4'b0;
        end
    end

    // Define state transitions and outputs
    always_comb begin
        case (state)
            IDLE: begin
                if (data == 4'b1101) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b0;
            end
            DETECT_PATTERN: begin
                next_state = SHIFT_DELAY;
                shift_ena = 1'b1;
                counting = 1'b0;
                done = 1'b0;
            end
            SHIFT_DELAY: begin
                if (shift_counter == 4) begin
                    next_state = WAIT_COUNTING;
                end else begin
                    next_state = SHIFT_DELAY;
                end
                shift_ena = 1'b0;
                counting = 1'b1;
                done = 1'b0;
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_COUNTING;
                end
                shift_ena = 1'b0;
                counting = 1'b1;
                done = 1'b0;
            end
            NOTIFY_USER: begin
                next_state = WAIT_ACK;
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b1;
            end
            WAIT_ACK: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = WAIT_ACK;
                end
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b1;
            end
            default: begin
                next_state = IDLE;
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b0;
            end
        endcase
    end
endmodule
",-1.0,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states for the finite state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_t;

    // Define state and next_state variables
    state_t state, next_state;

    // Define internal registers
    reg [3:0] shift_counter;

    // Initialize state and internal registers
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_counter <= 4'b0;
        end else begin
            state <= next_state;
            shift_counter <= (state == SHIFT_DELAY) ? shift_counter + 1 : 4'b0;
        end
    end

    // Define state transitions and outputs
    always_comb begin
        case (state)
            IDLE: begin
                if (data == 4'b1101) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b0;
            end
            DETECT_PATTERN: begin
                next_state = SHIFT_DELAY;
                shift_ena = 1'b1;
                counting = 1'b0;
                done = 1'b0;
            end
            SHIFT_DELAY: begin
                if (shift_counter == 4) begin
                    next_state = WAIT_COUNTING;
                end else begin
                    next_state = SHIFT_DELAY;
                end
                shift_ena = 1'b0;
                counting = 1'b1;
                done = 1'b0;
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_COUNTING;
                end
                shift_ena = 1'b0;
                counting = 1'b1;
                done = 1'b0;
            end
            NOTIFY_USER: begin
                next_state = WAIT_ACK;
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b1;
            end
            WAIT_ACK: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = WAIT_ACK;
                end
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b1;
            end
            default: begin
                next_state = IDLE;
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b0;
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states for the finite state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_t;

    // Define state and next_state variables
    state_t state, next_state;

    // Define internal registers
    reg [3:0] shift_counter;

    // Initialize state and internal registers
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_counter <= 4'b0;
        end else begin
            state <= next_state;
            shift_counter <= (state == SHIFT_DELAY) ? shift_counter + 1 : 4'b0;
        end
    end

    // Define state transitions and outputs
    always_comb begin
        case (state)
            IDLE: begin
                if (data == 4'b1101) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b0;
            end
            DETECT_PATTERN: begin
                next_state = SHIFT_DELAY;
                shift_ena = 1'b1;
                counting = 1'b0;
                done = 1'b0;
            end
            SHIFT_DELAY: begin
                if (shift_counter == 4) begin
                    next_state = WAIT_COUNTING;
                end else begin
                    next_state = SHIFT_DELAY;
                end
                shift_ena = 1'b0;
                counting = 1'b1;
                done = 1'b0;
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_COUNTING;
                end
                shift_ena = 1'b0;
                counting = 1'b1;
                done = 1'b0;
            end
            NOTIFY_USER: begin
                next_state = WAIT_ACK;
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b1;
            end
            WAIT_ACK: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = WAIT_ACK;
                end
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b1;
            end
            default: begin
                next_state = IDLE;
                shift_ena = 1'b0;
                counting = 1'b0;
                done = 1'b0;
            end
        endcase
    end
endmodule
"
"
  reg [2:0] state;

  // State machine logic
  always @ (posedge clk or posedge reset) begin
    if (reset) begin
      state <= 3'b000; // Initial state
    end else begin
      case (state)
        3'b000: begin // State 0: Waiting for start sequence
          if (data == 4'b1101) begin
            state <= 3'b001; // Transition to state 1
          end else begin
            state <= 3'b000; // Stay in state 0
          end
        end
        3'b001: begin // State 1: Shift in 4 more bits
          shift_ena <= 1;
          state <= 3'b010; // Transition to state 2
        end
        3'b010: begin // State 2: Waiting for counters
          counting <= 1;
          if (done_counting) begin
            state <= 3'b011; // Transition to state 3
          end else begin
            state <= 3'b010; // Stay in state 2
          end
        end
        3'b011: begin // State 3: Timer has timed out
          done <= 1;
          if (ack) begin
            state <= 3'b000; // Transition back to state 0
          end else begin
            state <= 3'b011; // Stay in state 3
          end
        end
      endcase
    end
  end
endmodule
",-1.0,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


  reg [2:0] state;

  // State machine logic
  always @ (posedge clk or posedge reset) begin
    if (reset) begin
      state <= 3'b000; // Initial state
    end else begin
      case (state)
        3'b000: begin // State 0: Waiting for start sequence
          if (data == 4'b1101) begin
            state <= 3'b001; // Transition to state 1
          end else begin
            state <= 3'b000; // Stay in state 0
          end
        end
        3'b001: begin // State 1: Shift in 4 more bits
          shift_ena <= 1;
          state <= 3'b010; // Transition to state 2
        end
        3'b010: begin // State 2: Waiting for counters
          counting <= 1;
          if (done_counting) begin
            state <= 3'b011; // Transition to state 3
          end else begin
            state <= 3'b010; // Stay in state 2
          end
        end
        3'b011: begin // State 3: Timer has timed out
          done <= 1;
          if (ack) begin
            state <= 3'b000; // Transition back to state 0
          end else begin
            state <= 3'b011; // Stay in state 3
          end
        end
      endcase
    end
  end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


  reg [2:0] state;

  // State machine logic
  always @ (posedge clk or posedge reset) begin
    if (reset) begin
      state <= 3'b000; // Initial state
    end else begin
      case (state)
        3'b000: begin // State 0: Waiting for start sequence
          if (data == 4'b1101) begin
            state <= 3'b001; // Transition to state 1
          end else begin
            state <= 3'b000; // Stay in state 0
          end
        end
        3'b001: begin // State 1: Shift in 4 more bits
          shift_ena <= 1;
          state <= 3'b010; // Transition to state 2
        end
        3'b010: begin // State 2: Waiting for counters
          counting <= 1;
          if (done_counting) begin
            state <= 3'b011; // Transition to state 3
          end else begin
            state <= 3'b010; // Stay in state 2
          end
        end
        3'b011: begin // State 3: Timer has timed out
          done <= 1;
          if (ack) begin
            state <= 3'b000; // Transition back to state 0
          end else begin
            state <= 3'b011; // Stay in state 3
          end
        end
      endcase
    end
  end
endmodule
"
"
    // Define the states of the state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_IN,
        WAIT_FOR_COUNTERS,
        NOTIFY_USER,
        WAIT_FOR_ACK
    } state_t;

    // Define the signals for the state machine
    state_t state, next_state;
    logic [3:0] counter;

    // Initialize the state machine
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            counter <= 4'b0;
        end else begin
            state <= next_state;
            counter <= (state == SHIFT_IN) ? counter + 1 : 4'b0;
        end
    end

    // State machine logic
    always_comb begin
        shift_ena = 1'b0;
        counting = 1'b0;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (data == 1'b1 && $past(data) == 1'b1 && $past($past(data)) == 1'b0 && $past($past($past(data))) == 1'b1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end

            DETECT_PATTERN: begin
                shift_ena = 1'b1;
                next_state = SHIFT_IN;
            end

            SHIFT_IN: begin
                if (counter == 4'b1111) begin
                    counting = 1'b1;
                    next_state = WAIT_FOR_COUNTERS;
                end else begin
                    next_state = SHIFT_IN;
                end
            end

            WAIT_FOR_COUNTERS: begin
                if (done_counting) begin
                    done = 1'b1;
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            NOTIFY_USER: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end

            default: next_state = IDLE;
        endcase
    end
endmodule
",-1.0,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define the states of the state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_IN,
        WAIT_FOR_COUNTERS,
        NOTIFY_USER,
        WAIT_FOR_ACK
    } state_t;

    // Define the signals for the state machine
    state_t state, next_state;
    logic [3:0] counter;

    // Initialize the state machine
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            counter <= 4'b0;
        end else begin
            state <= next_state;
            counter <= (state == SHIFT_IN) ? counter + 1 : 4'b0;
        end
    end

    // State machine logic
    always_comb begin
        shift_ena = 1'b0;
        counting = 1'b0;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (data == 1'b1 && $past(data) == 1'b1 && $past($past(data)) == 1'b0 && $past($past($past(data))) == 1'b1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end

            DETECT_PATTERN: begin
                shift_ena = 1'b1;
                next_state = SHIFT_IN;
            end

            SHIFT_IN: begin
                if (counter == 4'b1111) begin
                    counting = 1'b1;
                    next_state = WAIT_FOR_COUNTERS;
                end else begin
                    next_state = SHIFT_IN;
                end
            end

            WAIT_FOR_COUNTERS: begin
                if (done_counting) begin
                    done = 1'b1;
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            NOTIFY_USER: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end

            default: next_state = IDLE;
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define the states of the state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_IN,
        WAIT_FOR_COUNTERS,
        NOTIFY_USER,
        WAIT_FOR_ACK
    } state_t;

    // Define the signals for the state machine
    state_t state, next_state;
    logic [3:0] counter;

    // Initialize the state machine
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            counter <= 4'b0;
        end else begin
            state <= next_state;
            counter <= (state == SHIFT_IN) ? counter + 1 : 4'b0;
        end
    end

    // State machine logic
    always_comb begin
        shift_ena = 1'b0;
        counting = 1'b0;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (data == 1'b1 && $past(data) == 1'b1 && $past($past(data)) == 1'b0 && $past($past($past(data))) == 1'b1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end

            DETECT_PATTERN: begin
                shift_ena = 1'b1;
                next_state = SHIFT_IN;
            end

            SHIFT_IN: begin
                if (counter == 4'b1111) begin
                    counting = 1'b1;
                    next_state = WAIT_FOR_COUNTERS;
                end else begin
                    next_state = SHIFT_IN;
                end
            end

            WAIT_FOR_COUNTERS: begin
                if (done_counting) begin
                    done = 1'b1;
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            NOTIFY_USER: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end

            default: next_state = IDLE;
        endcase
    end
endmodule
"
"
    // Define states for the finite state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_type;

    // Define state and next_state variables
    state_type state, next_state;

    // Define shift counter variable
    reg [3:0] shift_counter;

    // Define state machine logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_counter <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Define next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (data == 1'b1 && $past(data) == 1'b1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end
            DETECT_PATTERN: begin
                next_state = SHIFT_DELAY;
            end
            SHIFT_DELAY: begin
                if (shift_counter < 4) begin
                    next_state = SHIFT_DELAY;
                end else begin
                    next_state = WAIT_COUNTING;
                end
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_COUNTING;
                end
            end
            NOTIFY_USER: begin
                if (ack) begin
                    next_state = WAIT_ACK;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end
            WAIT_ACK: begin
                if (data == 1'b1 && $past(data) == 1'b1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = WAIT_ACK;
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Define output logic
    assign shift_ena = (state == SHIFT_DELAY) ? 1 : 0;
    assign counting = (state == WAIT_COUNTING) ? 1 : 0;
    assign done = (state == NOTIFY_USER) ? 1 : 0;
",-1.0,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states for the finite state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_type;

    // Define state and next_state variables
    state_type state, next_state;

    // Define shift counter variable
    reg [3:0] shift_counter;

    // Define state machine logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_counter <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Define next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (data == 1'b1 && $past(data) == 1'b1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end
            DETECT_PATTERN: begin
                next_state = SHIFT_DELAY;
            end
            SHIFT_DELAY: begin
                if (shift_counter < 4) begin
                    next_state = SHIFT_DELAY;
                end else begin
                    next_state = WAIT_COUNTING;
                end
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_COUNTING;
                end
            end
            NOTIFY_USER: begin
                if (ack) begin
                    next_state = WAIT_ACK;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end
            WAIT_ACK: begin
                if (data == 1'b1 && $past(data) == 1'b1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = WAIT_ACK;
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Define output logic
    assign shift_ena = (state == SHIFT_DELAY) ? 1 : 0;
    assign counting = (state == WAIT_COUNTING) ? 1 : 0;
    assign done = (state == NOTIFY_USER) ? 1 : 0;
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states for the finite state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_type;

    // Define state and next_state variables
    state_type state, next_state;

    // Define shift counter variable
    reg [3:0] shift_counter;

    // Define state machine logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_counter <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Define next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (data == 1'b1 && $past(data) == 1'b1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end
            DETECT_PATTERN: begin
                next_state = SHIFT_DELAY;
            end
            SHIFT_DELAY: begin
                if (shift_counter < 4) begin
                    next_state = SHIFT_DELAY;
                end else begin
                    next_state = WAIT_COUNTING;
                end
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_COUNTING;
                end
            end
            NOTIFY_USER: begin
                if (ack) begin
                    next_state = WAIT_ACK;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end
            WAIT_ACK: begin
                if (data == 1'b1 && $past(data) == 1'b1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = WAIT_ACK;
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Define output logic
    assign shift_ena = (state == SHIFT_DELAY) ? 1 : 0;
    assign counting = (state == WAIT_COUNTING) ? 1 : 0;
    assign done = (state == NOTIFY_USER) ? 1 : 0;
"
"
    // Define states for the finite-state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_IN,
        WAIT_FOR_COUNTERS,
        NOTIFY_USER,
        WAIT_FOR_ACK
    } state_t;

    // Define state and next_state variables
    state_t state, next_state;

    // Define counter variable to keep track of the number of clock cycles for shift_ena
    reg [3:0] counter;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            counter <= 0;
        end
        else begin
            state <= next_state;
        end
    end

    always_comb begin
        shift_ena = 0;
        counting = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (data == 1 && $past(data) == 1 && $past($past(data)) == 0) begin
                    next_state = DETECT_PATTERN;
                end
                else begin
                    next_state = IDLE;
                end
            end

            DETECT_PATTERN: begin
                shift_ena = 1;
                counter <= counter + 1;
                if (counter == 4) begin
                    next_state = SHIFT_IN;
                    counter <= 0;
                end
                else begin
                    next_state = DETECT_PATTERN;
                end
            end

            SHIFT_IN: begin
                shift_ena = 0;
                counting = 1;
                next_state = WAIT_FOR_COUNTERS;
            end

            WAIT_FOR_COUNTERS: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end
                else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            NOTIFY_USER: begin
                done = 1;
                next_state = WAIT_FOR_ACK;
            end

            WAIT_FOR_ACK: begin
                if (ack) begin
                    next_state = IDLE;
                end
                else begin
                    next_state = WAIT_FOR_ACK;
                end
            end
        endcase
    end
endmodule
",-1.0,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states for the finite-state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_IN,
        WAIT_FOR_COUNTERS,
        NOTIFY_USER,
        WAIT_FOR_ACK
    } state_t;

    // Define state and next_state variables
    state_t state, next_state;

    // Define counter variable to keep track of the number of clock cycles for shift_ena
    reg [3:0] counter;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            counter <= 0;
        end
        else begin
            state <= next_state;
        end
    end

    always_comb begin
        shift_ena = 0;
        counting = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (data == 1 && $past(data) == 1 && $past($past(data)) == 0) begin
                    next_state = DETECT_PATTERN;
                end
                else begin
                    next_state = IDLE;
                end
            end

            DETECT_PATTERN: begin
                shift_ena = 1;
                counter <= counter + 1;
                if (counter == 4) begin
                    next_state = SHIFT_IN;
                    counter <= 0;
                end
                else begin
                    next_state = DETECT_PATTERN;
                end
            end

            SHIFT_IN: begin
                shift_ena = 0;
                counting = 1;
                next_state = WAIT_FOR_COUNTERS;
            end

            WAIT_FOR_COUNTERS: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end
                else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            NOTIFY_USER: begin
                done = 1;
                next_state = WAIT_FOR_ACK;
            end

            WAIT_FOR_ACK: begin
                if (ack) begin
                    next_state = IDLE;
                end
                else begin
                    next_state = WAIT_FOR_ACK;
                end
            end
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states for the finite-state machine
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_IN,
        WAIT_FOR_COUNTERS,
        NOTIFY_USER,
        WAIT_FOR_ACK
    } state_t;

    // Define state and next_state variables
    state_t state, next_state;

    // Define counter variable to keep track of the number of clock cycles for shift_ena
    reg [3:0] counter;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            counter <= 0;
        end
        else begin
            state <= next_state;
        end
    end

    always_comb begin
        shift_ena = 0;
        counting = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (data == 1 && $past(data) == 1 && $past($past(data)) == 0) begin
                    next_state = DETECT_PATTERN;
                end
                else begin
                    next_state = IDLE;
                end
            end

            DETECT_PATTERN: begin
                shift_ena = 1;
                counter <= counter + 1;
                if (counter == 4) begin
                    next_state = SHIFT_IN;
                    counter <= 0;
                end
                else begin
                    next_state = DETECT_PATTERN;
                end
            end

            SHIFT_IN: begin
                shift_ena = 0;
                counting = 1;
                next_state = WAIT_FOR_COUNTERS;
            end

            WAIT_FOR_COUNTERS: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end
                else begin
                    next_state = WAIT_FOR_COUNTERS;
                end
            end

            NOTIFY_USER: begin
                done = 1;
                next_state = WAIT_FOR_ACK;
            end

            WAIT_FOR_ACK: begin
                if (ack) begin
                    next_state = IDLE;
                end
                else begin
                    next_state = WAIT_FOR_ACK;
                end
            end
        endcase
    end
endmodule
"
"
  reg [3:0] state;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      state <= 4'b0000; // Initial state
    end else begin
      case (state)
        4'b0000: begin // Waiting for start sequence
          if (data == 4'b1101) begin
            state <= 4'b0001; // Transition to next state
          end
        end
        4'b0001: begin // Shift in 4 more bits
          shift_ena <= 1;
          state <= 4'b0010; // Transition to next state
        end
        4'b0010: begin // Waiting for counters
          shift_ena <= 0;
          counting <= 1;
          if (done_counting) begin
            state <= 4'b0011; // Transition to next state
          end
        end
        4'b0011: begin // Notify user and wait for ack
          done <= 1;
          if (ack) begin
            done <= 0;
            counting <= 0;
            state <= 4'b0000; // Reset to initial state
          end
        end
      endcase
    end
  end
endmodule
",-1.0,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


  reg [3:0] state;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      state <= 4'b0000; // Initial state
    end else begin
      case (state)
        4'b0000: begin // Waiting for start sequence
          if (data == 4'b1101) begin
            state <= 4'b0001; // Transition to next state
          end
        end
        4'b0001: begin // Shift in 4 more bits
          shift_ena <= 1;
          state <= 4'b0010; // Transition to next state
        end
        4'b0010: begin // Waiting for counters
          shift_ena <= 0;
          counting <= 1;
          if (done_counting) begin
            state <= 4'b0011; // Transition to next state
          end
        end
        4'b0011: begin // Notify user and wait for ack
          done <= 1;
          if (ack) begin
            done <= 0;
            counting <= 0;
            state <= 4'b0000; // Reset to initial state
          end
        end
      endcase
    end
  end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


  reg [3:0] state;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      state <= 4'b0000; // Initial state
    end else begin
      case (state)
        4'b0000: begin // Waiting for start sequence
          if (data == 4'b1101) begin
            state <= 4'b0001; // Transition to next state
          end
        end
        4'b0001: begin // Shift in 4 more bits
          shift_ena <= 1;
          state <= 4'b0010; // Transition to next state
        end
        4'b0010: begin // Waiting for counters
          shift_ena <= 0;
          counting <= 1;
          if (done_counting) begin
            state <= 4'b0011; // Transition to next state
          end
        end
        4'b0011: begin // Notify user and wait for ack
          done <= 1;
          if (ack) begin
            done <= 0;
            counting <= 0;
            state <= 4'b0000; // Reset to initial state
          end
        end
      endcase
    end
  end
endmodule
"
"
    // Define states
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Define outputs
    assign shift_ena = (state == SHIFT_DELAY);
    assign counting = (state == WAIT_COUNTING);
    assign done = (state == NOTIFY_USER);

    // State machine logic
    always_comb begin
        case (state)
            IDLE: begin
                if (data == 1 && $past(data) == 1 && $past($past(data)) == 0 && $past($past($past(data))) == 1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end
            DETECT_PATTERN: begin
                next_state = SHIFT_DELAY;
            end
            SHIFT_DELAY: begin
                next_state = WAIT_COUNTING;
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_COUNTING;
                end
            end
            NOTIFY_USER: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end
            default: next_state = IDLE;
        endcase
    end
endmodule
",-0.5,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Define outputs
    assign shift_ena = (state == SHIFT_DELAY);
    assign counting = (state == WAIT_COUNTING);
    assign done = (state == NOTIFY_USER);

    // State machine logic
    always_comb begin
        case (state)
            IDLE: begin
                if (data == 1 && $past(data) == 1 && $past($past(data)) == 0 && $past($past($past(data))) == 1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end
            DETECT_PATTERN: begin
                next_state = SHIFT_DELAY;
            end
            SHIFT_DELAY: begin
                next_state = WAIT_COUNTING;
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_COUNTING;
                end
            end
            NOTIFY_USER: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end
            default: next_state = IDLE;
        endcase
    end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );


    // Define states
    typedef enum logic [2:0] {
        IDLE,
        DETECT_PATTERN,
        SHIFT_DELAY,
        WAIT_COUNTING,
        NOTIFY_USER,
        WAIT_ACK
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Define outputs
    assign shift_ena = (state == SHIFT_DELAY);
    assign counting = (state == WAIT_COUNTING);
    assign done = (state == NOTIFY_USER);

    // State machine logic
    always_comb begin
        case (state)
            IDLE: begin
                if (data == 1 && $past(data) == 1 && $past($past(data)) == 0 && $past($past($past(data))) == 1) begin
                    next_state = DETECT_PATTERN;
                end else begin
                    next_state = IDLE;
                end
            end
            DETECT_PATTERN: begin
                next_state = SHIFT_DELAY;
            end
            SHIFT_DELAY: begin
                next_state = WAIT_COUNTING;
            end
            WAIT_COUNTING: begin
                if (done_counting) begin
                    next_state = NOTIFY_USER;
                end else begin
                    next_state = WAIT_COUNTING;
                end
            end
            NOTIFY_USER: begin
                if (ack) begin
                    next_state = IDLE;
                end else begin
                    next_state = NOTIFY_USER;
                end
            end
            default: next_state = IDLE;
        endcase
    end
endmodule
"
"
    // Define states
    parameter IDLE = 2'b00;
    parameter FOUND_1 = 2'b01;
    parameter FOUND_11 = 2'b10;
    parameter FOUND_110 = 2'b11;
    
    // Define state register and next state logic
    reg [1:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Define output
    reg start_shifting;
    
    // State transition and output logic
    always @* begin
        start_shifting = 0;
        
        case (state)
            IDLE: begin
                if (data == 1)
                    next_state = FOUND_1;
                else
                    next_state = IDLE;
            end
            FOUND_1: begin
                if (data == 1)
                    next_state = FOUND_11;
                else
                    next_state = IDLE;
            end
            FOUND_11: begin
                if (data == 0)
                    next_state = IDLE;
                else
                    next_state = FOUND_110;
            end
            FOUND_110: begin
                if (data == 1) begin
                    next_state = FOUND_1;
                    start_shifting = 1;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end

endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    parameter IDLE = 2'b00;
    parameter FOUND_1 = 2'b01;
    parameter FOUND_11 = 2'b10;
    parameter FOUND_110 = 2'b11;
    
    // Define state register and next state logic
    reg [1:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Define output
    reg start_shifting;
    
    // State transition and output logic
    always @* begin
        start_shifting = 0;
        
        case (state)
            IDLE: begin
                if (data == 1)
                    next_state = FOUND_1;
                else
                    next_state = IDLE;
            end
            FOUND_1: begin
                if (data == 1)
                    next_state = FOUND_11;
                else
                    next_state = IDLE;
            end
            FOUND_11: begin
                if (data == 0)
                    next_state = IDLE;
                else
                    next_state = FOUND_110;
            end
            FOUND_110: begin
                if (data == 1) begin
                    next_state = FOUND_1;
                    start_shifting = 1;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    parameter IDLE = 2'b00;
    parameter FOUND_1 = 2'b01;
    parameter FOUND_11 = 2'b10;
    parameter FOUND_110 = 2'b11;
    
    // Define state register and next state logic
    reg [1:0] state, next_state;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Define output
    reg start_shifting;
    
    // State transition and output logic
    always @* begin
        start_shifting = 0;
        
        case (state)
            IDLE: begin
                if (data == 1)
                    next_state = FOUND_1;
                else
                    next_state = IDLE;
            end
            FOUND_1: begin
                if (data == 1)
                    next_state = FOUND_11;
                else
                    next_state = IDLE;
            end
            FOUND_11: begin
                if (data == 0)
                    next_state = IDLE;
                else
                    next_state = FOUND_110;
            end
            FOUND_110: begin
                if (data == 1) begin
                    next_state = FOUND_1;
                    start_shifting = 1;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end

endmodule
"
"
    // Define states
    typedef enum logic [2:0] {
        S0, // Initial state
        S1,
        S2,
        S3,
        FINAL // Sequence found
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Output
    reg start_shifting;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == FINAL) ? 1 : 0;
        end
    end

    // State transition logic
    always_comb begin
        next_state = state;
        case (state)
            S0: if (data) next_state = S1;
            S1: if (data) next_state = S2; else next_state = S0;
            S2: if (data) next_state = S3; else next_state = S0;
            S3: if (data) next_state = FINAL; else next_state = S0;
            FINAL: next_state = FINAL;
        endcase
    end

endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0, // Initial state
        S1,
        S2,
        S3,
        FINAL // Sequence found
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Output
    reg start_shifting;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == FINAL) ? 1 : 0;
        end
    end

    // State transition logic
    always_comb begin
        next_state = state;
        case (state)
            S0: if (data) next_state = S1;
            S1: if (data) next_state = S2; else next_state = S0;
            S2: if (data) next_state = S3; else next_state = S0;
            S3: if (data) next_state = FINAL; else next_state = S0;
            FINAL: next_state = FINAL;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0, // Initial state
        S1,
        S2,
        S3,
        FINAL // Sequence found
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Output
    reg start_shifting;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == FINAL) ? 1 : 0;
        end
    end

    // State transition logic
    always_comb begin
        next_state = state;
        case (state)
            S0: if (data) next_state = S1;
            S1: if (data) next_state = S2; else next_state = S0;
            S2: if (data) next_state = S3; else next_state = S0;
            S3: if (data) next_state = FINAL; else next_state = S0;
            FINAL: next_state = FINAL;
        endcase
    end

endmodule
"
"
    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;
    
    // Define state register and next state
    state_t state, next_state;
    
    // Output for start shifting
    reg start_shifting;
    
    // State transition and output logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == S3) ? 1 : 0;
        end
    end
    
    // Next state logic
    always @* begin
        next_state = state;
        case (state)
            S0: if (data) next_state = S1;
            S1: if (data) next_state = S2; else next_state = S0;
            S2: if (data) next_state = S3; else next_state = S0;
            S3: next_state = S3;
        endcase
    end
    
endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;
    
    // Define state register and next state
    state_t state, next_state;
    
    // Output for start shifting
    reg start_shifting;
    
    // State transition and output logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == S3) ? 1 : 0;
        end
    end
    
    // Next state logic
    always @* begin
        next_state = state;
        case (state)
            S0: if (data) next_state = S1;
            S1: if (data) next_state = S2; else next_state = S0;
            S2: if (data) next_state = S3; else next_state = S0;
            S3: next_state = S3;
        endcase
    end
    
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;
    
    // Define state register and next state
    state_t state, next_state;
    
    // Output for start shifting
    reg start_shifting;
    
    // State transition and output logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == S3) ? 1 : 0;
        end
    end
    
    // Next state logic
    always @* begin
        next_state = state;
        case (state)
            S0: if (data) next_state = S1;
            S1: if (data) next_state = S2; else next_state = S0;
            S2: if (data) next_state = S3; else next_state = S0;
            S3: next_state = S3;
        endcase
    end
    
endmodule
"
"
    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define output register
    reg start_shifting;

    // State register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= start_shifting;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        start_shifting = start_shifting;
        
        case (state)
            S0: begin
                if (data == 1)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if (data == 1)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if (data == 0)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                next_state = S3;
                start_shifting = 1;
            end
        endcase
    end

endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define output register
    reg start_shifting;

    // State register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= start_shifting;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        start_shifting = start_shifting;
        
        case (state)
            S0: begin
                if (data == 1)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if (data == 1)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if (data == 0)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                next_state = S3;
                start_shifting = 1;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define output register
    reg start_shifting;

    // State register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= start_shifting;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        start_shifting = start_shifting;
        
        case (state)
            S0: begin
                if (data == 1)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if (data == 1)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if (data == 0)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                next_state = S3;
                start_shifting = 1;
            end
        endcase
    end

endmodule
"
"
    // Define state enum
    typedef enum logic [2:0] {
        IDLE,
        STATE_1,
        STATE_2,
        STATE_3,
        FINAL_STATE
    } state_type;

    // Define state register and next state logic
    state_type state_reg, state_next;

    // Output signal
    reg start_shifting;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state_reg <= IDLE;
            start_shifting <= 0;
        end else begin
            state_reg <= state_next;
        end
    end

    always @* begin
        state_next = state_reg;
        start_shifting = 0;

        case (state_reg)
            IDLE: begin
                if (data) begin
                    state_next = STATE_1;
                end
            end

            STATE_1: begin
                if (data) begin
                    state_next = STATE_2;
                end else begin
                    state_next = IDLE;
                end
            end

            STATE_2: begin
                if (data) begin
                    state_next = STATE_3;
                end else begin
                    state_next = IDLE;
                end
            end

            STATE_3: begin
                if (data) begin
                    state_next = FINAL_STATE;
                    start_shifting = 1;
                end else begin
                    state_next = IDLE;
                end
            end

            FINAL_STATE: begin
                start_shifting = 1;
            end
        endcase
    end

endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define state enum
    typedef enum logic [2:0] {
        IDLE,
        STATE_1,
        STATE_2,
        STATE_3,
        FINAL_STATE
    } state_type;

    // Define state register and next state logic
    state_type state_reg, state_next;

    // Output signal
    reg start_shifting;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state_reg <= IDLE;
            start_shifting <= 0;
        end else begin
            state_reg <= state_next;
        end
    end

    always @* begin
        state_next = state_reg;
        start_shifting = 0;

        case (state_reg)
            IDLE: begin
                if (data) begin
                    state_next = STATE_1;
                end
            end

            STATE_1: begin
                if (data) begin
                    state_next = STATE_2;
                end else begin
                    state_next = IDLE;
                end
            end

            STATE_2: begin
                if (data) begin
                    state_next = STATE_3;
                end else begin
                    state_next = IDLE;
                end
            end

            STATE_3: begin
                if (data) begin
                    state_next = FINAL_STATE;
                    start_shifting = 1;
                end else begin
                    state_next = IDLE;
                end
            end

            FINAL_STATE: begin
                start_shifting = 1;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define state enum
    typedef enum logic [2:0] {
        IDLE,
        STATE_1,
        STATE_2,
        STATE_3,
        FINAL_STATE
    } state_type;

    // Define state register and next state logic
    state_type state_reg, state_next;

    // Output signal
    reg start_shifting;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state_reg <= IDLE;
            start_shifting <= 0;
        end else begin
            state_reg <= state_next;
        end
    end

    always @* begin
        state_next = state_reg;
        start_shifting = 0;

        case (state_reg)
            IDLE: begin
                if (data) begin
                    state_next = STATE_1;
                end
            end

            STATE_1: begin
                if (data) begin
                    state_next = STATE_2;
                end else begin
                    state_next = IDLE;
                end
            end

            STATE_2: begin
                if (data) begin
                    state_next = STATE_3;
                end else begin
                    state_next = IDLE;
                end
            end

            STATE_3: begin
                if (data) begin
                    state_next = FINAL_STATE;
                    start_shifting = 1;
                end else begin
                    state_next = IDLE;
                end
            end

            FINAL_STATE: begin
                start_shifting = 1;
            end
        endcase
    end

endmodule
"
"
    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define outputs
    logic start_shifting;

    // State register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic and output logic
    always_comb begin
        start_shifting = 0;
        case(state)
            S0: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S0;
                end
            end
            S1: begin
                if (data) begin
                    next_state = S2;
                end else begin
                    next_state = S0;
                end
            end
            S2: begin
                if (data) begin
                    next_state = S3;
                end else begin
                    next_state = S0;
                end
            end
            S3: begin
                start_shifting = 1;
                next_state = S3;
            end
        endcase
    end

endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define outputs
    logic start_shifting;

    // State register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic and output logic
    always_comb begin
        start_shifting = 0;
        case(state)
            S0: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S0;
                end
            end
            S1: begin
                if (data) begin
                    next_state = S2;
                end else begin
                    next_state = S0;
                end
            end
            S2: begin
                if (data) begin
                    next_state = S3;
                end else begin
                    next_state = S0;
                end
            end
            S3: begin
                start_shifting = 1;
                next_state = S3;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define outputs
    logic start_shifting;

    // State register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic and output logic
    always_comb begin
        start_shifting = 0;
        case(state)
            S0: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S0;
                end
            end
            S1: begin
                if (data) begin
                    next_state = S2;
                end else begin
                    next_state = S0;
                end
            end
            S2: begin
                if (data) begin
                    next_state = S3;
                end else begin
                    next_state = S0;
                end
            end
            S3: begin
                start_shifting = 1;
                next_state = S3;
            end
        endcase
    end

endmodule
"
"
    // Define states
    typedef enum logic [2:0] {
        IDLE,
        STATE1,
        STATE2,
        STATE3,
        FINAL_STATE
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define start_shifting output
    logic start_shifting;

    // State register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always_comb begin
        start_shifting = 0;

        case (state)
            IDLE: begin
                if (data == 1)
                    next_state = STATE1;
                else
                    next_state = IDLE;
            end
            STATE1: begin
                if (data == 1)
                    next_state = STATE2;
                else
                    next_state = IDLE;
            end
            STATE2: begin
                if (data == 0)
                    next_state = STATE3;
                else
                    next_state = IDLE;
            end
            STATE3: begin
                if (data == 1)
                    next_state = FINAL_STATE;
                else
                    next_state = IDLE;
            end
            FINAL_STATE: begin
                next_state = FINAL_STATE;
                start_shifting = 1;
            end
        endcase
    end

endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        IDLE,
        STATE1,
        STATE2,
        STATE3,
        FINAL_STATE
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define start_shifting output
    logic start_shifting;

    // State register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always_comb begin
        start_shifting = 0;

        case (state)
            IDLE: begin
                if (data == 1)
                    next_state = STATE1;
                else
                    next_state = IDLE;
            end
            STATE1: begin
                if (data == 1)
                    next_state = STATE2;
                else
                    next_state = IDLE;
            end
            STATE2: begin
                if (data == 0)
                    next_state = STATE3;
                else
                    next_state = IDLE;
            end
            STATE3: begin
                if (data == 1)
                    next_state = FINAL_STATE;
                else
                    next_state = IDLE;
            end
            FINAL_STATE: begin
                next_state = FINAL_STATE;
                start_shifting = 1;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        IDLE,
        STATE1,
        STATE2,
        STATE3,
        FINAL_STATE
    } state_t;

    // Define state register and next state logic
    state_t state, next_state;

    // Define start_shifting output
    logic start_shifting;

    // State register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always_comb begin
        start_shifting = 0;

        case (state)
            IDLE: begin
                if (data == 1)
                    next_state = STATE1;
                else
                    next_state = IDLE;
            end
            STATE1: begin
                if (data == 1)
                    next_state = STATE2;
                else
                    next_state = IDLE;
            end
            STATE2: begin
                if (data == 0)
                    next_state = STATE3;
                else
                    next_state = IDLE;
            end
            STATE3: begin
                if (data == 1)
                    next_state = FINAL_STATE;
                else
                    next_state = IDLE;
            end
            FINAL_STATE: begin
                next_state = FINAL_STATE;
                start_shifting = 1;
            end
        endcase
    end

endmodule
"
"
    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define output
    reg start_shifting;
    
    // State transition and output logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == S3) ? 1 : 0;
        end
    end
    
    // Next state logic
    always @* begin
        next_state = state;
        case (state)
            S0: begin
                if (data) begin
                    next_state = S1;
                end
            end
            S1: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S2;
                end
            end
            S2: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S3;
                end
            end
            S3: begin
                next_state = S3;
            end
        endcase
    end
    
endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define output
    reg start_shifting;
    
    // State transition and output logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == S3) ? 1 : 0;
        end
    end
    
    // Next state logic
    always @* begin
        next_state = state;
        case (state)
            S0: begin
                if (data) begin
                    next_state = S1;
                end
            end
            S1: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S2;
                end
            end
            S2: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S3;
                end
            end
            S3: begin
                next_state = S3;
            end
        endcase
    end
    
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;
    
    // Define state register and next state logic
    state_t state, next_state;
    
    // Define output
    reg start_shifting;
    
    // State transition and output logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == S3) ? 1 : 0;
        end
    end
    
    // Next state logic
    always @* begin
        next_state = state;
        case (state)
            S0: begin
                if (data) begin
                    next_state = S1;
                end
            end
            S1: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S2;
                end
            end
            S2: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S3;
                end
            end
            S3: begin
                next_state = S3;
            end
        endcase
    end
    
endmodule
"
"
    // Define states
    typedef enum logic [2:0] {
        IDLE,
        STATE_1,
        STATE_2,
        STATE_3,
        FINAL_STATE
    } fsm_state;

    // State register
    fsm_state current_state, next_state;

    // Output register
    reg start_shifting;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            start_shifting <= 0;
        end else begin
            current_state <= next_state;
            start_shifting <= (current_state == FINAL_STATE) ? 1 : 0;
        end
    end

    always_comb begin
        next_state = current_state;
        case(current_state)
            IDLE: begin
                if (data == 1'b1)
                    next_state = STATE_1;
            end
            STATE_1: begin
                if (data == 1'b1)
                    next_state = STATE_2;
                else
                    next_state = IDLE;
            end
            STATE_2: begin
                if (data == 1'b0)
                    next_state = IDLE;
                else
                    next_state = STATE_3;
            end
            STATE_3: begin
                if (data == 1'b1)
                    next_state = FINAL_STATE;
                else
                    next_state = IDLE;
            end
            FINAL_STATE: begin
                next_state = FINAL_STATE;
            end
        endcase
    end

endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        IDLE,
        STATE_1,
        STATE_2,
        STATE_3,
        FINAL_STATE
    } fsm_state;

    // State register
    fsm_state current_state, next_state;

    // Output register
    reg start_shifting;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            start_shifting <= 0;
        end else begin
            current_state <= next_state;
            start_shifting <= (current_state == FINAL_STATE) ? 1 : 0;
        end
    end

    always_comb begin
        next_state = current_state;
        case(current_state)
            IDLE: begin
                if (data == 1'b1)
                    next_state = STATE_1;
            end
            STATE_1: begin
                if (data == 1'b1)
                    next_state = STATE_2;
                else
                    next_state = IDLE;
            end
            STATE_2: begin
                if (data == 1'b0)
                    next_state = IDLE;
                else
                    next_state = STATE_3;
            end
            STATE_3: begin
                if (data == 1'b1)
                    next_state = FINAL_STATE;
                else
                    next_state = IDLE;
            end
            FINAL_STATE: begin
                next_state = FINAL_STATE;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // Define states
    typedef enum logic [2:0] {
        IDLE,
        STATE_1,
        STATE_2,
        STATE_3,
        FINAL_STATE
    } fsm_state;

    // State register
    fsm_state current_state, next_state;

    // Output register
    reg start_shifting;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            start_shifting <= 0;
        end else begin
            current_state <= next_state;
            start_shifting <= (current_state == FINAL_STATE) ? 1 : 0;
        end
    end

    always_comb begin
        next_state = current_state;
        case(current_state)
            IDLE: begin
                if (data == 1'b1)
                    next_state = STATE_1;
            end
            STATE_1: begin
                if (data == 1'b1)
                    next_state = STATE_2;
                else
                    next_state = IDLE;
            end
            STATE_2: begin
                if (data == 1'b0)
                    next_state = IDLE;
                else
                    next_state = STATE_3;
            end
            STATE_3: begin
                if (data == 1'b1)
                    next_state = FINAL_STATE;
                else
                    next_state = IDLE;
            end
            FINAL_STATE: begin
                next_state = FINAL_STATE;
            end
        endcase
    end

endmodule
"
"
    // State definitions
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;

    // State register
    state_t state, next_state;

    // Output register
    reg start_shifting;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == S3) ? 1 : 0;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            S0: begin
                if (data) begin
                    next_state = S1;
                end
            end
            S1: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S2;
                end
            end
            S2: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S3;
                end
            end
            S3: begin
                next_state = S3;
            end
        endcase
    end

endmodule
",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // State definitions
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;

    // State register
    state_t state, next_state;

    // Output register
    reg start_shifting;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == S3) ? 1 : 0;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            S0: begin
                if (data) begin
                    next_state = S1;
                end
            end
            S1: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S2;
                end
            end
            S2: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S3;
                end
            end
            S3: begin
                next_state = S3;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    // State definitions
    typedef enum logic [2:0] {
        S0,
        S1,
        S2,
        S3
    } state_t;

    // State register
    state_t state, next_state;

    // Output register
    reg start_shifting;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= S0;
            start_shifting <= 0;
        end else begin
            state <= next_state;
            start_shifting <= (state == S3) ? 1 : 0;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            S0: begin
                if (data) begin
                    next_state = S1;
                end
            end
            S1: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S2;
                end
            end
            S2: begin
                if (data) begin
                    next_state = S1;
                end else begin
                    next_state = S3;
                end
            end
            S3: begin
                next_state = S3;
            end
        endcase
    end

endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1; // Enable shift register
        end else begin
            case (state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100; // Move to next state
                end
                default: begin // State 4
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1; // Enable shift register
        end else begin
            case (state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100; // Move to next state
                end
                default: begin // State 4
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1; // Enable shift register
        end else begin
            case (state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100; // Move to next state
                end
                default: begin // State 4
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            shift_ena <= 1;
        end else begin
            case (state)
                3'b000: begin
                    shift_ena <= 1;
                    state <= 3'b001;
                end
                3'b001: begin
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin
                    shift_ena <= 1;
                    state <= 3'b011;
                end
                3'b011: begin
                    shift_ena <= 1;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            shift_ena <= 1;
        end else begin
            case (state)
                3'b000: begin
                    shift_ena <= 1;
                    state <= 3'b001;
                end
                3'b001: begin
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin
                    shift_ena <= 1;
                    state <= 3'b011;
                end
                3'b011: begin
                    shift_ena <= 1;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            shift_ena <= 1;
        end else begin
            case (state)
                3'b000: begin
                    shift_ena <= 1;
                    state <= 3'b001;
                end
                3'b001: begin
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin
                    shift_ena <= 1;
                    state <= 3'b011;
                end
                3'b011: begin
                    shift_ena <= 1;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000; // initial state
            shift_ena <= 1; // enable shift register
        end else begin
            case(state)
                3'b000: begin // State 0
                    shift_ena <= 1;
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1;
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1;
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1;
                    state <= 3'b000; // Reset state to initial state
                end
                default: begin
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to initial state
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000; // initial state
            shift_ena <= 1; // enable shift register
        end else begin
            case(state)
                3'b000: begin // State 0
                    shift_ena <= 1;
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1;
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1;
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1;
                    state <= 3'b000; // Reset state to initial state
                end
                default: begin
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to initial state
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000; // initial state
            shift_ena <= 1; // enable shift register
        end else begin
            case(state)
                3'b000: begin // State 0
                    shift_ena <= 1;
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1;
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1;
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1;
                    state <= 3'b000; // Reset state to initial state
                end
                default: begin
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to initial state
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            case (state)
                3'b000: begin // Initial state
                    if (/* condition for detecting proper bit pattern */) begin
                        shift_ena <= 1;
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Enable shift register for 4 cycles
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin
                    shift_ena <= 1;
                    state <= 3'b011;
                end
                3'b011: begin
                    shift_ena <= 1;
                    state <= 3'b100;
                end
                3'b100: begin
                    shift_ena <= 1;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            case (state)
                3'b000: begin // Initial state
                    if (/* condition for detecting proper bit pattern */) begin
                        shift_ena <= 1;
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Enable shift register for 4 cycles
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin
                    shift_ena <= 1;
                    state <= 3'b011;
                end
                3'b011: begin
                    shift_ena <= 1;
                    state <= 3'b100;
                end
                3'b100: begin
                    shift_ena <= 1;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            case (state)
                3'b000: begin // Initial state
                    if (/* condition for detecting proper bit pattern */) begin
                        shift_ena <= 1;
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Enable shift register for 4 cycles
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin
                    shift_ena <= 1;
                    state <= 3'b011;
                end
                3'b011: begin
                    shift_ena <= 1;
                    state <= 3'b100;
                end
                3'b100: begin
                    shift_ena <= 1;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1;  // Enable shift register
        end
        else begin
            case (state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100; // Move to next state
                end
                default: begin // State 4
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1;  // Enable shift register
        end
        else begin
            case (state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100; // Move to next state
                end
                default: begin // State 4
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1;  // Enable shift register
        end
        else begin
            case (state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100; // Move to next state
                end
                default: begin // State 4
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1; // Enable shift register
        end else begin
            case(state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b000; // Reset state to initial state
                end
                default: begin
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to initial state
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1; // Enable shift register
        end else begin
            case(state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b000; // Reset state to initial state
                end
                default: begin
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to initial state
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1; // Enable shift register
        end else begin
            case(state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b000; // Reset state to initial state
                end
                default: begin
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to initial state
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initialize state to 0
            shift_ena <= 1; // Enable shift register
        end
        else begin
            case (state)
                3'b000: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001;
                end
                3'b001: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010;
                end
                3'b010: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011;
                end
                3'b011: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100;
                end
                default: begin
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to 0
                end
            endcase
        end
    end
endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initialize state to 0
            shift_ena <= 1; // Enable shift register
        end
        else begin
            case (state)
                3'b000: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001;
                end
                3'b001: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010;
                end
                3'b010: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011;
                end
                3'b011: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100;
                end
                default: begin
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to 0
                end
            endcase
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initialize state to 0
            shift_ena <= 1; // Enable shift register
        end
        else begin
            case (state)
                3'b000: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001;
                end
                3'b001: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010;
                end
                3'b010: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011;
                end
                3'b011: begin
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100;
                end
                default: begin
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to 0
                end
            endcase
        end
    end
endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1; // Enable shift register
        end else begin
            case (state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100; // Move to next state
                end
                default: begin // State 4
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to initial state
                end
            endcase
        end
    end
endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1; // Enable shift register
        end else begin
            case (state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100; // Move to next state
                end
                default: begin // State 4
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to initial state
                end
            endcase
        end
    end
endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
            shift_ena <= 1; // Enable shift register
        end else begin
            case (state)
                3'b000: begin // State 0
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b001; // Move to next state
                end
                3'b001: begin // State 1
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b010; // Move to next state
                end
                3'b010: begin // State 2
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b011; // Move to next state
                end
                3'b011: begin // State 3
                    shift_ena <= 1; // Enable shift register
                    state <= 3'b100; // Move to next state
                end
                default: begin // State 4
                    shift_ena <= 0; // Disable shift register
                    state <= 3'b000; // Reset state to initial state
                end
            endcase
        end
    end
endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            shift_ena <= 1;
        end else begin
            case (state)
                3'b000: begin
                    shift_ena <= 1;
                    state <= 3'b001;
                end
                3'b001, 3'b010, 3'b011: begin
                    shift_ena <= 1;
                    state <= state + 1;
                end
                default: begin
                    shift_ena <= 0;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            shift_ena <= 1;
        end else begin
            case (state)
                3'b000: begin
                    shift_ena <= 1;
                    state <= 3'b001;
                end
                3'b001, 3'b010, 3'b011: begin
                    shift_ena <= 1;
                    state <= state + 1;
                end
                default: begin
                    shift_ena <= 0;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            shift_ena <= 1;
        end else begin
            case (state)
                3'b000: begin
                    shift_ena <= 1;
                    state <= 3'b001;
                end
                3'b001, 3'b010, 3'b011: begin
                    shift_ena <= 1;
                    state <= state + 1;
                end
                default: begin
                    shift_ena <= 0;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
        end else begin
            case (state)
                3'b000: begin // State 0: Assert shift_ena for 4 cycles
                    shift_ena <= 1;
                    state <= 3'b001;
                end
                3'b001: begin // State 1
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin // State 2
                    shift_ena <= 1;
                    state <= 3'b011;
                end
                3'b011: begin // State 3
                    shift_ena <= 1;
                    state <= 3'b100;
                end
                3'b100: begin // State 4: Reset shift_ena
                    shift_ena <= 0;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
",-1.0,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
        end else begin
            case (state)
                3'b000: begin // State 0: Assert shift_ena for 4 cycles
                    shift_ena <= 1;
                    state <= 3'b001;
                end
                3'b001: begin // State 1
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin // State 2
                    shift_ena <= 1;
                    state <= 3'b011;
                end
                3'b011: begin // State 3
                    shift_ena <= 1;
                    state <= 3'b100;
                end
                3'b100: begin // State 4: Reset shift_ena
                    shift_ena <= 0;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000; // Initial state
        end else begin
            case (state)
                3'b000: begin // State 0: Assert shift_ena for 4 cycles
                    shift_ena <= 1;
                    state <= 3'b001;
                end
                3'b001: begin // State 1
                    shift_ena <= 1;
                    state <= 3'b010;
                end
                3'b010: begin // State 2
                    shift_ena <= 1;
                    state <= 3'b011;
                end
                3'b011: begin // State 3
                    shift_ena <= 1;
                    state <= 3'b100;
                end
                3'b100: begin // State 4: Reset shift_ena
                    shift_ena <= 0;
                    state <= 3'b000;
                end
            endcase
        end
    end

endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena && !count_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        else if (!shift_ena && count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena && !count_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        else if (!shift_ena && count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena && !count_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        else if (!shift_ena && count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            // Shift data in
            shift_reg <= {shift_reg[2:0], data};
        end else if (count_ena) begin
            // Decrement current value
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            // Shift data in
            shift_reg <= {shift_reg[2:0], data};
        end else if (count_ena) begin
            // Decrement current value
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            // Shift data in
            shift_reg <= {shift_reg[2:0], data};
        end else if (count_ena) begin
            // Decrement current value
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {shift_reg[2:0], data};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;

endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {shift_reg[2:0], data};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;

endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {shift_reg[2:0], data};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;

endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena & ~count_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end else if (count_ena & ~shift_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena & ~count_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end else if (count_ena & ~shift_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena & ~count_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end else if (count_ena & ~shift_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;

endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;

endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;

endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;

endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;

endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end
        if (count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;

endmodule
"
"    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena && !count_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end else if (!shift_ena && count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena && !count_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end else if (!shift_ena && count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    reg [3:0] shift_reg;

    always @(posedge clk) begin
        if (shift_ena && !count_ena) begin
            shift_reg <= {data, shift_reg[3:1]};
        end else if (!shift_ena && count_ena) begin
            shift_reg <= shift_reg - 1;
        end
    end

    assign q = shift_reg;
endmodule
"
"    wire s1, c1, c2;
    
    // First adder stage
    xor gate1 (s1, a, b);
    and gate2 (c1, a, b);
    
    // Second adder stage
    xor gate3 (sum, s1, cin);
    and gate4 (c2, s1, cin);
    
    // OR gate for carry-out
    or gate5 (cout, c1, c2);
    
endmodule
",1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    wire s1, c1, c2;
    
    // First adder stage
    xor gate1 (s1, a, b);
    and gate2 (c1, a, b);
    
    // Second adder stage
    xor gate3 (sum, s1, cin);
    and gate4 (c2, s1, cin);
    
    // OR gate for carry-out
    or gate5 (cout, c1, c2);
    
endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    wire s1, c1, c2;
    
    // First adder stage
    xor gate1 (s1, a, b);
    and gate2 (c1, a, b);
    
    // Second adder stage
    xor gate3 (sum, s1, cin);
    and gate4 (c2, s1, cin);
    
    // OR gate for carry-out
    or gate5 (cout, c1, c2);
    
endmodule
"
"    assign {cout, sum} = a + b + cin;
endmodule
",1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    assign {cout, sum} = a + b + cin;
endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    assign {cout, sum} = a + b + cin;
endmodule
"
"    // XOR gates to calculate sum
    wire s1, s2;
    xor gate1 (s1, a, b);
    xor gate2 (sum, s1, cin);
    
    // AND gates to calculate carry-out
    wire c1, c2, c3;
    and gate3 (c1, a, b);
    and gate4 (c2, b, cin);
    and gate5 (c3, a, cin);
    
    or gate6 (cout, c1, c2, c3);
endmodule
",1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    // XOR gates to calculate sum
    wire s1, s2;
    xor gate1 (s1, a, b);
    xor gate2 (sum, s1, cin);
    
    // AND gates to calculate carry-out
    wire c1, c2, c3;
    and gate3 (c1, a, b);
    and gate4 (c2, b, cin);
    and gate5 (c3, a, cin);
    
    or gate6 (cout, c1, c2, c3);
endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    // XOR gates to calculate sum
    wire s1, s2;
    xor gate1 (s1, a, b);
    xor gate2 (sum, s1, cin);
    
    // AND gates to calculate carry-out
    wire c1, c2, c3;
    and gate3 (c1, a, b);
    and gate4 (c2, b, cin);
    and gate5 (c3, a, cin);
    
    or gate6 (cout, c1, c2, c3);
endmodule
"
"    assign {cout, sum} = a + b + cin;
endmodule
",1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    assign {cout, sum} = a + b + cin;
endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    assign {cout, sum} = a + b + cin;
endmodule
"
"    assign {cout, sum} = a + b + cin;
endmodule
",1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    assign {cout, sum} = a + b + cin;
endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    assign {cout, sum} = a + b + cin;
endmodule
"
"    // Define the outputs
    output sum;
    output cout;

    // Internal signals
    wire s1, c1, c2;

    // First stage: half adder for a and b
    half_adder HA1( .a(a), .b(b), .sum(s1), .cout(c1) );

    // Second stage: half adder for sum of a and b and carry-in
    half_adder HA2( .a(s1), .b(cin), .sum(sum), .cout(c2) );

    // OR gate for final carry-out
    assign cout = c1 || c2;

endmodule
",-1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    // Define the outputs
    output sum;
    output cout;

    // Internal signals
    wire s1, c1, c2;

    // First stage: half adder for a and b
    half_adder HA1( .a(a), .b(b), .sum(s1), .cout(c1) );

    // Second stage: half adder for sum of a and b and carry-in
    half_adder HA2( .a(s1), .b(cin), .sum(sum), .cout(c2) );

    // OR gate for final carry-out
    assign cout = c1 || c2;

endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    // Define the outputs
    output sum;
    output cout;

    // Internal signals
    wire s1, c1, c2;

    // First stage: half adder for a and b
    half_adder HA1( .a(a), .b(b), .sum(s1), .cout(c1) );

    // Second stage: half adder for sum of a and b and carry-in
    half_adder HA2( .a(s1), .b(cin), .sum(sum), .cout(c2) );

    // OR gate for final carry-out
    assign cout = c1 || c2;

endmodule
"
"    // Define internal wires
    wire s1, c1, c2;
    
    // First half adder
    half_adder ha1(a, b, s1, c1);
    
    // Second half adder
    half_adder ha2(s1, cin, sum, c2);
    
    // Generate carry-out
    assign cout = c1 | c2; // OR gate to combine carry-outs from both half adders
endmodule
",-1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    // Define internal wires
    wire s1, c1, c2;
    
    // First half adder
    half_adder ha1(a, b, s1, c1);
    
    // Second half adder
    half_adder ha2(s1, cin, sum, c2);
    
    // Generate carry-out
    assign cout = c1 | c2; // OR gate to combine carry-outs from both half adders
endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    // Define internal wires
    wire s1, c1, c2;
    
    // First half adder
    half_adder ha1(a, b, s1, c1);
    
    // Second half adder
    half_adder ha2(s1, cin, sum, c2);
    
    // Generate carry-out
    assign cout = c1 | c2; // OR gate to combine carry-outs from both half adders
endmodule
"
"    // Define internal signals
    wire s1, c1, c2;

    // First stage
    xor gate1( s1, a, b );
    and gate2( c1, a, b );

    // Second stage
    xor gate3( sum, s1, cin );
    and gate4( c2, s1, cin );

    // Final stage
    or gate5( cout, c1, c2 );

endmodule
",1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    // Define internal signals
    wire s1, c1, c2;

    // First stage
    xor gate1( s1, a, b );
    and gate2( c1, a, b );

    // Second stage
    xor gate3( sum, s1, cin );
    and gate4( c2, s1, cin );

    // Final stage
    or gate5( cout, c1, c2 );

endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    // Define internal signals
    wire s1, c1, c2;

    // First stage
    xor gate1( s1, a, b );
    and gate2( c1, a, b );

    // Second stage
    xor gate3( sum, s1, cin );
    and gate4( c2, s1, cin );

    // Final stage
    or gate5( cout, c1, c2 );

endmodule
"
"    assign {cout, sum} = a + b + cin;
endmodule
",1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    assign {cout, sum} = a + b + cin;
endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    assign {cout, sum} = a + b + cin;
endmodule
"
"    // Define the internal signals
    wire s1, c1, c2;

    // First half adder
    xor gate1 (s1, a, b);
    and gate2 (c1, a, b);

    // Second half adder
    xor gate3 (sum, s1, cin);
    and gate4 (c2, s1, cin);

    // Final OR gate for carry-out
    or gate5 (cout, c1, c2);
endmodule
",1.0,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );

    // Define the internal signals
    wire s1, c1, c2;

    // First half adder
    xor gate1 (s1, a, b);
    and gate2 (c1, a, b);

    // Second half adder
    xor gate3 (sum, s1, cin);
    and gate4 (c2, s1, cin);

    // Final OR gate for carry-out
    or gate5 (cout, c1, c2);
endmodule
","module top_module( 
    input a, b, cin,
    output cout, sum );

    // Define the internal signals
    wire s1, c1, c2;

    // First half adder
    xor gate1 (s1, a, b);
    and gate2 (c1, a, b);

    // Second half adder
    xor gate3 (sum, s1, cin);
    and gate4 (c2, s1, cin);

    // Final OR gate for carry-out
    or gate5 (cout, c1, c2);
endmodule
"
"// Define states
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define signals
state_t state, next_state;
reg done;

// State flip-flops
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        done <= 0;
    end else begin
        state <= next_state;
        done <= 0;
    end
end

// State transition logic
always_comb begin
    case(state)
        IDLE: begin
            if (in[3] == 1) begin
                next_state = BYTE1;
            end else begin
                next_state = IDLE;
            end
        end
        BYTE1: begin
            next_state = BYTE2;
        end
        BYTE2: begin
            next_state = BYTE3;
        end
        BYTE3: begin
            next_state = IDLE;
            done = 1;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

endmodule
",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);
// Define states
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define signals
state_t state, next_state;
reg done;

// State flip-flops
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        done <= 0;
    end else begin
        state <= next_state;
        done <= 0;
    end
end

// State transition logic
always_comb begin
    case(state)
        IDLE: begin
            if (in[3] == 1) begin
                next_state = BYTE1;
            end else begin
                next_state = IDLE;
            end
        end
        BYTE1: begin
            next_state = BYTE2;
        end
        BYTE2: begin
            next_state = BYTE3;
        end
        BYTE3: begin
            next_state = IDLE;
            done = 1;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);
// Define states
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define signals
state_t state, next_state;
reg done;

// State flip-flops
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        done <= 0;
    end else begin
        state <= next_state;
        done <= 0;
    end
end

// State transition logic
always_comb begin
    case(state)
        IDLE: begin
            if (in[3] == 1) begin
                next_state = BYTE1;
            end else begin
                next_state = IDLE;
            end
        end
        BYTE1: begin
            next_state = BYTE2;
        end
        BYTE2: begin
            next_state = BYTE3;
        end
        BYTE3: begin
            next_state = IDLE;
            done = 1;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

endmodule
"
"
    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case(state)
                3'b000: begin // State 0: Waiting for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // State 1: Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // State 2: Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // State 3: Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case(state)
                3'b000: begin // State 0: Waiting for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // State 1: Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // State 2: Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // State 3: Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case(state)
                3'b000: begin // State 0: Waiting for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // State 1: Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // State 2: Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // State 3: Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case (state)
                3'b000: begin // Waiting for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case (state)
                3'b000: begin // Waiting for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case (state)
                3'b000: begin // Waiting for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
"
"
    reg [3:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 4'b0000;
            done <= 0;
        end else begin
            case(state)
                4'b0000: begin // Idle state
                    if (in[3] == 1) begin
                        state <= 4'b0001;
                    end
                end
                4'b0001: begin // First byte received
                    state <= 4'b0010;
                end
                4'b0010: begin // Second byte received
                    state <= 4'b0011;
                end
                4'b0011: begin // Third byte received, signal done
                    state <= 4'b0000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [3:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 4'b0000;
            done <= 0;
        end else begin
            case(state)
                4'b0000: begin // Idle state
                    if (in[3] == 1) begin
                        state <= 4'b0001;
                    end
                end
                4'b0001: begin // First byte received
                    state <= 4'b0010;
                end
                4'b0010: begin // Second byte received
                    state <= 4'b0011;
                end
                4'b0011: begin // Third byte received, signal done
                    state <= 4'b0000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [3:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 4'b0000;
            done <= 0;
        end else begin
            case(state)
                4'b0000: begin // Idle state
                    if (in[3] == 1) begin
                        state <= 4'b0001;
                    end
                end
                4'b0001: begin // First byte received
                    state <= 4'b0010;
                end
                4'b0010: begin // Second byte received
                    state <= 4'b0011;
                end
                4'b0011: begin // Third byte received, signal done
                    state <= 4'b0000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case(state)
                3'b000: begin // Initial state, waiting for start of message
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

    assign done = done;

endmodule
",-1.0,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case(state)
                3'b000: begin // Initial state, waiting for start of message
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

    assign done = done;

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case(state)
                3'b000: begin // Initial state, waiting for start of message
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

    assign done = done;

endmodule
"
"// Define states
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define outputs
reg done;

// Define state flip-flops
reg [1:0] state, next_state;

// State transition logic
always_comb begin
    next_state = state;
    case(state)
        IDLE: begin
            if (in[3] == 1)
                next_state = BYTE1;
        end
        BYTE1: next_state = BYTE2;
        BYTE2: next_state = BYTE3;
        BYTE3: next_state = IDLE;
    endcase
end

// State flip-flops
always_ff @(posedge clk or posedge reset) begin
    if (reset)
        state <= IDLE;
    else
        state <= next_state;
end

// Output logic
always_comb begin
    done = 0;
    if (state == BYTE3)
        done = 1;
end

endmodule
",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);
// Define states
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define outputs
reg done;

// Define state flip-flops
reg [1:0] state, next_state;

// State transition logic
always_comb begin
    next_state = state;
    case(state)
        IDLE: begin
            if (in[3] == 1)
                next_state = BYTE1;
        end
        BYTE1: next_state = BYTE2;
        BYTE2: next_state = BYTE3;
        BYTE3: next_state = IDLE;
    endcase
end

// State flip-flops
always_ff @(posedge clk or posedge reset) begin
    if (reset)
        state <= IDLE;
    else
        state <= next_state;
end

// Output logic
always_comb begin
    done = 0;
    if (state == BYTE3)
        done = 1;
end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);
// Define states
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define outputs
reg done;

// Define state flip-flops
reg [1:0] state, next_state;

// State transition logic
always_comb begin
    next_state = state;
    case(state)
        IDLE: begin
            if (in[3] == 1)
                next_state = BYTE1;
        end
        BYTE1: next_state = BYTE2;
        BYTE2: next_state = BYTE3;
        BYTE3: next_state = IDLE;
    endcase
end

// State flip-flops
always_ff @(posedge clk or posedge reset) begin
    if (reset)
        state <= IDLE;
    else
        state <= next_state;
end

// Output logic
always_comb begin
    done = 0;
    if (state == BYTE3)
        done = 1;
end

endmodule
"
"
    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 0;
            done <= 0;
        end else begin
            case (state)
                0: begin // Waiting for first byte
                    if (in[3] == 1) begin
                        state <= 1;
                    end
                end
                1: begin // Waiting for second byte
                    state <= 2;
                end
                2: begin // Waiting for third byte
                    state <= 3;
                end
                3: begin // Message received
                    state <= 0;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 0;
            done <= 0;
        end else begin
            case (state)
                0: begin // Waiting for first byte
                    if (in[3] == 1) begin
                        state <= 1;
                    end
                end
                1: begin // Waiting for second byte
                    state <= 2;
                end
                2: begin // Waiting for third byte
                    state <= 3;
                end
                3: begin // Message received
                    state <= 0;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 0;
            done <= 0;
        end else begin
            case (state)
                0: begin // Waiting for first byte
                    if (in[3] == 1) begin
                        state <= 1;
                    end
                end
                1: begin // Waiting for second byte
                    state <= 2;
                end
                2: begin // Waiting for third byte
                    state <= 3;
                end
                3: begin // Message received
                    state <= 0;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
"
"
    reg [3:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 4'b0000;
            done <= 0;
        end else begin
            case (state)
                4'b0000: begin // Idle state
                    if (in[3] == 1'b1) begin
                        state <= 4'b0001;
                    end
                end
                4'b0001: begin // Byte 1 received
                    state <= 4'b0010;
                end
                4'b0010: begin // Byte 2 received
                    state <= 4'b0011;
                end
                4'b0011: begin // Byte 3 received
                    state <= 4'b0100;
                    done <= 1;
                end
                default: begin
                    state <= 4'b0000;
                end
            endcase
        end
    end

endmodule
",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [3:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 4'b0000;
            done <= 0;
        end else begin
            case (state)
                4'b0000: begin // Idle state
                    if (in[3] == 1'b1) begin
                        state <= 4'b0001;
                    end
                end
                4'b0001: begin // Byte 1 received
                    state <= 4'b0010;
                end
                4'b0010: begin // Byte 2 received
                    state <= 4'b0011;
                end
                4'b0011: begin // Byte 3 received
                    state <= 4'b0100;
                    done <= 1;
                end
                default: begin
                    state <= 4'b0000;
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [3:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 4'b0000;
            done <= 0;
        end else begin
            case (state)
                4'b0000: begin // Idle state
                    if (in[3] == 1'b1) begin
                        state <= 4'b0001;
                    end
                end
                4'b0001: begin // Byte 1 received
                    state <= 4'b0010;
                end
                4'b0010: begin // Byte 2 received
                    state <= 4'b0011;
                end
                4'b0011: begin // Byte 3 received
                    state <= 4'b0100;
                    done <= 1;
                end
                default: begin
                    state <= 4'b0000;
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case (state)
                3'b000: begin // Initial state, waiting for bit[3] = 1
                    if (in[3] == 1)
                        state <= 3'b001;
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, signal done
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case (state)
                3'b000: begin // Initial state, waiting for bit[3] = 1
                    if (in[3] == 1)
                        state <= 3'b001;
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, signal done
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case (state)
                3'b000: begin // Initial state, waiting for bit[3] = 1
                    if (in[3] == 1)
                        state <= 3'b001;
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, signal done
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
"
"
    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case(state)
                3'b000: begin // Initial state, waiting for bit[3]=1
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case(state)
                3'b000: begin // Initial state, waiting for bit[3]=1
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);

    reg [2:0] state;
    reg done;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 3'b000;
            done <= 0;
        end else begin
            case(state)
                3'b000: begin // Initial state, waiting for bit[3]=1
                    if (in[3] == 1) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Received first byte, waiting for second byte
                    state <= 3'b010;
                end
                3'b010: begin // Received second byte, waiting for third byte
                    state <= 3'b011;
                end
                3'b011: begin // Received third byte, message complete
                    state <= 3'b000;
                    done <= 1;
                end
            endcase
        end
    end

endmodule
"
"// Define states
parameter IDLE = 2'b00;
parameter BYTE1 = 2'b01;
parameter BYTE2 = 2'b10;
parameter BYTE3 = 2'b11;

// Define signals
reg [1:0] state, next_state;
reg [7:0] byte1, byte2, byte3;
reg [23:0] out_bytes_reg;
reg done_reg;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        byte1 <= 8'b0;
        byte2 <= 8'b0;
        byte3 <= 8'b0;
        out_bytes_reg <= 24'b0;
        done_reg <= 1'b0;
    end else begin
        state <= next_state;
        out_bytes_reg <= {byte1, byte2, byte3};
        done_reg <= (state == BYTE3);
    end
end

always @* begin
    case (state)
        IDLE: begin
            if (in[3] == 1'b1) begin
                next_state = BYTE1;
                byte1 = in;
            end else begin
                next_state = IDLE;
            end
        end
        BYTE1: begin
            next_state = BYTE2;
            byte2 = in;
        end
        BYTE2: begin
            next_state = BYTE3;
            byte3 = in;
        end
        BYTE3: begin
            next_state = IDLE;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

assign out_bytes = out_bytes_reg;
assign done = done_reg;

endmodule
",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states
parameter IDLE = 2'b00;
parameter BYTE1 = 2'b01;
parameter BYTE2 = 2'b10;
parameter BYTE3 = 2'b11;

// Define signals
reg [1:0] state, next_state;
reg [7:0] byte1, byte2, byte3;
reg [23:0] out_bytes_reg;
reg done_reg;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        byte1 <= 8'b0;
        byte2 <= 8'b0;
        byte3 <= 8'b0;
        out_bytes_reg <= 24'b0;
        done_reg <= 1'b0;
    end else begin
        state <= next_state;
        out_bytes_reg <= {byte1, byte2, byte3};
        done_reg <= (state == BYTE3);
    end
end

always @* begin
    case (state)
        IDLE: begin
            if (in[3] == 1'b1) begin
                next_state = BYTE1;
                byte1 = in;
            end else begin
                next_state = IDLE;
            end
        end
        BYTE1: begin
            next_state = BYTE2;
            byte2 = in;
        end
        BYTE2: begin
            next_state = BYTE3;
            byte3 = in;
        end
        BYTE3: begin
            next_state = IDLE;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

assign out_bytes = out_bytes_reg;
assign done = done_reg;

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states
parameter IDLE = 2'b00;
parameter BYTE1 = 2'b01;
parameter BYTE2 = 2'b10;
parameter BYTE3 = 2'b11;

// Define signals
reg [1:0] state, next_state;
reg [7:0] byte1, byte2, byte3;
reg [23:0] out_bytes_reg;
reg done_reg;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        byte1 <= 8'b0;
        byte2 <= 8'b0;
        byte3 <= 8'b0;
        out_bytes_reg <= 24'b0;
        done_reg <= 1'b0;
    end else begin
        state <= next_state;
        out_bytes_reg <= {byte1, byte2, byte3};
        done_reg <= (state == BYTE3);
    end
end

always @* begin
    case (state)
        IDLE: begin
            if (in[3] == 1'b1) begin
                next_state = BYTE1;
                byte1 = in;
            end else begin
                next_state = IDLE;
            end
        end
        BYTE1: begin
            next_state = BYTE2;
            byte2 = in;
        end
        BYTE2: begin
            next_state = BYTE3;
            byte3 = in;
        end
        BYTE3: begin
            next_state = IDLE;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

assign out_bytes = out_bytes_reg;
assign done = done_reg;

endmodule
"
"
    // Define states
    typedef enum logic [1:0] {
        IDLE,
        BYTE1,
        BYTE2,
        BYTE3
    } state_t;
    
    // Define signals
    state_t state, next_state;
    logic [7:0] byte1, byte2, byte3;
    
    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            byte1 <= 8'b0;
            byte2 <= 8'b0;
            byte3 <= 8'b0;
        end else begin
            case(state)
                IDLE: begin
                    byte1 <= in;
                    byte2 <= 8'b0;
                    byte3 <= 8'b0;
                end
                BYTE1: begin
                    byte2 <= in;
                end
                BYTE2: begin
                    byte3 <= in;
                end
                BYTE3: begin
                    byte1 <= 8'b0;
                    byte2 <= 8'b0;
                    byte3 <= 8'b0;
                end
            endcase
        end
    end
    
    // FSM
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            case(state)
                IDLE: begin
                    if (in[3] == 1) begin
                        next_state <= BYTE1;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                BYTE1: begin
                    next_state <= BYTE2;
                end
                BYTE2: begin
                    next_state <= BYTE3;
                end
                BYTE3: begin
                    next_state <= IDLE;
                end
            endcase
        end
    end
    
    // Output logic
    assign out_bytes = {byte1, byte2, byte3};
    assign done = (state == BYTE3);
    
endmodule
",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);



    // Define states
    typedef enum logic [1:0] {
        IDLE,
        BYTE1,
        BYTE2,
        BYTE3
    } state_t;
    
    // Define signals
    state_t state, next_state;
    logic [7:0] byte1, byte2, byte3;
    
    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            byte1 <= 8'b0;
            byte2 <= 8'b0;
            byte3 <= 8'b0;
        end else begin
            case(state)
                IDLE: begin
                    byte1 <= in;
                    byte2 <= 8'b0;
                    byte3 <= 8'b0;
                end
                BYTE1: begin
                    byte2 <= in;
                end
                BYTE2: begin
                    byte3 <= in;
                end
                BYTE3: begin
                    byte1 <= 8'b0;
                    byte2 <= 8'b0;
                    byte3 <= 8'b0;
                end
            endcase
        end
    end
    
    // FSM
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            case(state)
                IDLE: begin
                    if (in[3] == 1) begin
                        next_state <= BYTE1;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                BYTE1: begin
                    next_state <= BYTE2;
                end
                BYTE2: begin
                    next_state <= BYTE3;
                end
                BYTE3: begin
                    next_state <= IDLE;
                end
            endcase
        end
    end
    
    // Output logic
    assign out_bytes = {byte1, byte2, byte3};
    assign done = (state == BYTE3);
    
endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);



    // Define states
    typedef enum logic [1:0] {
        IDLE,
        BYTE1,
        BYTE2,
        BYTE3
    } state_t;
    
    // Define signals
    state_t state, next_state;
    logic [7:0] byte1, byte2, byte3;
    
    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            byte1 <= 8'b0;
            byte2 <= 8'b0;
            byte3 <= 8'b0;
        end else begin
            case(state)
                IDLE: begin
                    byte1 <= in;
                    byte2 <= 8'b0;
                    byte3 <= 8'b0;
                end
                BYTE1: begin
                    byte2 <= in;
                end
                BYTE2: begin
                    byte3 <= in;
                end
                BYTE3: begin
                    byte1 <= 8'b0;
                    byte2 <= 8'b0;
                    byte3 <= 8'b0;
                end
            endcase
        end
    end
    
    // FSM
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            case(state)
                IDLE: begin
                    if (in[3] == 1) begin
                        next_state <= BYTE1;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                BYTE1: begin
                    next_state <= BYTE2;
                end
                BYTE2: begin
                    next_state <= BYTE3;
                end
                BYTE3: begin
                    next_state <= IDLE;
                end
            endcase
        end
    end
    
    // Output logic
    assign out_bytes = {byte1, byte2, byte3};
    assign done = (state == BYTE3);
    
endmodule
"
"    reg [1:0] state;
    reg [7:0] byte1, byte2, byte3;
    reg [5:0] count;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 2'b00;
            count <= 6'b0;
        end else begin
            case(state)
                2'b00: begin // State 0: Wait for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        byte1 <= in;
                        count <= 6'b1;
                        state <= 2'b01;
                    end
                end
                2'b01: begin // State 1: Receive second byte
                    byte2 <= in;
                    count <= count + 1;
                    state <= 2'b10;
                end
                2'b10: begin // State 2: Receive third byte and output message
                    byte3 <= in;
                    out_bytes <= {byte1, byte2, byte3};
                    state <= 2'b00;
                    count <= 6'b0;
                end
            endcase
        end
    end
    
    assign done = (state == 2'b10);
    
endmodule
",-1.0,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


    reg [1:0] state;
    reg [7:0] byte1, byte2, byte3;
    reg [5:0] count;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 2'b00;
            count <= 6'b0;
        end else begin
            case(state)
                2'b00: begin // State 0: Wait for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        byte1 <= in;
                        count <= 6'b1;
                        state <= 2'b01;
                    end
                end
                2'b01: begin // State 1: Receive second byte
                    byte2 <= in;
                    count <= count + 1;
                    state <= 2'b10;
                end
                2'b10: begin // State 2: Receive third byte and output message
                    byte3 <= in;
                    out_bytes <= {byte1, byte2, byte3};
                    state <= 2'b00;
                    count <= 6'b0;
                end
            endcase
        end
    end
    
    assign done = (state == 2'b10);
    
endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


    reg [1:0] state;
    reg [7:0] byte1, byte2, byte3;
    reg [5:0] count;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 2'b00;
            count <= 6'b0;
        end else begin
            case(state)
                2'b00: begin // State 0: Wait for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        byte1 <= in;
                        count <= 6'b1;
                        state <= 2'b01;
                    end
                end
                2'b01: begin // State 1: Receive second byte
                    byte2 <= in;
                    count <= count + 1;
                    state <= 2'b10;
                end
                2'b10: begin // State 2: Receive third byte and output message
                    byte3 <= in;
                    out_bytes <= {byte1, byte2, byte3};
                    state <= 2'b00;
                    count <= 6'b0;
                end
            endcase
        end
    end
    
    assign done = (state == 2'b10);
    
endmodule
"
"// Define states for the FSM
parameter IDLE = 2'b00;
parameter BYTE1 = 2'b01;
parameter BYTE2 = 2'b10;
parameter BYTE3 = 2'b11;

// Define signals for the FSM
reg [1:0] state, next_state;
reg [7:0] byte1, byte2, byte3;
reg [23:0] out_bytes_reg;
reg done_reg;

// Datapath to store incoming bytes
always @(posedge clk) begin
    if (reset) begin
        byte1 <= 8'b0;
        byte2 <= 8'b0;
        byte3 <= 8'b0;
    end else begin
        case(state)
            BYTE1: byte1 <= in;
            BYTE2: byte2 <= in;
            BYTE3: byte3 <= in;
        endcase
    end
end

// FSM to detect message boundaries
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'b0;
        done_reg <= 1'b0;
    end else begin
        case(state)
            IDLE: begin
                if (in[3] == 1'b1) begin
                    next_state <= BYTE1;
                end else begin
                    next_state <= IDLE;
                end
            end
            BYTE1: next_state <= BYTE2;
            BYTE2: next_state <= BYTE3;
            BYTE3: begin
                next_state <= IDLE;
                done_reg <= 1'b1;
            end
        endcase
    end
end

// Update state and output bytes
always @(posedge clk) begin
    state <= next_state;
    if (done_reg) begin
        out_bytes_reg[23:16] <= byte1;
        out_bytes_reg[15:8] <= byte2;
        out_bytes_reg[7:0] <= byte3;
    end
end

// Assign outputs
assign out_bytes = out_bytes_reg;
assign done = done_reg;
",-1.0,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states for the FSM
parameter IDLE = 2'b00;
parameter BYTE1 = 2'b01;
parameter BYTE2 = 2'b10;
parameter BYTE3 = 2'b11;

// Define signals for the FSM
reg [1:0] state, next_state;
reg [7:0] byte1, byte2, byte3;
reg [23:0] out_bytes_reg;
reg done_reg;

// Datapath to store incoming bytes
always @(posedge clk) begin
    if (reset) begin
        byte1 <= 8'b0;
        byte2 <= 8'b0;
        byte3 <= 8'b0;
    end else begin
        case(state)
            BYTE1: byte1 <= in;
            BYTE2: byte2 <= in;
            BYTE3: byte3 <= in;
        endcase
    end
end

// FSM to detect message boundaries
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'b0;
        done_reg <= 1'b0;
    end else begin
        case(state)
            IDLE: begin
                if (in[3] == 1'b1) begin
                    next_state <= BYTE1;
                end else begin
                    next_state <= IDLE;
                end
            end
            BYTE1: next_state <= BYTE2;
            BYTE2: next_state <= BYTE3;
            BYTE3: begin
                next_state <= IDLE;
                done_reg <= 1'b1;
            end
        endcase
    end
end

// Update state and output bytes
always @(posedge clk) begin
    state <= next_state;
    if (done_reg) begin
        out_bytes_reg[23:16] <= byte1;
        out_bytes_reg[15:8] <= byte2;
        out_bytes_reg[7:0] <= byte3;
    end
end

// Assign outputs
assign out_bytes = out_bytes_reg;
assign done = done_reg;
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states for the FSM
parameter IDLE = 2'b00;
parameter BYTE1 = 2'b01;
parameter BYTE2 = 2'b10;
parameter BYTE3 = 2'b11;

// Define signals for the FSM
reg [1:0] state, next_state;
reg [7:0] byte1, byte2, byte3;
reg [23:0] out_bytes_reg;
reg done_reg;

// Datapath to store incoming bytes
always @(posedge clk) begin
    if (reset) begin
        byte1 <= 8'b0;
        byte2 <= 8'b0;
        byte3 <= 8'b0;
    end else begin
        case(state)
            BYTE1: byte1 <= in;
            BYTE2: byte2 <= in;
            BYTE3: byte3 <= in;
        endcase
    end
end

// FSM to detect message boundaries
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'b0;
        done_reg <= 1'b0;
    end else begin
        case(state)
            IDLE: begin
                if (in[3] == 1'b1) begin
                    next_state <= BYTE1;
                end else begin
                    next_state <= IDLE;
                end
            end
            BYTE1: next_state <= BYTE2;
            BYTE2: next_state <= BYTE3;
            BYTE3: begin
                next_state <= IDLE;
                done_reg <= 1'b1;
            end
        endcase
    end
end

// Update state and output bytes
always @(posedge clk) begin
    state <= next_state;
    if (done_reg) begin
        out_bytes_reg[23:16] <= byte1;
        out_bytes_reg[15:8] <= byte2;
        out_bytes_reg[7:0] <= byte3;
    end
end

// Assign outputs
assign out_bytes = out_bytes_reg;
assign done = done_reg;
"
"
    reg [1:0] state;
    reg [7:0] byte1, byte2, byte3;
    reg [23:0] out_bytes_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00;
            byte1 <= 8'b0;
            byte2 <= 8'b0;
            byte3 <= 8'b0;
            out_bytes_reg <= 24'b0;
        end else begin
            case (state)
                2'b00: begin // Wait for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        state <= 2'b01;
                        byte1 <= in;
                    end
                end
                2'b01: begin // Receive second byte
                    state <= 2'b10;
                    byte2 <= in;
                end
                2'b10: begin // Receive third byte and output message
                    state <= 2'b00;
                    byte3 <= in;
                    out_bytes_reg <= {byte1, byte2, byte3};
                end
            endcase
        end
    end
    
    assign out_bytes = out_bytes_reg;
    assign done = (state == 2'b10);
endmodule
",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);



    reg [1:0] state;
    reg [7:0] byte1, byte2, byte3;
    reg [23:0] out_bytes_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00;
            byte1 <= 8'b0;
            byte2 <= 8'b0;
            byte3 <= 8'b0;
            out_bytes_reg <= 24'b0;
        end else begin
            case (state)
                2'b00: begin // Wait for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        state <= 2'b01;
                        byte1 <= in;
                    end
                end
                2'b01: begin // Receive second byte
                    state <= 2'b10;
                    byte2 <= in;
                end
                2'b10: begin // Receive third byte and output message
                    state <= 2'b00;
                    byte3 <= in;
                    out_bytes_reg <= {byte1, byte2, byte3};
                end
            endcase
        end
    end
    
    assign out_bytes = out_bytes_reg;
    assign done = (state == 2'b10);
endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);



    reg [1:0] state;
    reg [7:0] byte1, byte2, byte3;
    reg [23:0] out_bytes_reg;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00;
            byte1 <= 8'b0;
            byte2 <= 8'b0;
            byte3 <= 8'b0;
            out_bytes_reg <= 24'b0;
        end else begin
            case (state)
                2'b00: begin // Wait for first byte with bit[3]=1
                    if (in[3] == 1) begin
                        state <= 2'b01;
                        byte1 <= in;
                    end
                end
                2'b01: begin // Receive second byte
                    state <= 2'b10;
                    byte2 <= in;
                end
                2'b10: begin // Receive third byte and output message
                    state <= 2'b00;
                    byte3 <= in;
                    out_bytes_reg <= {byte1, byte2, byte3};
                end
            endcase
        end
    end
    
    assign out_bytes = out_bytes_reg;
    assign done = (state == 2'b10);
endmodule
"
"// Define states
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define outputs
reg [23:0] out_bytes_reg;
reg [23:0] out_bytes;
reg done;

// Define state and next state
state_t state, next_state;

// Define datapath for storing incoming bytes
reg [7:0] byte1, byte2, byte3;

// FSM
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'b0;
        done <= 0;
    end else begin
        state <= next_state;
        out_bytes_reg <= out_bytes;
        done <= 0;
    end
end

// Datapath
always @(*) begin
    case(state)
        IDLE: begin
            if (in[3] == 1) begin
                byte1 <= in;
                next_state <= BYTE1;
            end else begin
                byte1 <= 8'b0;
                next_state <= IDLE;
            end
        end
        
        BYTE1: begin
            byte2 <= in;
            next_state <= BYTE2;
        end
        
        BYTE2: begin
            byte3 <= in;
            next_state <= BYTE3;
        end
        
        BYTE3: begin
            out_bytes[23:16] <= byte1;
            out_bytes[15:8] <= byte2;
            out_bytes[7:0] <= byte3;
            next_state <= IDLE;
            done <= 1;
        end
    endcase
end

// Assign output
assign out_bytes = out_bytes_reg;

endmodule
",-1.0,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define outputs
reg [23:0] out_bytes_reg;
reg [23:0] out_bytes;
reg done;

// Define state and next state
state_t state, next_state;

// Define datapath for storing incoming bytes
reg [7:0] byte1, byte2, byte3;

// FSM
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'b0;
        done <= 0;
    end else begin
        state <= next_state;
        out_bytes_reg <= out_bytes;
        done <= 0;
    end
end

// Datapath
always @(*) begin
    case(state)
        IDLE: begin
            if (in[3] == 1) begin
                byte1 <= in;
                next_state <= BYTE1;
            end else begin
                byte1 <= 8'b0;
                next_state <= IDLE;
            end
        end
        
        BYTE1: begin
            byte2 <= in;
            next_state <= BYTE2;
        end
        
        BYTE2: begin
            byte3 <= in;
            next_state <= BYTE3;
        end
        
        BYTE3: begin
            out_bytes[23:16] <= byte1;
            out_bytes[15:8] <= byte2;
            out_bytes[7:0] <= byte3;
            next_state <= IDLE;
            done <= 1;
        end
    endcase
end

// Assign output
assign out_bytes = out_bytes_reg;

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define outputs
reg [23:0] out_bytes_reg;
reg [23:0] out_bytes;
reg done;

// Define state and next state
state_t state, next_state;

// Define datapath for storing incoming bytes
reg [7:0] byte1, byte2, byte3;

// FSM
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'b0;
        done <= 0;
    end else begin
        state <= next_state;
        out_bytes_reg <= out_bytes;
        done <= 0;
    end
end

// Datapath
always @(*) begin
    case(state)
        IDLE: begin
            if (in[3] == 1) begin
                byte1 <= in;
                next_state <= BYTE1;
            end else begin
                byte1 <= 8'b0;
                next_state <= IDLE;
            end
        end
        
        BYTE1: begin
            byte2 <= in;
            next_state <= BYTE2;
        end
        
        BYTE2: begin
            byte3 <= in;
            next_state <= BYTE3;
        end
        
        BYTE3: begin
            out_bytes[23:16] <= byte1;
            out_bytes[15:8] <= byte2;
            out_bytes[7:0] <= byte3;
            next_state <= IDLE;
            done <= 1;
        end
    endcase
end

// Assign output
assign out_bytes = out_bytes_reg;

endmodule
"
"// Define states for the FSM
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define registers for the datapath
reg [7:0] byte1, byte2, byte3;
reg [1:0] state_reg, next_state_reg;
reg [23:0] out_bytes_reg;
reg done_reg;

// Define combinational logic for next state and output bytes
always_comb begin
    next_state_reg = state_reg;
    out_bytes_reg = {byte1, byte2, byte3};
    done_reg = 0;
    
    case(state_reg)
        IDLE: begin
            if(in[3] == 1) begin
                byte1 = in;
                next_state_reg = BYTE1;
            end
        end
        BYTE1: begin
            byte2 = in;
            next_state_reg = BYTE2;
        end
        BYTE2: begin
            byte3 = in;
            next_state_reg = BYTE3;
        end
        BYTE3: begin
            done_reg = 1;
            next_state_reg = IDLE;
        end
    endcase
end

// Define sequential logic for state transition
always_ff @(posedge clk) begin
    if(reset) begin
        state_reg <= IDLE;
    end else begin
        state_reg <= next_state_reg;
    end
end

// Assign outputs
assign out_bytes = out_bytes_reg;
assign done = done_reg;

endmodule
",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states for the FSM
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define registers for the datapath
reg [7:0] byte1, byte2, byte3;
reg [1:0] state_reg, next_state_reg;
reg [23:0] out_bytes_reg;
reg done_reg;

// Define combinational logic for next state and output bytes
always_comb begin
    next_state_reg = state_reg;
    out_bytes_reg = {byte1, byte2, byte3};
    done_reg = 0;
    
    case(state_reg)
        IDLE: begin
            if(in[3] == 1) begin
                byte1 = in;
                next_state_reg = BYTE1;
            end
        end
        BYTE1: begin
            byte2 = in;
            next_state_reg = BYTE2;
        end
        BYTE2: begin
            byte3 = in;
            next_state_reg = BYTE3;
        end
        BYTE3: begin
            done_reg = 1;
            next_state_reg = IDLE;
        end
    endcase
end

// Define sequential logic for state transition
always_ff @(posedge clk) begin
    if(reset) begin
        state_reg <= IDLE;
    end else begin
        state_reg <= next_state_reg;
    end
end

// Assign outputs
assign out_bytes = out_bytes_reg;
assign done = done_reg;

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states for the FSM
typedef enum logic [1:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define registers for the datapath
reg [7:0] byte1, byte2, byte3;
reg [1:0] state_reg, next_state_reg;
reg [23:0] out_bytes_reg;
reg done_reg;

// Define combinational logic for next state and output bytes
always_comb begin
    next_state_reg = state_reg;
    out_bytes_reg = {byte1, byte2, byte3};
    done_reg = 0;
    
    case(state_reg)
        IDLE: begin
            if(in[3] == 1) begin
                byte1 = in;
                next_state_reg = BYTE1;
            end
        end
        BYTE1: begin
            byte2 = in;
            next_state_reg = BYTE2;
        end
        BYTE2: begin
            byte3 = in;
            next_state_reg = BYTE3;
        end
        BYTE3: begin
            done_reg = 1;
            next_state_reg = IDLE;
        end
    endcase
end

// Define sequential logic for state transition
always_ff @(posedge clk) begin
    if(reset) begin
        state_reg <= IDLE;
    end else begin
        state_reg <= next_state_reg;
    end
end

// Assign outputs
assign out_bytes = out_bytes_reg;
assign done = done_reg;

endmodule
"
"// Define states for the FSM
typedef enum logic [2:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define signals for the datapath
reg [7:0] byte1;
reg [7:0] byte2;
reg [7:0] byte3;
reg [23:0] out_bytes_reg;

// Define state and next_state variables
state_t state, next_state;

// Define FSM logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'h0;
    end else begin
        state <= next_state;
    end
end

// Define datapath logic
always_comb begin
    case(state)
        IDLE: begin
            if (in[3] == 1) begin
                byte1 <= in;
                next_state = BYTE1;
            end else begin
                next_state = IDLE;
            end
        end
        BYTE1: begin
            byte2 <= in;
            next_state = BYTE2;
        end
        BYTE2: begin
            byte3 <= in;
            next_state = BYTE3;
        end
        BYTE3: begin
            out_bytes_reg = {byte1, byte2, byte3};
            next_state = IDLE;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

// Output logic
assign out_bytes = out_bytes_reg;
assign done = (state == BYTE3);
",-1.0,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states for the FSM
typedef enum logic [2:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define signals for the datapath
reg [7:0] byte1;
reg [7:0] byte2;
reg [7:0] byte3;
reg [23:0] out_bytes_reg;

// Define state and next_state variables
state_t state, next_state;

// Define FSM logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'h0;
    end else begin
        state <= next_state;
    end
end

// Define datapath logic
always_comb begin
    case(state)
        IDLE: begin
            if (in[3] == 1) begin
                byte1 <= in;
                next_state = BYTE1;
            end else begin
                next_state = IDLE;
            end
        end
        BYTE1: begin
            byte2 <= in;
            next_state = BYTE2;
        end
        BYTE2: begin
            byte3 <= in;
            next_state = BYTE3;
        end
        BYTE3: begin
            out_bytes_reg = {byte1, byte2, byte3};
            next_state = IDLE;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

// Output logic
assign out_bytes = out_bytes_reg;
assign done = (state == BYTE3);
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states for the FSM
typedef enum logic [2:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define signals for the datapath
reg [7:0] byte1;
reg [7:0] byte2;
reg [7:0] byte3;
reg [23:0] out_bytes_reg;

// Define state and next_state variables
state_t state, next_state;

// Define FSM logic
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'h0;
    end else begin
        state <= next_state;
    end
end

// Define datapath logic
always_comb begin
    case(state)
        IDLE: begin
            if (in[3] == 1) begin
                byte1 <= in;
                next_state = BYTE1;
            end else begin
                next_state = IDLE;
            end
        end
        BYTE1: begin
            byte2 <= in;
            next_state = BYTE2;
        end
        BYTE2: begin
            byte3 <= in;
            next_state = BYTE3;
        end
        BYTE3: begin
            out_bytes_reg = {byte1, byte2, byte3};
            next_state = IDLE;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

// Output logic
assign out_bytes = out_bytes_reg;
assign done = (state == BYTE3);
"
"// Define states
parameter IDLE = 2'b00;
parameter BYTE1 = 2'b01;
parameter BYTE2 = 2'b10;
parameter BYTE3 = 2'b11;

// Define signals
reg [1:0] state, next_state;
reg [7:0] byte1, byte2, byte3;
reg [23:0] out_bytes_reg;
reg done_reg;

// Datapath to store incoming bytes
always @(posedge clk) begin
    if (reset) begin
        byte1 <= 8'b0;
        byte2 <= 8'b0;
        byte3 <= 8'b0;
    end else begin
        case(state)
            BYTE1: byte1 <= in;
            BYTE2: byte2 <= in;
            BYTE3: byte3 <= in;
        endcase
    end
end

// FSM
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'b0;
        done_reg <= 1'b0;
    end else begin
        case(state)
            IDLE: begin
                if (in[3] == 1'b1) begin
                    next_state <= BYTE1;
                end else begin
                    next_state <= IDLE;
                end
            end
            BYTE1: next_state <= BYTE2;
            BYTE2: next_state <= BYTE3;
            BYTE3: begin
                next_state <= IDLE;
                done_reg <= 1'b1;
            end
        endcase
    end
end

// Output the 24-bit message when a packet is received
always @(posedge clk) begin
    if (reset) begin
        out_bytes <= 24'b0;
    end else begin
        if (done_reg) begin
            out_bytes <= {byte1, byte2, byte3};
        end else begin
            out_bytes <= out_bytes_reg;
        end
    end
end

// Update state
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
    end else begin
        state <= next_state;
    end
end

// Update done signal
always @(posedge clk) begin
    if (reset) begin
        done <= 1'b0;
    end else begin
        done <= done_reg;
    end
end

endmodule
",-1.0,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states
parameter IDLE = 2'b00;
parameter BYTE1 = 2'b01;
parameter BYTE2 = 2'b10;
parameter BYTE3 = 2'b11;

// Define signals
reg [1:0] state, next_state;
reg [7:0] byte1, byte2, byte3;
reg [23:0] out_bytes_reg;
reg done_reg;

// Datapath to store incoming bytes
always @(posedge clk) begin
    if (reset) begin
        byte1 <= 8'b0;
        byte2 <= 8'b0;
        byte3 <= 8'b0;
    end else begin
        case(state)
            BYTE1: byte1 <= in;
            BYTE2: byte2 <= in;
            BYTE3: byte3 <= in;
        endcase
    end
end

// FSM
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'b0;
        done_reg <= 1'b0;
    end else begin
        case(state)
            IDLE: begin
                if (in[3] == 1'b1) begin
                    next_state <= BYTE1;
                end else begin
                    next_state <= IDLE;
                end
            end
            BYTE1: next_state <= BYTE2;
            BYTE2: next_state <= BYTE3;
            BYTE3: begin
                next_state <= IDLE;
                done_reg <= 1'b1;
            end
        endcase
    end
end

// Output the 24-bit message when a packet is received
always @(posedge clk) begin
    if (reset) begin
        out_bytes <= 24'b0;
    end else begin
        if (done_reg) begin
            out_bytes <= {byte1, byte2, byte3};
        end else begin
            out_bytes <= out_bytes_reg;
        end
    end
end

// Update state
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
    end else begin
        state <= next_state;
    end
end

// Update done signal
always @(posedge clk) begin
    if (reset) begin
        done <= 1'b0;
    end else begin
        done <= done_reg;
    end
end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states
parameter IDLE = 2'b00;
parameter BYTE1 = 2'b01;
parameter BYTE2 = 2'b10;
parameter BYTE3 = 2'b11;

// Define signals
reg [1:0] state, next_state;
reg [7:0] byte1, byte2, byte3;
reg [23:0] out_bytes_reg;
reg done_reg;

// Datapath to store incoming bytes
always @(posedge clk) begin
    if (reset) begin
        byte1 <= 8'b0;
        byte2 <= 8'b0;
        byte3 <= 8'b0;
    end else begin
        case(state)
            BYTE1: byte1 <= in;
            BYTE2: byte2 <= in;
            BYTE3: byte3 <= in;
        endcase
    end
end

// FSM
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
        out_bytes_reg <= 24'b0;
        done_reg <= 1'b0;
    end else begin
        case(state)
            IDLE: begin
                if (in[3] == 1'b1) begin
                    next_state <= BYTE1;
                end else begin
                    next_state <= IDLE;
                end
            end
            BYTE1: next_state <= BYTE2;
            BYTE2: next_state <= BYTE3;
            BYTE3: begin
                next_state <= IDLE;
                done_reg <= 1'b1;
            end
        endcase
    end
end

// Output the 24-bit message when a packet is received
always @(posedge clk) begin
    if (reset) begin
        out_bytes <= 24'b0;
    end else begin
        if (done_reg) begin
            out_bytes <= {byte1, byte2, byte3};
        end else begin
            out_bytes <= out_bytes_reg;
        end
    end
end

// Update state
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
    end else begin
        state <= next_state;
    end
end

// Update done signal
always @(posedge clk) begin
    if (reset) begin
        done <= 1'b0;
    end else begin
        done <= done_reg;
    end
end

endmodule
"
"// Define states for the FSM
typedef enum logic [2:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define signals for the datapath
reg [7:0] byte1;
reg [7:0] byte2;
reg [7:0] byte3;
reg [2:0] state;
reg [3:0] count;

// Define outputs
assign out_bytes = {byte1, byte2, byte3};
assign done = (state == BYTE3);

// FSM
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        count <= 0;
    end else begin
        case(state)
            IDLE: begin
                if (in[3] == 1) begin
                    state <= BYTE1;
                    count <= 0;
                end
            end
            BYTE1: begin
                byte1 <= in;
                count <= count + 1;
                if (count == 2) begin
                    state <= BYTE2;
                    count <= 0;
                end
            end
            BYTE2: begin
                byte2 <= in;
                count <= count + 1;
                if (count == 2) begin
                    state <= BYTE3;
                    count <= 0;
                end
            end
            BYTE3: begin
                byte3 <= in;
                count <= count + 1;
                if (count == 2) begin
                    state <= IDLE;
                    count <= 0;
                end
            end
        endcase
    end
end

endmodule
",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states for the FSM
typedef enum logic [2:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define signals for the datapath
reg [7:0] byte1;
reg [7:0] byte2;
reg [7:0] byte3;
reg [2:0] state;
reg [3:0] count;

// Define outputs
assign out_bytes = {byte1, byte2, byte3};
assign done = (state == BYTE3);

// FSM
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        count <= 0;
    end else begin
        case(state)
            IDLE: begin
                if (in[3] == 1) begin
                    state <= BYTE1;
                    count <= 0;
                end
            end
            BYTE1: begin
                byte1 <= in;
                count <= count + 1;
                if (count == 2) begin
                    state <= BYTE2;
                    count <= 0;
                end
            end
            BYTE2: begin
                byte2 <= in;
                count <= count + 1;
                if (count == 2) begin
                    state <= BYTE3;
                    count <= 0;
                end
            end
            BYTE3: begin
                byte3 <= in;
                count <= count + 1;
                if (count == 2) begin
                    state <= IDLE;
                    count <= 0;
                end
            end
        endcase
    end
end

endmodule
","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);


// Define states for the FSM
typedef enum logic [2:0] {
    IDLE,
    BYTE1,
    BYTE2,
    BYTE3
} state_t;

// Define signals for the datapath
reg [7:0] byte1;
reg [7:0] byte2;
reg [7:0] byte3;
reg [2:0] state;
reg [3:0] count;

// Define outputs
assign out_bytes = {byte1, byte2, byte3};
assign done = (state == BYTE3);

// FSM
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        count <= 0;
    end else begin
        case(state)
            IDLE: begin
                if (in[3] == 1) begin
                    state <= BYTE1;
                    count <= 0;
                end
            end
            BYTE1: begin
                byte1 <= in;
                count <= count + 1;
                if (count == 2) begin
                    state <= BYTE2;
                    count <= 0;
                end
            end
            BYTE2: begin
                byte2 <= in;
                count <= count + 1;
                if (count == 2) begin
                    state <= BYTE3;
                    count <= 0;
                end
            end
            BYTE3: begin
                byte3 <= in;
                count <= count + 1;
                if (count == 2) begin
                    state <= IDLE;
                    count <= 0;
                end
            end
        endcase
    end
end

endmodule
"
"    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Registers
    state_t state, next_state;
    logic [2:0] data_count;
    logic start_bit_detected, stop_bit_detected;

    // Combinational logic
    always_comb begin
        start_bit_detected = (state == START_BIT) && in;
        stop_bit_detected = (state == STOP_BIT) && !in;
    end

    // State transition and output logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_count <= 3'b0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                        data_count <= 3'b0;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    if (start_bit_detected) begin
                        next_state = DATA_BITS;
                    end else begin
                        next_state = START_BIT;
                    end
                end
                DATA_BITS: begin
                    if (data_count == 3'b111) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                        data_count <= data_count + 1;
                    end
                end
                STOP_BIT: begin
                    if (stop_bit_detected) begin
                        next_state = IDLE;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end

    // Output assignment
    assign done = (state == STOP_BIT);

endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Registers
    state_t state, next_state;
    logic [2:0] data_count;
    logic start_bit_detected, stop_bit_detected;

    // Combinational logic
    always_comb begin
        start_bit_detected = (state == START_BIT) && in;
        stop_bit_detected = (state == STOP_BIT) && !in;
    end

    // State transition and output logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_count <= 3'b0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                        data_count <= 3'b0;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    if (start_bit_detected) begin
                        next_state = DATA_BITS;
                    end else begin
                        next_state = START_BIT;
                    end
                end
                DATA_BITS: begin
                    if (data_count == 3'b111) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                        data_count <= data_count + 1;
                    end
                end
                STOP_BIT: begin
                    if (stop_bit_detected) begin
                        next_state = IDLE;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end

    // Output assignment
    assign done = (state == STOP_BIT);

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Registers
    state_t state, next_state;
    logic [2:0] data_count;
    logic start_bit_detected, stop_bit_detected;

    // Combinational logic
    always_comb begin
        start_bit_detected = (state == START_BIT) && in;
        stop_bit_detected = (state == STOP_BIT) && !in;
    end

    // State transition and output logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_count <= 3'b0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                        data_count <= 3'b0;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    if (start_bit_detected) begin
                        next_state = DATA_BITS;
                    end else begin
                        next_state = START_BIT;
                    end
                end
                DATA_BITS: begin
                    if (data_count == 3'b111) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                        data_count <= data_count + 1;
                    end
                end
                STOP_BIT: begin
                    if (stop_bit_detected) begin
                        next_state = IDLE;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end

    // Output assignment
    assign done = (state == STOP_BIT);

endmodule
"
"    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_type;
    
    // Registers
    state_type state, next_state;
    logic [2:0] data_count;
    logic start_detected, stop_detected;
    
    // Combinational logic
    always_comb begin
        start_detected = (state == START_BIT) ? 1 : 0;
        stop_detected = (state == STOP_BIT) ? 1 : 0;
    end
    
    // Sequential logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_count <= 3'b0;
        end else begin
            state <= next_state;
            data_count <= (state == DATA_BITS) ? data_count + 1 : 3'b0;
        end
    end
    
    // State transition and output logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 1) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            START_BIT: begin
                if (in == 0) begin
                    next_state = DATA_BITS;
                end else begin
                    next_state = START_BIT;
                end
            end
            DATA_BITS: begin
                if (data_count == 8) begin
                    next_state = STOP_BIT;
                end else begin
                    next_state = DATA_BITS;
                end
            end
            STOP_BIT: begin
                if (in == 1) begin
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output
    assign done = stop_detected;
    
endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_type;
    
    // Registers
    state_type state, next_state;
    logic [2:0] data_count;
    logic start_detected, stop_detected;
    
    // Combinational logic
    always_comb begin
        start_detected = (state == START_BIT) ? 1 : 0;
        stop_detected = (state == STOP_BIT) ? 1 : 0;
    end
    
    // Sequential logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_count <= 3'b0;
        end else begin
            state <= next_state;
            data_count <= (state == DATA_BITS) ? data_count + 1 : 3'b0;
        end
    end
    
    // State transition and output logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 1) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            START_BIT: begin
                if (in == 0) begin
                    next_state = DATA_BITS;
                end else begin
                    next_state = START_BIT;
                end
            end
            DATA_BITS: begin
                if (data_count == 8) begin
                    next_state = STOP_BIT;
                end else begin
                    next_state = DATA_BITS;
                end
            end
            STOP_BIT: begin
                if (in == 1) begin
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output
    assign done = stop_detected;
    
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_type;
    
    // Registers
    state_type state, next_state;
    logic [2:0] data_count;
    logic start_detected, stop_detected;
    
    // Combinational logic
    always_comb begin
        start_detected = (state == START_BIT) ? 1 : 0;
        stop_detected = (state == STOP_BIT) ? 1 : 0;
    end
    
    // Sequential logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_count <= 3'b0;
        end else begin
            state <= next_state;
            data_count <= (state == DATA_BITS) ? data_count + 1 : 3'b0;
        end
    end
    
    // State transition and output logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 1) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            START_BIT: begin
                if (in == 0) begin
                    next_state = DATA_BITS;
                end else begin
                    next_state = START_BIT;
                end
            end
            DATA_BITS: begin
                if (data_count == 8) begin
                    next_state = STOP_BIT;
                end else begin
                    next_state = DATA_BITS;
                end
            end
            STOP_BIT: begin
                if (in == 1) begin
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output
    assign done = stop_detected;
    
endmodule
"
"    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define outputs
    reg done;
    
    // Define state register
    reg [1:0] state;
    
    // Define data register
    reg [7:0] data;
    
    // Define count register
    reg [2:0] count;
    
    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            count <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (in == 1) begin
                        state <= START_BIT;
                        count <= 0;
                    end
                end
                START_BIT: begin
                    if (count < 8) begin
                        data[count] <= in;
                        count <= count + 1;
                    end else begin
                        state <= STOP_BIT;
                        count <= 0;
                    end
                end
                DATA_BITS: begin
                    if (count < 8) begin
                        data[count] <= in;
                        count <= count + 1;
                    end else begin
                        state <= STOP_BIT;
                        count <= 0;
                    end
                end
                STOP_BIT: begin
                    if (in == 1) begin
                        done <= 1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
    
endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define outputs
    reg done;
    
    // Define state register
    reg [1:0] state;
    
    // Define data register
    reg [7:0] data;
    
    // Define count register
    reg [2:0] count;
    
    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            count <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (in == 1) begin
                        state <= START_BIT;
                        count <= 0;
                    end
                end
                START_BIT: begin
                    if (count < 8) begin
                        data[count] <= in;
                        count <= count + 1;
                    end else begin
                        state <= STOP_BIT;
                        count <= 0;
                    end
                end
                DATA_BITS: begin
                    if (count < 8) begin
                        data[count] <= in;
                        count <= count + 1;
                    end else begin
                        state <= STOP_BIT;
                        count <= 0;
                    end
                end
                STOP_BIT: begin
                    if (in == 1) begin
                        done <= 1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
    
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define outputs
    reg done;
    
    // Define state register
    reg [1:0] state;
    
    // Define data register
    reg [7:0] data;
    
    // Define count register
    reg [2:0] count;
    
    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            count <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (in == 1) begin
                        state <= START_BIT;
                        count <= 0;
                    end
                end
                START_BIT: begin
                    if (count < 8) begin
                        data[count] <= in;
                        count <= count + 1;
                    end else begin
                        state <= STOP_BIT;
                        count <= 0;
                    end
                end
                DATA_BITS: begin
                    if (count < 8) begin
                        data[count] <= in;
                        count <= count + 1;
                    end else begin
                        state <= STOP_BIT;
                        count <= 0;
                    end
                end
                STOP_BIT: begin
                    if (in == 1) begin
                        done <= 1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
    
endmodule
"
"
    // Define states
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;
    
    // Define signals
    state_t state, next_state;
    logic [7:0] data_bits;
    logic start_bit_detected, stop_bit_detected;
    logic [2:0] bit_counter;
    
    // Define parameters
    parameter START_BIT_VALUE = 1'b0;
    parameter STOP_BIT_VALUE = 1'b1;
    
    // Define FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            start_bit_detected <= 1'b0;
            stop_bit_detected <= 1'b0;
            bit_counter <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    // State transitions and logic
    always_comb begin
        case(state)
            IDLE: begin
                if (in == START_BIT_VALUE) begin
                    next_state = START_BIT;
                    start_bit_detected = 1'b1;
                    bit_counter = 0;
                end else begin
                    next_state = IDLE;
                    start_bit_detected = 1'b0;
                end
            end
            
            START_BIT: begin
                if (bit_counter < 8) begin
                    next_state = DATA_BITS;
                    data_bits[bit_counter] = in;
                    bit_counter = bit_counter + 1;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            
            DATA_BITS: begin
                if (bit_counter < 8) begin
                    next_state = DATA_BITS;
                    data_bits[bit_counter] = in;
                    bit_counter = bit_counter + 1;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            
            STOP_BIT: begin
                if (in == STOP_BIT_VALUE) begin
                    next_state = IDLE;
                    stop_bit_detected = 1'b1;
                end else begin
                    next_state = STOP_BIT;
                    stop_bit_detected = 1'b0;
                end
            end
        endcase
    end
    
    // Output
    assign done = (start_bit_detected && stop_bit_detected);
    
endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);

    // Define states
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;
    
    // Define signals
    state_t state, next_state;
    logic [7:0] data_bits;
    logic start_bit_detected, stop_bit_detected;
    logic [2:0] bit_counter;
    
    // Define parameters
    parameter START_BIT_VALUE = 1'b0;
    parameter STOP_BIT_VALUE = 1'b1;
    
    // Define FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            start_bit_detected <= 1'b0;
            stop_bit_detected <= 1'b0;
            bit_counter <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    // State transitions and logic
    always_comb begin
        case(state)
            IDLE: begin
                if (in == START_BIT_VALUE) begin
                    next_state = START_BIT;
                    start_bit_detected = 1'b1;
                    bit_counter = 0;
                end else begin
                    next_state = IDLE;
                    start_bit_detected = 1'b0;
                end
            end
            
            START_BIT: begin
                if (bit_counter < 8) begin
                    next_state = DATA_BITS;
                    data_bits[bit_counter] = in;
                    bit_counter = bit_counter + 1;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            
            DATA_BITS: begin
                if (bit_counter < 8) begin
                    next_state = DATA_BITS;
                    data_bits[bit_counter] = in;
                    bit_counter = bit_counter + 1;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            
            STOP_BIT: begin
                if (in == STOP_BIT_VALUE) begin
                    next_state = IDLE;
                    stop_bit_detected = 1'b1;
                end else begin
                    next_state = STOP_BIT;
                    stop_bit_detected = 1'b0;
                end
            end
        endcase
    end
    
    // Output
    assign done = (start_bit_detected && stop_bit_detected);
    
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);

    // Define states
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;
    
    // Define signals
    state_t state, next_state;
    logic [7:0] data_bits;
    logic start_bit_detected, stop_bit_detected;
    logic [2:0] bit_counter;
    
    // Define parameters
    parameter START_BIT_VALUE = 1'b0;
    parameter STOP_BIT_VALUE = 1'b1;
    
    // Define FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            start_bit_detected <= 1'b0;
            stop_bit_detected <= 1'b0;
            bit_counter <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    // State transitions and logic
    always_comb begin
        case(state)
            IDLE: begin
                if (in == START_BIT_VALUE) begin
                    next_state = START_BIT;
                    start_bit_detected = 1'b1;
                    bit_counter = 0;
                end else begin
                    next_state = IDLE;
                    start_bit_detected = 1'b0;
                end
            end
            
            START_BIT: begin
                if (bit_counter < 8) begin
                    next_state = DATA_BITS;
                    data_bits[bit_counter] = in;
                    bit_counter = bit_counter + 1;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            
            DATA_BITS: begin
                if (bit_counter < 8) begin
                    next_state = DATA_BITS;
                    data_bits[bit_counter] = in;
                    bit_counter = bit_counter + 1;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            
            STOP_BIT: begin
                if (in == STOP_BIT_VALUE) begin
                    next_state = IDLE;
                    stop_bit_detected = 1'b1;
                end else begin
                    next_state = STOP_BIT;
                    stop_bit_detected = 1'b0;
                end
            end
        endcase
    end
    
    // Output
    assign done = (start_bit_detected && stop_bit_detected);
    
endmodule
"
"
    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define signals
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg valid_data;
    
    // FSM logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data <= 8'b0;
            valid_data <= 1'b0;
        end else begin
            state <= next_state;
        end
    end
    
    // State transitions and data reception logic
    always @* begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            
            START_BIT: begin
                next_state = DATA_BITS;
            end
            
            DATA_BITS: begin
                data <= {data[6:0], in};
                if (valid_data == 1'b0) begin
                    if (data == 8'b00000001) begin
                        valid_data = 1'b1;
                    end
                end
                if (valid_data == 1'b1) begin
                    next_state = STOP_BIT;
                end
            end
            
            STOP_BIT: begin
                if (in == 1'b1) begin
                    valid_data = 0;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end
    
    // Output logic
    assign done = (state == STOP_BIT && valid_data == 1'b1);
    
endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);

    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define signals
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg valid_data;
    
    // FSM logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data <= 8'b0;
            valid_data <= 1'b0;
        end else begin
            state <= next_state;
        end
    end
    
    // State transitions and data reception logic
    always @* begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            
            START_BIT: begin
                next_state = DATA_BITS;
            end
            
            DATA_BITS: begin
                data <= {data[6:0], in};
                if (valid_data == 1'b0) begin
                    if (data == 8'b00000001) begin
                        valid_data = 1'b1;
                    end
                end
                if (valid_data == 1'b1) begin
                    next_state = STOP_BIT;
                end
            end
            
            STOP_BIT: begin
                if (in == 1'b1) begin
                    valid_data = 0;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end
    
    // Output logic
    assign done = (state == STOP_BIT && valid_data == 1'b1);
    
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);

    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define signals
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg valid_data;
    
    // FSM logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data <= 8'b0;
            valid_data <= 1'b0;
        end else begin
            state <= next_state;
        end
    end
    
    // State transitions and data reception logic
    always @* begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            
            START_BIT: begin
                next_state = DATA_BITS;
            end
            
            DATA_BITS: begin
                data <= {data[6:0], in};
                if (valid_data == 1'b0) begin
                    if (data == 8'b00000001) begin
                        valid_data = 1'b1;
                    end
                end
                if (valid_data == 1'b1) begin
                    next_state = STOP_BIT;
                end
            end
            
            STOP_BIT: begin
                if (in == 1'b1) begin
                    valid_data = 0;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end
    
    // Output logic
    assign done = (state == STOP_BIT && valid_data == 1'b1);
    
endmodule
"
"    reg [3:0] state;
    reg [7:0] data;
    reg done;

    parameter IDLE = 4'b0000;
    parameter START_BIT = 4'b0001;
    parameter DATA_BITS = 4'b0010;
    parameter STOP_BIT = 4'b0011;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data <= 8'b0;
            done <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (in == 1'b0) begin
                        state <= START_BIT;
                    end
                end
                START_BIT: begin
                    state <= DATA_BITS;
                end
                DATA_BITS: begin
                    data <= {data[6:0], in};
                    if (data[7] == 1'b1) begin
                        state <= STOP_BIT;
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        done <= 1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end

endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    reg [3:0] state;
    reg [7:0] data;
    reg done;

    parameter IDLE = 4'b0000;
    parameter START_BIT = 4'b0001;
    parameter DATA_BITS = 4'b0010;
    parameter STOP_BIT = 4'b0011;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data <= 8'b0;
            done <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (in == 1'b0) begin
                        state <= START_BIT;
                    end
                end
                START_BIT: begin
                    state <= DATA_BITS;
                end
                DATA_BITS: begin
                    data <= {data[6:0], in};
                    if (data[7] == 1'b1) begin
                        state <= STOP_BIT;
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        done <= 1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    reg [3:0] state;
    reg [7:0] data;
    reg done;

    parameter IDLE = 4'b0000;
    parameter START_BIT = 4'b0001;
    parameter DATA_BITS = 4'b0010;
    parameter STOP_BIT = 4'b0011;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data <= 8'b0;
            done <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (in == 1'b0) begin
                        state <= START_BIT;
                    end
                end
                START_BIT: begin
                    state <= DATA_BITS;
                end
                DATA_BITS: begin
                    data <= {data[6:0], in};
                    if (data[7] == 1'b1) begin
                        state <= STOP_BIT;
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        done <= 1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end

endmodule
"
"
    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define outputs
    reg done;
    
    // Define state register
    reg [1:0] state, next_state;
    
    // Define data register
    reg [7:0] data;
    reg [2:0] bit_count;
    
    // State transition logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
        end
    end
    
    // Output logic
    always @(state, in) begin
        done = 0;
        case (state)
            IDLE: begin
                if (in == 1) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            
            START_BIT: begin
                if (in == 0) begin
                    next_state = DATA_BITS;
                    bit_count <= 3'b0;
                end else begin
                    next_state = IDLE;
                end
            end
            
            DATA_BITS: begin
                if (bit_count < 8) begin
                    data[bit_count] = in;
                    bit_count <= bit_count + 1;
                    next_state = DATA_BITS;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            
            STOP_BIT: begin
                if (in == 1) begin
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end
endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);

    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define outputs
    reg done;
    
    // Define state register
    reg [1:0] state, next_state;
    
    // Define data register
    reg [7:0] data;
    reg [2:0] bit_count;
    
    // State transition logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
        end
    end
    
    // Output logic
    always @(state, in) begin
        done = 0;
        case (state)
            IDLE: begin
                if (in == 1) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            
            START_BIT: begin
                if (in == 0) begin
                    next_state = DATA_BITS;
                    bit_count <= 3'b0;
                end else begin
                    next_state = IDLE;
                end
            end
            
            DATA_BITS: begin
                if (bit_count < 8) begin
                    data[bit_count] = in;
                    bit_count <= bit_count + 1;
                    next_state = DATA_BITS;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            
            STOP_BIT: begin
                if (in == 1) begin
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);

    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define outputs
    reg done;
    
    // Define state register
    reg [1:0] state, next_state;
    
    // Define data register
    reg [7:0] data;
    reg [2:0] bit_count;
    
    // State transition logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
        end
    end
    
    // Output logic
    always @(state, in) begin
        done = 0;
        case (state)
            IDLE: begin
                if (in == 1) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            
            START_BIT: begin
                if (in == 0) begin
                    next_state = DATA_BITS;
                    bit_count <= 3'b0;
                end else begin
                    next_state = IDLE;
                end
            end
            
            DATA_BITS: begin
                if (bit_count < 8) begin
                    data[bit_count] = in;
                    bit_count <= bit_count + 1;
                    next_state = DATA_BITS;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            
            STOP_BIT: begin
                if (in == 1) begin
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end
endmodule
"
"    // State definitions
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Internal signals
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg done;
    
    // State machine
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data <= 8'b0;
            done <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    next_state = DATA_BITS;
                end
                DATA_BITS: begin
                    if (data == 8'b11111111) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        done = 1;
                        next_state = IDLE;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end
    
endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // State definitions
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Internal signals
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg done;
    
    // State machine
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data <= 8'b0;
            done <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    next_state = DATA_BITS;
                end
                DATA_BITS: begin
                    if (data == 8'b11111111) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        done = 1;
                        next_state = IDLE;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end
    
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // State definitions
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Internal signals
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg done;
    
    // State machine
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data <= 8'b0;
            done <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    next_state = DATA_BITS;
                end
                DATA_BITS: begin
                    if (data == 8'b11111111) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        done = 1;
                        next_state = IDLE;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end
    
endmodule
"
"    // State definitions
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Internal signals
    reg [1:0] state, next_state;
    reg [7:0] data_bits;
    reg done;
    
    // State transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_bits <= 8'b0;
            done <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                        data_bits <= 8'b0;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    next_state = DATA_BITS;
                    data_bits <= {data_bits[6:0], in};
                end
                DATA_BITS: begin
                    if (data_bits == 8'b11111111) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                        data_bits <= {data_bits[6:0], in};
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        next_state = IDLE;
                        done <= 1;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end
    
endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // State definitions
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Internal signals
    reg [1:0] state, next_state;
    reg [7:0] data_bits;
    reg done;
    
    // State transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_bits <= 8'b0;
            done <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                        data_bits <= 8'b0;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    next_state = DATA_BITS;
                    data_bits <= {data_bits[6:0], in};
                end
                DATA_BITS: begin
                    if (data_bits == 8'b11111111) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                        data_bits <= {data_bits[6:0], in};
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        next_state = IDLE;
                        done <= 1;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end
    
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // State definitions
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Internal signals
    reg [1:0] state, next_state;
    reg [7:0] data_bits;
    reg done;
    
    // State transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_bits <= 8'b0;
            done <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                        data_bits <= 8'b0;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    next_state = DATA_BITS;
                    data_bits <= {data_bits[6:0], in};
                end
                DATA_BITS: begin
                    if (data_bits == 8'b11111111) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                        data_bits <= {data_bits[6:0], in};
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        next_state = IDLE;
                        done <= 1;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end
    
endmodule
"
"    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define outputs
    reg done;
    
    // Define state register
    reg [1:0] state, next_state;
    
    // Define data counter
    reg [2:0] data_counter;
    
    // Define start and stop bit signals
    reg start_bit_detected;
    reg stop_bit_detected;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_counter <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            done <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1) begin
                    next_state = START_BIT;
                    start_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                end
            end
            START_BIT: begin
                if (data_counter < 8) begin
                    next_state = DATA_BITS;
                end else if (in == 1) begin
                    next_state = STOP_BIT;
                    stop_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                end
            end
            DATA_BITS: begin
                if (data_counter < 8) begin
                    next_state = DATA_BITS;
                    data_counter = data_counter + 1;
                end else begin
                    next_state = IDLE;
                end
            end
            STOP_BIT: begin
                if (in == 1) begin
                    next_state = IDLE;
                    done = 1;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end
endmodule
",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define outputs
    reg done;
    
    // Define state register
    reg [1:0] state, next_state;
    
    // Define data counter
    reg [2:0] data_counter;
    
    // Define start and stop bit signals
    reg start_bit_detected;
    reg stop_bit_detected;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_counter <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            done <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1) begin
                    next_state = START_BIT;
                    start_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                end
            end
            START_BIT: begin
                if (data_counter < 8) begin
                    next_state = DATA_BITS;
                end else if (in == 1) begin
                    next_state = STOP_BIT;
                    stop_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                end
            end
            DATA_BITS: begin
                if (data_counter < 8) begin
                    next_state = DATA_BITS;
                    data_counter = data_counter + 1;
                end else begin
                    next_state = IDLE;
                end
            end
            STOP_BIT: begin
                if (in == 1) begin
                    next_state = IDLE;
                    done = 1;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);
    // Define states
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;
    
    // Define outputs
    reg done;
    
    // Define state register
    reg [1:0] state, next_state;
    
    // Define data counter
    reg [2:0] data_counter;
    
    // Define start and stop bit signals
    reg start_bit_detected;
    reg stop_bit_detected;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_counter <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            done <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1) begin
                    next_state = START_BIT;
                    start_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                end
            end
            START_BIT: begin
                if (data_counter < 8) begin
                    next_state = DATA_BITS;
                end else if (in == 1) begin
                    next_state = STOP_BIT;
                    stop_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                end
            end
            DATA_BITS: begin
                if (data_counter < 8) begin
                    next_state = DATA_BITS;
                    data_counter = data_counter + 1;
                end else begin
                    next_state = IDLE;
                end
            end
            STOP_BIT: begin
                if (in == 1) begin
                    next_state = IDLE;
                    done = 1;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end
endmodule
"
"    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] shift_reg;
    logic [7:0] data_reg;
    logic start_bit_detected, stop_bit_detected;

    // Datapath to latch input bits
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            shift_reg <= 0;
            data_reg <= 0;
        end else begin
            shift_reg <= {shift_reg[1:0], in};
            case(state)
                IDLE:
                    if (shift_reg == 3'b010) begin
                        start_bit_detected <= 1;
                        next_state <= DATA_BITS;
                    end else begin
                        start_bit_detected <= 0;
                        next_state <= IDLE;
                    end
                START_BIT:
                    start_bit_detected <= 0;
                    next_state <= DATA_BITS;
                DATA_BITS:
                    if (shift_reg[0] == 1) begin
                        data_reg <= {shift_reg[2:1], data_reg[6:0]};
                    end
                    if (shift_reg == 3'b100) begin
                        stop_bit_detected <= 1;
                        next_state <= STOP_BIT;
                    end else begin
                        stop_bit_detected <= 0;
                        next_state <= DATA_BITS;
                    end
                STOP_BIT:
                    if (shift_reg == 3'b100) begin
                        stop_bit_detected <= 1;
                        next_state <= STOP_BIT;
                    end else begin
                        stop_bit_detected <= 0;
                        next_state <= IDLE;
                    end
            endcase
        end
    end

    // FSM to identify correctly received bytes
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Output the correctly received data byte
    assign out_byte = data_reg;
    assign done = (state == STOP_BIT && stop_bit_detected);

endmodule
",-1.0,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] shift_reg;
    logic [7:0] data_reg;
    logic start_bit_detected, stop_bit_detected;

    // Datapath to latch input bits
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            shift_reg <= 0;
            data_reg <= 0;
        end else begin
            shift_reg <= {shift_reg[1:0], in};
            case(state)
                IDLE:
                    if (shift_reg == 3'b010) begin
                        start_bit_detected <= 1;
                        next_state <= DATA_BITS;
                    end else begin
                        start_bit_detected <= 0;
                        next_state <= IDLE;
                    end
                START_BIT:
                    start_bit_detected <= 0;
                    next_state <= DATA_BITS;
                DATA_BITS:
                    if (shift_reg[0] == 1) begin
                        data_reg <= {shift_reg[2:1], data_reg[6:0]};
                    end
                    if (shift_reg == 3'b100) begin
                        stop_bit_detected <= 1;
                        next_state <= STOP_BIT;
                    end else begin
                        stop_bit_detected <= 0;
                        next_state <= DATA_BITS;
                    end
                STOP_BIT:
                    if (shift_reg == 3'b100) begin
                        stop_bit_detected <= 1;
                        next_state <= STOP_BIT;
                    end else begin
                        stop_bit_detected <= 0;
                        next_state <= IDLE;
                    end
            endcase
        end
    end

    // FSM to identify correctly received bytes
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Output the correctly received data byte
    assign out_byte = data_reg;
    assign done = (state == STOP_BIT && stop_bit_detected);

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] shift_reg;
    logic [7:0] data_reg;
    logic start_bit_detected, stop_bit_detected;

    // Datapath to latch input bits
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            shift_reg <= 0;
            data_reg <= 0;
        end else begin
            shift_reg <= {shift_reg[1:0], in};
            case(state)
                IDLE:
                    if (shift_reg == 3'b010) begin
                        start_bit_detected <= 1;
                        next_state <= DATA_BITS;
                    end else begin
                        start_bit_detected <= 0;
                        next_state <= IDLE;
                    end
                START_BIT:
                    start_bit_detected <= 0;
                    next_state <= DATA_BITS;
                DATA_BITS:
                    if (shift_reg[0] == 1) begin
                        data_reg <= {shift_reg[2:1], data_reg[6:0]};
                    end
                    if (shift_reg == 3'b100) begin
                        stop_bit_detected <= 1;
                        next_state <= STOP_BIT;
                    end else begin
                        stop_bit_detected <= 0;
                        next_state <= DATA_BITS;
                    end
                STOP_BIT:
                    if (shift_reg == 3'b100) begin
                        stop_bit_detected <= 1;
                        next_state <= STOP_BIT;
                    end else begin
                        stop_bit_detected <= 0;
                        next_state <= IDLE;
                    end
            endcase
        end
    end

    // FSM to identify correctly received bytes
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Output the correctly received data byte
    assign out_byte = data_reg;
    assign done = (state == STOP_BIT && stop_bit_detected);

endmodule
"
"    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] data_count;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;

    // Define datapath signals
    logic [7:0] shift_reg;
    logic [2:0] shift_count;
    logic [2:0] latch_count;
    logic [7:0] latched_byte;

    // FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data_count <= 0;
            data_byte <= 0;
            start_bit <= 0;
            stop_bit <= 0;
            shift_reg <= 0;
            shift_count <= 0;
            latch_count <= 0;
            latched_byte <= 0;
            out_byte <= 0;
            done <= 0;
        end else begin
            state <= next_state;
            case (state)
                IDLE: begin
                    if (in == 0) begin
                        next_state <= START_BIT;
                        data_count <= 0;
                        data_byte <= 0;
                        start_bit <= 1;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= 0;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    if (shift_count == 7 && in == 1) begin
                        next_state <= DATA_BITS;
                        shift_count <= 0;
                    end else begin
                        next_state <= START_BIT;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= shift_count + 1;
                    end
                end
                DATA_BITS: begin
                    if (shift_count == 7) begin
                        data_byte <= {shift_reg[7], data_byte[7:1]};
                        data_count <= data_count + 1;
                        if (data_count == 7) begin
                            next_state <= STOP_BIT;
                        end else begin
                            next_state <= DATA_BITS;
                        end
                        shift_count <= 0;
                    end else begin
                        next_state <= DATA_BITS;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= shift_count + 1;
                    end
                end
                STOP_BIT: begin
                    if (shift_count == 7 && in == 1) begin
                        stop_bit <= 1;
                        next_state <= IDLE;
                        done <= 1;
                        out_byte <= data_byte;
                    end else begin
                        next_state <= STOP_BIT;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= shift_count + 1;
                    end
                end
                default: begin
                    next_state <= IDLE;
                end
            endcase
        end
    end

    // Datapath for latching input bits
    always_comb begin
        case (latch_count)
            0: latched_byte[0] <= in;
            1: latched_byte[1] <= in;
            2: latched_byte[2] <= in;
            3: latched_byte[3] <= in;
            4: latched_byte[4] <= in;
            5: latched_byte[5] <= in;
            6: latched_byte[6] <= in;
            7: latched_byte[7] <= in;
            default: begin
                // Do nothing
            end
        endcase
    end

    // Update latch count
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            latch_count <= 0;
        end else begin
            if (state == START_BIT && shift_count == 7 && in == 1) begin
                latch_count <= 0;
            end else if (state == DATA_BITS && shift_count == 7) begin
                latch_count <= latch_count + 1;
            end else begin
                latch_count <= latch_count;
            end
        end
    end

endmodule
",-1.0,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] data_count;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;

    // Define datapath signals
    logic [7:0] shift_reg;
    logic [2:0] shift_count;
    logic [2:0] latch_count;
    logic [7:0] latched_byte;

    // FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data_count <= 0;
            data_byte <= 0;
            start_bit <= 0;
            stop_bit <= 0;
            shift_reg <= 0;
            shift_count <= 0;
            latch_count <= 0;
            latched_byte <= 0;
            out_byte <= 0;
            done <= 0;
        end else begin
            state <= next_state;
            case (state)
                IDLE: begin
                    if (in == 0) begin
                        next_state <= START_BIT;
                        data_count <= 0;
                        data_byte <= 0;
                        start_bit <= 1;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= 0;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    if (shift_count == 7 && in == 1) begin
                        next_state <= DATA_BITS;
                        shift_count <= 0;
                    end else begin
                        next_state <= START_BIT;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= shift_count + 1;
                    end
                end
                DATA_BITS: begin
                    if (shift_count == 7) begin
                        data_byte <= {shift_reg[7], data_byte[7:1]};
                        data_count <= data_count + 1;
                        if (data_count == 7) begin
                            next_state <= STOP_BIT;
                        end else begin
                            next_state <= DATA_BITS;
                        end
                        shift_count <= 0;
                    end else begin
                        next_state <= DATA_BITS;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= shift_count + 1;
                    end
                end
                STOP_BIT: begin
                    if (shift_count == 7 && in == 1) begin
                        stop_bit <= 1;
                        next_state <= IDLE;
                        done <= 1;
                        out_byte <= data_byte;
                    end else begin
                        next_state <= STOP_BIT;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= shift_count + 1;
                    end
                end
                default: begin
                    next_state <= IDLE;
                end
            endcase
        end
    end

    // Datapath for latching input bits
    always_comb begin
        case (latch_count)
            0: latched_byte[0] <= in;
            1: latched_byte[1] <= in;
            2: latched_byte[2] <= in;
            3: latched_byte[3] <= in;
            4: latched_byte[4] <= in;
            5: latched_byte[5] <= in;
            6: latched_byte[6] <= in;
            7: latched_byte[7] <= in;
            default: begin
                // Do nothing
            end
        endcase
    end

    // Update latch count
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            latch_count <= 0;
        end else begin
            if (state == START_BIT && shift_count == 7 && in == 1) begin
                latch_count <= 0;
            end else if (state == DATA_BITS && shift_count == 7) begin
                latch_count <= latch_count + 1;
            end else begin
                latch_count <= latch_count;
            end
        end
    end

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] data_count;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;

    // Define datapath signals
    logic [7:0] shift_reg;
    logic [2:0] shift_count;
    logic [2:0] latch_count;
    logic [7:0] latched_byte;

    // FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data_count <= 0;
            data_byte <= 0;
            start_bit <= 0;
            stop_bit <= 0;
            shift_reg <= 0;
            shift_count <= 0;
            latch_count <= 0;
            latched_byte <= 0;
            out_byte <= 0;
            done <= 0;
        end else begin
            state <= next_state;
            case (state)
                IDLE: begin
                    if (in == 0) begin
                        next_state <= START_BIT;
                        data_count <= 0;
                        data_byte <= 0;
                        start_bit <= 1;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= 0;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    if (shift_count == 7 && in == 1) begin
                        next_state <= DATA_BITS;
                        shift_count <= 0;
                    end else begin
                        next_state <= START_BIT;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= shift_count + 1;
                    end
                end
                DATA_BITS: begin
                    if (shift_count == 7) begin
                        data_byte <= {shift_reg[7], data_byte[7:1]};
                        data_count <= data_count + 1;
                        if (data_count == 7) begin
                            next_state <= STOP_BIT;
                        end else begin
                            next_state <= DATA_BITS;
                        end
                        shift_count <= 0;
                    end else begin
                        next_state <= DATA_BITS;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= shift_count + 1;
                    end
                end
                STOP_BIT: begin
                    if (shift_count == 7 && in == 1) begin
                        stop_bit <= 1;
                        next_state <= IDLE;
                        done <= 1;
                        out_byte <= data_byte;
                    end else begin
                        next_state <= STOP_BIT;
                        shift_reg <= {shift_reg[6:0], in};
                        shift_count <= shift_count + 1;
                    end
                end
                default: begin
                    next_state <= IDLE;
                end
            endcase
        end
    end

    // Datapath for latching input bits
    always_comb begin
        case (latch_count)
            0: latched_byte[0] <= in;
            1: latched_byte[1] <= in;
            2: latched_byte[2] <= in;
            3: latched_byte[3] <= in;
            4: latched_byte[4] <= in;
            5: latched_byte[5] <= in;
            6: latched_byte[6] <= in;
            7: latched_byte[7] <= in;
            default: begin
                // Do nothing
            end
        endcase
    end

    // Update latch count
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            latch_count <= 0;
        end else begin
            if (state == START_BIT && shift_count == 7 && in == 1) begin
                latch_count <= 0;
            end else if (state == DATA_BITS && shift_count == 7) begin
                latch_count <= latch_count + 1;
            end else begin
                latch_count <= latch_count;
            end
        end
    end

endmodule
"
"    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } fsm_state_t;
    
    // Define signals for the FSM
    fsm_state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_byte;
    
    // Define signals for datapath
    logic [7:0] shift_reg;
    logic [2:0] shift_counter;
    
    // Output signals
    assign out_byte = done ? data_byte : 8'b0;
    
    // FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            bit_counter <= 3'b0;
            data_byte <= 8'b0;
            shift_reg <= 8'b0;
            shift_counter <= 3'b0;
            done <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    // Datapath to latch input bits
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            shift_reg <= 8'b0;
            shift_counter <= 3'b0;
        end else begin
            if (state == IDLE || state == STOP_BIT) begin
                shift_reg <= {shift_reg[6:0], in};
                shift_counter <= 3'b0;
            end else if (state == START_BIT || state == DATA_BITS) begin
                shift_reg <= {shift_reg[6:0], in};
                shift_counter <= shift_counter + 1;
            end
        end
    end
    
    // Next state logic for FSM
    always_comb begin
        case(state)
            IDLE: begin
                if (shift_reg == 8'b0) begin
                    next_state = IDLE;
                end else if (shift_reg == 8'b1) begin
                    next_state = START_BIT;
                end
            end
            START_BIT: begin
                if (shift_counter == 3'b0) begin
                    next_state = DATA_BITS;
                end
            end
            DATA_BITS: begin
                if (shift_counter == 3'b0) begin
                    data_byte = shift_reg;
                    next_state = STOP_BIT;
                end
            end
            STOP_BIT: begin
                if (shift_reg == 8'b1) begin
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            default: next_state = IDLE;
        endcase
    end
endmodule
",-1.0,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } fsm_state_t;
    
    // Define signals for the FSM
    fsm_state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_byte;
    
    // Define signals for datapath
    logic [7:0] shift_reg;
    logic [2:0] shift_counter;
    
    // Output signals
    assign out_byte = done ? data_byte : 8'b0;
    
    // FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            bit_counter <= 3'b0;
            data_byte <= 8'b0;
            shift_reg <= 8'b0;
            shift_counter <= 3'b0;
            done <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    // Datapath to latch input bits
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            shift_reg <= 8'b0;
            shift_counter <= 3'b0;
        end else begin
            if (state == IDLE || state == STOP_BIT) begin
                shift_reg <= {shift_reg[6:0], in};
                shift_counter <= 3'b0;
            end else if (state == START_BIT || state == DATA_BITS) begin
                shift_reg <= {shift_reg[6:0], in};
                shift_counter <= shift_counter + 1;
            end
        end
    end
    
    // Next state logic for FSM
    always_comb begin
        case(state)
            IDLE: begin
                if (shift_reg == 8'b0) begin
                    next_state = IDLE;
                end else if (shift_reg == 8'b1) begin
                    next_state = START_BIT;
                end
            end
            START_BIT: begin
                if (shift_counter == 3'b0) begin
                    next_state = DATA_BITS;
                end
            end
            DATA_BITS: begin
                if (shift_counter == 3'b0) begin
                    data_byte = shift_reg;
                    next_state = STOP_BIT;
                end
            end
            STOP_BIT: begin
                if (shift_reg == 8'b1) begin
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            default: next_state = IDLE;
        endcase
    end
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } fsm_state_t;
    
    // Define signals for the FSM
    fsm_state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_byte;
    
    // Define signals for datapath
    logic [7:0] shift_reg;
    logic [2:0] shift_counter;
    
    // Output signals
    assign out_byte = done ? data_byte : 8'b0;
    
    // FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            bit_counter <= 3'b0;
            data_byte <= 8'b0;
            shift_reg <= 8'b0;
            shift_counter <= 3'b0;
            done <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    // Datapath to latch input bits
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            shift_reg <= 8'b0;
            shift_counter <= 3'b0;
        end else begin
            if (state == IDLE || state == STOP_BIT) begin
                shift_reg <= {shift_reg[6:0], in};
                shift_counter <= 3'b0;
            end else if (state == START_BIT || state == DATA_BITS) begin
                shift_reg <= {shift_reg[6:0], in};
                shift_counter <= shift_counter + 1;
            end
        end
    end
    
    // Next state logic for FSM
    always_comb begin
        case(state)
            IDLE: begin
                if (shift_reg == 8'b0) begin
                    next_state = IDLE;
                end else if (shift_reg == 8'b1) begin
                    next_state = START_BIT;
                end
            end
            START_BIT: begin
                if (shift_counter == 3'b0) begin
                    next_state = DATA_BITS;
                end
            end
            DATA_BITS: begin
                if (shift_counter == 3'b0) begin
                    data_byte = shift_reg;
                    next_state = STOP_BIT;
                end
            end
            STOP_BIT: begin
                if (shift_reg == 8'b1) begin
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
            default: next_state = IDLE;
        endcase
    end
endmodule
"
"    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;
    
    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;
    
    // Datapath to latch input bits
    always_ff @(posedge clk) begin
        if (reset) begin
            data_byte <= 8'b0;
            bit_counter <= 3'b0;
        end else begin
            case(state)
                START_BIT: begin
                    data_byte <= {data_byte[6:0], in};
                end
                DATA_BITS: begin
                    data_byte <= {data_byte[6:0], in};
                    bit_counter <= bit_counter + 1;
                end
                STOP_BIT: begin
                    stop_bit <= in;
                end
            endcase
        end
    end
    
    // FSM to identify correctly received bytes
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            start_bit <= 0;
            stop_bit <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 0) begin
                        next_state <= START_BIT;
                        start_bit <= 1;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    next_state <= DATA_BITS;
                end
                DATA_BITS: begin
                    if (bit_counter == 7) begin
                        next_state <= STOP_BIT;
                    end else begin
                        next_state <= DATA_BITS;
                    end
                end
                STOP_BIT: begin
                    if (stop_bit == 1) begin
                        done <= 1;
                        out_byte <= data_byte;
                        next_state <= IDLE;
                    end else begin
                        done <= 0;
                        next_state <= STOP_BIT;
                    end
                end
            endcase
        end
    end
endmodule
",-1.0,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;
    
    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;
    
    // Datapath to latch input bits
    always_ff @(posedge clk) begin
        if (reset) begin
            data_byte <= 8'b0;
            bit_counter <= 3'b0;
        end else begin
            case(state)
                START_BIT: begin
                    data_byte <= {data_byte[6:0], in};
                end
                DATA_BITS: begin
                    data_byte <= {data_byte[6:0], in};
                    bit_counter <= bit_counter + 1;
                end
                STOP_BIT: begin
                    stop_bit <= in;
                end
            endcase
        end
    end
    
    // FSM to identify correctly received bytes
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            start_bit <= 0;
            stop_bit <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 0) begin
                        next_state <= START_BIT;
                        start_bit <= 1;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    next_state <= DATA_BITS;
                end
                DATA_BITS: begin
                    if (bit_counter == 7) begin
                        next_state <= STOP_BIT;
                    end else begin
                        next_state <= DATA_BITS;
                    end
                end
                STOP_BIT: begin
                    if (stop_bit == 1) begin
                        done <= 1;
                        out_byte <= data_byte;
                        next_state <= IDLE;
                    end else begin
                        done <= 0;
                        next_state <= STOP_BIT;
                    end
                end
            endcase
        end
    end
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;
    
    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;
    
    // Datapath to latch input bits
    always_ff @(posedge clk) begin
        if (reset) begin
            data_byte <= 8'b0;
            bit_counter <= 3'b0;
        end else begin
            case(state)
                START_BIT: begin
                    data_byte <= {data_byte[6:0], in};
                end
                DATA_BITS: begin
                    data_byte <= {data_byte[6:0], in};
                    bit_counter <= bit_counter + 1;
                end
                STOP_BIT: begin
                    stop_bit <= in;
                end
            endcase
        end
    end
    
    // FSM to identify correctly received bytes
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            start_bit <= 0;
            stop_bit <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 0) begin
                        next_state <= START_BIT;
                        start_bit <= 1;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    next_state <= DATA_BITS;
                end
                DATA_BITS: begin
                    if (bit_counter == 7) begin
                        next_state <= STOP_BIT;
                    end else begin
                        next_state <= DATA_BITS;
                    end
                end
                STOP_BIT: begin
                    if (stop_bit == 1) begin
                        done <= 1;
                        out_byte <= data_byte;
                        next_state <= IDLE;
                    end else begin
                        done <= 0;
                        next_state <= STOP_BIT;
                    end
                end
            endcase
        end
    end
endmodule
"
"    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [3:0] data_bits;
    logic [2:0] bit_counter;
    logic start_bit, stop_bit;
    logic [7:0] shift_reg;
    logic [7:0] out_byte_reg;
    logic done_reg;
    
    // Define parameters for the FSM
    parameter START_BIT_VAL = 1'b0;
    parameter STOP_BIT_VAL = 1'b1;
    
    // Define datapath for receiving bits
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
            state <= IDLE;
            bit_counter <= 0;
        end else begin
            case(state)
                IDLE: begin
                    if (in == START_BIT_VAL) begin
                        shift_reg <= {shift_reg[6:0], in};
                        next_state <= START_BIT;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    shift_reg <= {shift_reg[6:0], in};
                    next_state <= DATA_BITS;
                end
                DATA_BITS: begin
                    if (bit_counter < 8) begin
                        data_bits[bit_counter] <= in;
                        bit_counter <= bit_counter + 1;
                        shift_reg <= {shift_reg[6:0], in};
                        next_state <= DATA_BITS;
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
                STOP_BIT: begin
                    stop_bit <= in;
                    if (stop_bit == STOP_BIT_VAL) begin
                        out_byte_reg <= data_bits;
                        done_reg <= 1'b1;
                    end else begin
                        done_reg <= 1'b0;
                    end
                    next_state <= IDLE;
                end
            endcase
        end
    end
    
    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule
",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [3:0] data_bits;
    logic [2:0] bit_counter;
    logic start_bit, stop_bit;
    logic [7:0] shift_reg;
    logic [7:0] out_byte_reg;
    logic done_reg;
    
    // Define parameters for the FSM
    parameter START_BIT_VAL = 1'b0;
    parameter STOP_BIT_VAL = 1'b1;
    
    // Define datapath for receiving bits
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
            state <= IDLE;
            bit_counter <= 0;
        end else begin
            case(state)
                IDLE: begin
                    if (in == START_BIT_VAL) begin
                        shift_reg <= {shift_reg[6:0], in};
                        next_state <= START_BIT;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    shift_reg <= {shift_reg[6:0], in};
                    next_state <= DATA_BITS;
                end
                DATA_BITS: begin
                    if (bit_counter < 8) begin
                        data_bits[bit_counter] <= in;
                        bit_counter <= bit_counter + 1;
                        shift_reg <= {shift_reg[6:0], in};
                        next_state <= DATA_BITS;
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
                STOP_BIT: begin
                    stop_bit <= in;
                    if (stop_bit == STOP_BIT_VAL) begin
                        out_byte_reg <= data_bits;
                        done_reg <= 1'b1;
                    end else begin
                        done_reg <= 1'b0;
                    end
                    next_state <= IDLE;
                end
            endcase
        end
    end
    
    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [3:0] data_bits;
    logic [2:0] bit_counter;
    logic start_bit, stop_bit;
    logic [7:0] shift_reg;
    logic [7:0] out_byte_reg;
    logic done_reg;
    
    // Define parameters for the FSM
    parameter START_BIT_VAL = 1'b0;
    parameter STOP_BIT_VAL = 1'b1;
    
    // Define datapath for receiving bits
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
            state <= IDLE;
            bit_counter <= 0;
        end else begin
            case(state)
                IDLE: begin
                    if (in == START_BIT_VAL) begin
                        shift_reg <= {shift_reg[6:0], in};
                        next_state <= START_BIT;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    shift_reg <= {shift_reg[6:0], in};
                    next_state <= DATA_BITS;
                end
                DATA_BITS: begin
                    if (bit_counter < 8) begin
                        data_bits[bit_counter] <= in;
                        bit_counter <= bit_counter + 1;
                        shift_reg <= {shift_reg[6:0], in};
                        next_state <= DATA_BITS;
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
                STOP_BIT: begin
                    stop_bit <= in;
                    if (stop_bit == STOP_BIT_VAL) begin
                        out_byte_reg <= data_bits;
                        done_reg <= 1'b1;
                    end else begin
                        done_reg <= 1'b0;
                    end
                    next_state <= IDLE;
                end
            endcase
        end
    end
    
    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule
"
"    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] shift_reg;
    logic [2:0] data_reg;
    logic start_bit_detected;
    logic [2:0] out_byte_reg;
    logic done_reg;

    // Define parameters for the FSM
    parameter START_BIT_VAL = 3'b000;
    parameter STOP_BIT_VAL = 3'b111;

    // FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 3'b000;
            data_reg <= 3'b000;
            start_bit_detected <= 1'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    if (shift_reg == START_BIT_VAL) begin
                        start_bit_detected <= 1'b1;
                        next_state = DATA_BITS;
                    end else begin
                        next_state = START_BIT;
                    end
                end
                DATA_BITS: begin
                    if (shift_reg == STOP_BIT_VAL) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                    end
                end
                STOP_BIT: begin
                    if (shift_reg == STOP_BIT_VAL) begin
                        done_reg <= 1'b1;
                        out_byte_reg <= data_reg;
                        next_state = IDLE;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end

    // Datapath
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            shift_reg <= 3'b000;
            data_reg <= 3'b000;
        end else begin
            shift_reg <= {shift_reg[1:0], in};
            if (start_bit_detected) begin
                data_reg <= {data_reg[1:0], in};
            end
        end
    end

    // Output signals
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule
",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] shift_reg;
    logic [2:0] data_reg;
    logic start_bit_detected;
    logic [2:0] out_byte_reg;
    logic done_reg;

    // Define parameters for the FSM
    parameter START_BIT_VAL = 3'b000;
    parameter STOP_BIT_VAL = 3'b111;

    // FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 3'b000;
            data_reg <= 3'b000;
            start_bit_detected <= 1'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    if (shift_reg == START_BIT_VAL) begin
                        start_bit_detected <= 1'b1;
                        next_state = DATA_BITS;
                    end else begin
                        next_state = START_BIT;
                    end
                end
                DATA_BITS: begin
                    if (shift_reg == STOP_BIT_VAL) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                    end
                end
                STOP_BIT: begin
                    if (shift_reg == STOP_BIT_VAL) begin
                        done_reg <= 1'b1;
                        out_byte_reg <= data_reg;
                        next_state = IDLE;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end

    // Datapath
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            shift_reg <= 3'b000;
            data_reg <= 3'b000;
        end else begin
            shift_reg <= {shift_reg[1:0], in};
            if (start_bit_detected) begin
                data_reg <= {data_reg[1:0], in};
            end
        end
    end

    // Output signals
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] shift_reg;
    logic [2:0] data_reg;
    logic start_bit_detected;
    logic [2:0] out_byte_reg;
    logic done_reg;

    // Define parameters for the FSM
    parameter START_BIT_VAL = 3'b000;
    parameter STOP_BIT_VAL = 3'b111;

    // FSM
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 3'b000;
            data_reg <= 3'b000;
            start_bit_detected <= 1'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state = START_BIT;
                    end else begin
                        next_state = IDLE;
                    end
                end
                START_BIT: begin
                    if (shift_reg == START_BIT_VAL) begin
                        start_bit_detected <= 1'b1;
                        next_state = DATA_BITS;
                    end else begin
                        next_state = START_BIT;
                    end
                end
                DATA_BITS: begin
                    if (shift_reg == STOP_BIT_VAL) begin
                        next_state = STOP_BIT;
                    end else begin
                        next_state = DATA_BITS;
                    end
                end
                STOP_BIT: begin
                    if (shift_reg == STOP_BIT_VAL) begin
                        done_reg <= 1'b1;
                        out_byte_reg <= data_reg;
                        next_state = IDLE;
                    end else begin
                        next_state = STOP_BIT;
                    end
                end
            endcase
        end
    end

    // Datapath
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            shift_reg <= 3'b000;
            data_reg <= 3'b000;
        end else begin
            shift_reg <= {shift_reg[1:0], in};
            if (start_bit_detected) begin
                data_reg <= {data_reg[1:0], in};
            end
        end
    end

    // Output signals
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule
"
"    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;

    // Datapath to latch input bits
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            data_byte <= 8'b0;
        end else begin
            data_byte <= {data_byte[6:0], in};
        end
    end

    // FSM to identify correctly received bytes
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
            start_bit <= 1'b0;
            stop_bit <= 1'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state <= START_BIT;
                        start_bit <= 1'b1;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    next_state <= DATA_BITS;
                    start_bit <= 1'b0;
                end
                DATA_BITS: begin
                    if (bit_count == 3'b111) begin
                        next_state <= STOP_BIT;
                    end else begin
                        next_state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        next_state <= IDLE;
                        stop_bit <= 1'b1;
                        out_byte <= data_byte;
                        done <= 1'b1;
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
            endcase
        end
    end

endmodule
",-1.0,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;

    // Datapath to latch input bits
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            data_byte <= 8'b0;
        end else begin
            data_byte <= {data_byte[6:0], in};
        end
    end

    // FSM to identify correctly received bytes
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
            start_bit <= 1'b0;
            stop_bit <= 1'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state <= START_BIT;
                        start_bit <= 1'b1;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    next_state <= DATA_BITS;
                    start_bit <= 1'b0;
                end
                DATA_BITS: begin
                    if (bit_count == 3'b111) begin
                        next_state <= STOP_BIT;
                    end else begin
                        next_state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        next_state <= IDLE;
                        stop_bit <= 1'b1;
                        out_byte <= data_byte;
                        done <= 1'b1;
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;

    // Datapath to latch input bits
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            data_byte <= 8'b0;
        end else begin
            data_byte <= {data_byte[6:0], in};
        end
    end

    // FSM to identify correctly received bytes
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
            start_bit <= 1'b0;
            stop_bit <= 1'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == 1'b0) begin
                        next_state <= START_BIT;
                        start_bit <= 1'b1;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    next_state <= DATA_BITS;
                    start_bit <= 1'b0;
                end
                DATA_BITS: begin
                    if (bit_count == 3'b111) begin
                        next_state <= STOP_BIT;
                    end else begin
                        next_state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                    end
                end
                STOP_BIT: begin
                    if (in == 1'b1) begin
                        next_state <= IDLE;
                        stop_bit <= 1'b1;
                        out_byte <= data_byte;
                        done <= 1'b1;
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
            endcase
        end
    end

endmodule
"
"    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;
    logic [7:0] out_byte_reg;
    logic done_reg;

    // Define parameters for the FSM
    parameter START_BIT_VAL = 1'b0;
    parameter STOP_BIT_VAL = 1'b1;

    // Define datapath logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 8'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == START_BIT_VAL) begin
                        next_state <= START_BIT;
                        bit_count <= 1;
                        shift_reg <= {shift_reg[6:0], in};
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        next_state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                        shift_reg <= {shift_reg[6:0], in};
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        next_state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                        shift_reg <= {shift_reg[6:0], in};
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
                STOP_BIT: begin
                    if (in == STOP_BIT_VAL) begin
                        next_state <= IDLE;
                        out_byte_reg <= shift_reg;
                        done_reg <= 1;
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
            endcase
        end
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule
",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;
    logic [7:0] out_byte_reg;
    logic done_reg;

    // Define parameters for the FSM
    parameter START_BIT_VAL = 1'b0;
    parameter STOP_BIT_VAL = 1'b1;

    // Define datapath logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 8'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == START_BIT_VAL) begin
                        next_state <= START_BIT;
                        bit_count <= 1;
                        shift_reg <= {shift_reg[6:0], in};
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        next_state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                        shift_reg <= {shift_reg[6:0], in};
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        next_state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                        shift_reg <= {shift_reg[6:0], in};
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
                STOP_BIT: begin
                    if (in == STOP_BIT_VAL) begin
                        next_state <= IDLE;
                        out_byte_reg <= shift_reg;
                        done_reg <= 1;
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
            endcase
        end
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;
    logic [7:0] out_byte_reg;
    logic done_reg;

    // Define parameters for the FSM
    parameter START_BIT_VAL = 1'b0;
    parameter STOP_BIT_VAL = 1'b1;

    // Define datapath logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 8'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 0;
        end else begin
            state <= next_state;
            case(state)
                IDLE: begin
                    if (in == START_BIT_VAL) begin
                        next_state <= START_BIT;
                        bit_count <= 1;
                        shift_reg <= {shift_reg[6:0], in};
                    end else begin
                        next_state <= IDLE;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        next_state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                        shift_reg <= {shift_reg[6:0], in};
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        next_state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                        shift_reg <= {shift_reg[6:0], in};
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
                STOP_BIT: begin
                    if (in == STOP_BIT_VAL) begin
                        next_state <= IDLE;
                        out_byte_reg <= shift_reg;
                        done_reg <= 1;
                    end else begin
                        next_state <= STOP_BIT;
                    end
                end
            endcase
        end
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule
"
"    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;

    // Define states for the datapath
    parameter SHIFT_IN = 3'b000;
    parameter LATCH_BYTE = 3'b001;

    // Define variables for FSM
    reg [1:0] state;
    reg [2:0] datapath_state;
    reg [7:0] data_byte;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;

    // Output signals
    assign out_byte = done ? data_byte : 8'bzzzzzzzz;
    assign done = (state == STOP_BIT);

    // FSM
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            datapath_state <= SHIFT_IN;
            data_byte <= 8'b0;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (in == 1) begin
                        state <= START_BIT;
                        datapath_state <= SHIFT_IN;
                        bit_count <= 0;
                        start_bit_detected <= 1;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= STOP_BIT;
                        bit_count <= 0;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= STOP_BIT;
                        bit_count <= 0;
                    end
                end
                STOP_BIT: begin
                    if (in == 0) begin
                        stop_bit_detected <= 1;
                    end
                    if (stop_bit_detected) begin
                        state <= IDLE;
                        datapath_state <= LATCH_BYTE;
                    end
                end
            endcase
        end
    end

    // Datapath
    always @(posedge clk) begin
        if (reset) begin
            data_byte <= 8'b0;
        end else begin
            case (datapath_state)
                SHIFT_IN: begin
                    data_byte <= {data_byte[6:0], in};
                end
                LATCH_BYTE: begin
                    data_byte <= data_byte;
                end
            endcase
        end
    end

endmodule
",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;

    // Define states for the datapath
    parameter SHIFT_IN = 3'b000;
    parameter LATCH_BYTE = 3'b001;

    // Define variables for FSM
    reg [1:0] state;
    reg [2:0] datapath_state;
    reg [7:0] data_byte;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;

    // Output signals
    assign out_byte = done ? data_byte : 8'bzzzzzzzz;
    assign done = (state == STOP_BIT);

    // FSM
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            datapath_state <= SHIFT_IN;
            data_byte <= 8'b0;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (in == 1) begin
                        state <= START_BIT;
                        datapath_state <= SHIFT_IN;
                        bit_count <= 0;
                        start_bit_detected <= 1;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= STOP_BIT;
                        bit_count <= 0;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= STOP_BIT;
                        bit_count <= 0;
                    end
                end
                STOP_BIT: begin
                    if (in == 0) begin
                        stop_bit_detected <= 1;
                    end
                    if (stop_bit_detected) begin
                        state <= IDLE;
                        datapath_state <= LATCH_BYTE;
                    end
                end
            endcase
        end
    end

    // Datapath
    always @(posedge clk) begin
        if (reset) begin
            data_byte <= 8'b0;
        end else begin
            case (datapath_state)
                SHIFT_IN: begin
                    data_byte <= {data_byte[6:0], in};
                end
                LATCH_BYTE: begin
                    data_byte <= data_byte;
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter STOP_BIT = 2'b11;

    // Define states for the datapath
    parameter SHIFT_IN = 3'b000;
    parameter LATCH_BYTE = 3'b001;

    // Define variables for FSM
    reg [1:0] state;
    reg [2:0] datapath_state;
    reg [7:0] data_byte;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;

    // Output signals
    assign out_byte = done ? data_byte : 8'bzzzzzzzz;
    assign done = (state == STOP_BIT);

    // FSM
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            datapath_state <= SHIFT_IN;
            data_byte <= 8'b0;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (in == 1) begin
                        state <= START_BIT;
                        datapath_state <= SHIFT_IN;
                        bit_count <= 0;
                        start_bit_detected <= 1;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= STOP_BIT;
                        bit_count <= 0;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        state <= DATA_BITS;
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= STOP_BIT;
                        bit_count <= 0;
                    end
                end
                STOP_BIT: begin
                    if (in == 0) begin
                        stop_bit_detected <= 1;
                    end
                    if (stop_bit_detected) begin
                        state <= IDLE;
                        datapath_state <= LATCH_BYTE;
                    end
                end
            endcase
        end
    end

    // Datapath
    always @(posedge clk) begin
        if (reset) begin
            data_byte <= 8'b0;
        end else begin
            case (datapath_state)
                SHIFT_IN: begin
                    data_byte <= {data_byte[6:0], in};
                end
                LATCH_BYTE: begin
                    data_byte <= data_byte;
                end
            endcase
        end
    end

endmodule
"
"    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;
    
    // Datapath to latch input bits
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            data_byte <= 8'b0;
            bit_counter <= 3'b0;
            start_bit <= 1'b0;
            stop_bit <= 1'b0;
        end else begin
            case(state)
                START_BIT: begin
                    start_bit <= in;
                end
                DATA_BITS: begin
                    data_byte[bit_counter] <= in;
                    bit_counter <= bit_counter + 1;
                end
                STOP_BIT: begin
                    stop_bit <= in;
                end
            endcase
        end
    end

    // FSM to identify correctly received bytes
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        done = 0;
        out_byte = 8'b0;
        
        case(state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            START_BIT: begin
                if (bit_counter == 3'b0 && start_bit == 1'b0) begin
                    next_state = DATA_BITS;
                end else begin
                    next_state = START_BIT;
                end
            end
            DATA_BITS: begin
                if (bit_counter == 3'b111) begin
                    next_state = STOP_BIT;
                end else begin
                    next_state = DATA_BITS;
                end
            end
            STOP_BIT: begin
                if (stop_bit == 1'b1) begin
                    out_byte = data_byte;
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end

endmodule
",-1.0,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;
    
    // Datapath to latch input bits
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            data_byte <= 8'b0;
            bit_counter <= 3'b0;
            start_bit <= 1'b0;
            stop_bit <= 1'b0;
        end else begin
            case(state)
                START_BIT: begin
                    start_bit <= in;
                end
                DATA_BITS: begin
                    data_byte[bit_counter] <= in;
                    bit_counter <= bit_counter + 1;
                end
                STOP_BIT: begin
                    stop_bit <= in;
                end
            endcase
        end
    end

    // FSM to identify correctly received bytes
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        done = 0;
        out_byte = 8'b0;
        
        case(state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            START_BIT: begin
                if (bit_counter == 3'b0 && start_bit == 1'b0) begin
                    next_state = DATA_BITS;
                end else begin
                    next_state = START_BIT;
                end
            end
            DATA_BITS: begin
                if (bit_counter == 3'b111) begin
                    next_state = STOP_BIT;
                end else begin
                    next_state = DATA_BITS;
                end
            end
            STOP_BIT: begin
                if (stop_bit == 1'b1) begin
                    out_byte = data_byte;
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;

    // Define signals for the FSM
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_byte;
    logic start_bit, stop_bit;
    
    // Datapath to latch input bits
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            data_byte <= 8'b0;
            bit_counter <= 3'b0;
            start_bit <= 1'b0;
            stop_bit <= 1'b0;
        end else begin
            case(state)
                START_BIT: begin
                    start_bit <= in;
                end
                DATA_BITS: begin
                    data_byte[bit_counter] <= in;
                    bit_counter <= bit_counter + 1;
                end
                STOP_BIT: begin
                    stop_bit <= in;
                end
            endcase
        end
    end

    // FSM to identify correctly received bytes
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        done = 0;
        out_byte = 8'b0;
        
        case(state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START_BIT;
                end else begin
                    next_state = IDLE;
                end
            end
            START_BIT: begin
                if (bit_counter == 3'b0 && start_bit == 1'b0) begin
                    next_state = DATA_BITS;
                end else begin
                    next_state = START_BIT;
                end
            end
            DATA_BITS: begin
                if (bit_counter == 3'b111) begin
                    next_state = STOP_BIT;
                end else begin
                    next_state = DATA_BITS;
                end
            end
            STOP_BIT: begin
                if (stop_bit == 1'b1) begin
                    out_byte = data_byte;
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP_BIT;
                end
            end
        endcase
    end

endmodule
"
"    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter PARITY_BIT = 2'b11;
    parameter STOP_BIT = 2'b100;
    
    // Define signals for the FSM
    reg [1:0] state, next_state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected, stop_bit_detected;
    reg odd_parity;
    
    // Instantiate the parity module
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // Output signals
    assign out_byte = data_reg;
    assign done = (state == STOP_BIT && stop_bit_detected);
    
    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data_reg <= 8'b0;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            odd_parity <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case (state)
            IDLE: begin
                if (in == 0) begin
                    next_state = START_BIT;
                    start_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                    start_bit_detected = 0;
                end
            end
            START_BIT: begin
                next_state = DATA_BITS;
                bit_count = 0;
            end
            DATA_BITS: begin
                if (bit_count < 8) begin
                    data_reg[bit_count] = in;
                    bit_count = bit_count + 1;
                    next_state = DATA_BITS;
                end else begin
                    next_state = PARITY_BIT;
                end
            end
            PARITY_BIT: begin
                next_state = STOP_BIT;
                if (odd_parity == 1) begin
                    // Parity check passed
                    stop_bit_detected = (in == 1);
                end else begin
                    // Parity check failed
                    stop_bit_detected = 0;
                end
            end
            STOP_BIT: begin
                next_state = IDLE;
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end
endmodule
",-1.0,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter PARITY_BIT = 2'b11;
    parameter STOP_BIT = 2'b100;
    
    // Define signals for the FSM
    reg [1:0] state, next_state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected, stop_bit_detected;
    reg odd_parity;
    
    // Instantiate the parity module
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // Output signals
    assign out_byte = data_reg;
    assign done = (state == STOP_BIT && stop_bit_detected);
    
    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data_reg <= 8'b0;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            odd_parity <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case (state)
            IDLE: begin
                if (in == 0) begin
                    next_state = START_BIT;
                    start_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                    start_bit_detected = 0;
                end
            end
            START_BIT: begin
                next_state = DATA_BITS;
                bit_count = 0;
            end
            DATA_BITS: begin
                if (bit_count < 8) begin
                    data_reg[bit_count] = in;
                    bit_count = bit_count + 1;
                    next_state = DATA_BITS;
                end else begin
                    next_state = PARITY_BIT;
                end
            end
            PARITY_BIT: begin
                next_state = STOP_BIT;
                if (odd_parity == 1) begin
                    // Parity check passed
                    stop_bit_detected = (in == 1);
                end else begin
                    // Parity check failed
                    stop_bit_detected = 0;
                end
            end
            STOP_BIT: begin
                next_state = IDLE;
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter PARITY_BIT = 2'b11;
    parameter STOP_BIT = 2'b100;
    
    // Define signals for the FSM
    reg [1:0] state, next_state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected, stop_bit_detected;
    reg odd_parity;
    
    // Instantiate the parity module
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // Output signals
    assign out_byte = data_reg;
    assign done = (state == STOP_BIT && stop_bit_detected);
    
    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data_reg <= 8'b0;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            odd_parity <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case (state)
            IDLE: begin
                if (in == 0) begin
                    next_state = START_BIT;
                    start_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                    start_bit_detected = 0;
                end
            end
            START_BIT: begin
                next_state = DATA_BITS;
                bit_count = 0;
            end
            DATA_BITS: begin
                if (bit_count < 8) begin
                    data_reg[bit_count] = in;
                    bit_count = bit_count + 1;
                    next_state = DATA_BITS;
                end else begin
                    next_state = PARITY_BIT;
                end
            end
            PARITY_BIT: begin
                next_state = STOP_BIT;
                if (odd_parity == 1) begin
                    // Parity check passed
                    stop_bit_detected = (in == 1);
                end else begin
                    // Parity check failed
                    stop_bit_detected = 0;
                end
            end
            STOP_BIT: begin
                next_state = IDLE;
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end
endmodule
"
"    // Define states for the FSM
    parameter IDLE = 2'd0;
    parameter START_BIT = 2'd1;
    parameter DATA_BITS = 2'd2;
    parameter PARITY_BIT = 2'd3;
    parameter STOP_BIT = 2'd4;
    
    // Define signals for the FSM
    reg [1:0] state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;
    reg parity_check_passed;
    reg [8:0] parity_count;
    reg done;
    
    // Instantiate the parity module
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_check_passed)
    );
    
    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            parity_check_passed <= 0;
            parity_count <= 0;
            done <= 0;
        end
        else begin
            case (state)
                IDLE: begin
                    if (in == 0) begin
                        state <= START_BIT;
                        start_bit_detected <= 1;
                        bit_count <= 0;
                        data_reg <= 0;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        state <= DATA_BITS;
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end
                    else begin
                        state <= PARITY_BIT;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end
                    else begin
                        state <= PARITY_BIT;
                    end
                end
                PARITY_BIT: begin
                    if (bit_count < 8) begin
                        parity_count <= {parity_count[6:0], in};
                        bit_count <= bit_count + 1;
                    end
                    else begin
                        if (parity_check_passed && (parity_count[8] == 1)) begin
                            state <= STOP_BIT;
                        end
                        else begin
                            state <= IDLE;
                        end
                    end
                end
                STOP_BIT: begin
                    if (in == 1) begin
                        stop_bit_detected <= 1;
                        done <= 1;
                        state <= IDLE;
                    end
                    else begin
                        state <= IDLE;
                    end
                end
                default: state <= IDLE;
            endcase
        end
    end
    
    // Assign output signals
    assign out_byte = data_reg;
    assign done = done;
endmodule
",-1.0,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'd0;
    parameter START_BIT = 2'd1;
    parameter DATA_BITS = 2'd2;
    parameter PARITY_BIT = 2'd3;
    parameter STOP_BIT = 2'd4;
    
    // Define signals for the FSM
    reg [1:0] state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;
    reg parity_check_passed;
    reg [8:0] parity_count;
    reg done;
    
    // Instantiate the parity module
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_check_passed)
    );
    
    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            parity_check_passed <= 0;
            parity_count <= 0;
            done <= 0;
        end
        else begin
            case (state)
                IDLE: begin
                    if (in == 0) begin
                        state <= START_BIT;
                        start_bit_detected <= 1;
                        bit_count <= 0;
                        data_reg <= 0;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        state <= DATA_BITS;
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end
                    else begin
                        state <= PARITY_BIT;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end
                    else begin
                        state <= PARITY_BIT;
                    end
                end
                PARITY_BIT: begin
                    if (bit_count < 8) begin
                        parity_count <= {parity_count[6:0], in};
                        bit_count <= bit_count + 1;
                    end
                    else begin
                        if (parity_check_passed && (parity_count[8] == 1)) begin
                            state <= STOP_BIT;
                        end
                        else begin
                            state <= IDLE;
                        end
                    end
                end
                STOP_BIT: begin
                    if (in == 1) begin
                        stop_bit_detected <= 1;
                        done <= 1;
                        state <= IDLE;
                    end
                    else begin
                        state <= IDLE;
                    end
                end
                default: state <= IDLE;
            endcase
        end
    end
    
    // Assign output signals
    assign out_byte = data_reg;
    assign done = done;
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'd0;
    parameter START_BIT = 2'd1;
    parameter DATA_BITS = 2'd2;
    parameter PARITY_BIT = 2'd3;
    parameter STOP_BIT = 2'd4;
    
    // Define signals for the FSM
    reg [1:0] state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;
    reg parity_check_passed;
    reg [8:0] parity_count;
    reg done;
    
    // Instantiate the parity module
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_check_passed)
    );
    
    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            parity_check_passed <= 0;
            parity_count <= 0;
            done <= 0;
        end
        else begin
            case (state)
                IDLE: begin
                    if (in == 0) begin
                        state <= START_BIT;
                        start_bit_detected <= 1;
                        bit_count <= 0;
                        data_reg <= 0;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        state <= DATA_BITS;
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end
                    else begin
                        state <= PARITY_BIT;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end
                    else begin
                        state <= PARITY_BIT;
                    end
                end
                PARITY_BIT: begin
                    if (bit_count < 8) begin
                        parity_count <= {parity_count[6:0], in};
                        bit_count <= bit_count + 1;
                    end
                    else begin
                        if (parity_check_passed && (parity_count[8] == 1)) begin
                            state <= STOP_BIT;
                        end
                        else begin
                            state <= IDLE;
                        end
                    end
                end
                STOP_BIT: begin
                    if (in == 1) begin
                        stop_bit_detected <= 1;
                        done <= 1;
                        state <= IDLE;
                    end
                    else begin
                        state <= IDLE;
                    end
                end
                default: state <= IDLE;
            endcase
        end
    end
    
    // Assign output signals
    assign out_byte = data_reg;
    assign done = done;
endmodule
"
"    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter PARITY_BIT = 2'b11;
    parameter STOP_BIT = 2'b100;

    // Define signals for the FSM
    reg [1:0] state, next_state;
    reg [7:0] data_byte;
    reg [2:0] bit_count;
    reg start_bit_detected, stop_bit_detected;
    reg parity_check_passed;
    reg odd_parity;
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data_byte <= 8'b0;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            parity_check_passed <= 0;
        end else begin
            state <= next_state;
        end
    end

    // State transition and data processing logic
    always @* begin
        case (state)
            IDLE: begin
                if (in == 0) begin
                    next_state = START_BIT;
                    start_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                    start_bit_detected = 0;
                end
            end
            START_BIT: begin
                next_state = DATA_BITS;
            end
            DATA_BITS: begin
                if (bit_count < 8) begin
                    data_byte[bit_count] = in;
                    bit_count = bit_count + 1;
                    next_state = DATA_BITS;
                end else begin
                    next_state = PARITY_BIT;
                end
            end
            PARITY_BIT: begin
                odd_parity = in;
                next_state = STOP_BIT;
            end
            STOP_BIT: begin
                if (in == 1) begin
                    stop_bit_detected = 1;
                    if (odd_parity == 1) begin
                        parity_check_passed = 1;
                    end else begin
                        parity_check_passed = 0;
                    end
                end else begin
                    stop_bit_detected = 0;
                    parity_check_passed = 0;
                end
                
                if (stop_bit_detected && parity_check_passed) begin
                    out_byte = data_byte;
                    done = 1;
                end else begin
                    out_byte = 8'b0;
                    done = 0;
                end
                
                next_state = IDLE;
            end
        endcase
    end
endmodule
",-1.0,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter PARITY_BIT = 2'b11;
    parameter STOP_BIT = 2'b100;

    // Define signals for the FSM
    reg [1:0] state, next_state;
    reg [7:0] data_byte;
    reg [2:0] bit_count;
    reg start_bit_detected, stop_bit_detected;
    reg parity_check_passed;
    reg odd_parity;
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data_byte <= 8'b0;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            parity_check_passed <= 0;
        end else begin
            state <= next_state;
        end
    end

    // State transition and data processing logic
    always @* begin
        case (state)
            IDLE: begin
                if (in == 0) begin
                    next_state = START_BIT;
                    start_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                    start_bit_detected = 0;
                end
            end
            START_BIT: begin
                next_state = DATA_BITS;
            end
            DATA_BITS: begin
                if (bit_count < 8) begin
                    data_byte[bit_count] = in;
                    bit_count = bit_count + 1;
                    next_state = DATA_BITS;
                end else begin
                    next_state = PARITY_BIT;
                end
            end
            PARITY_BIT: begin
                odd_parity = in;
                next_state = STOP_BIT;
            end
            STOP_BIT: begin
                if (in == 1) begin
                    stop_bit_detected = 1;
                    if (odd_parity == 1) begin
                        parity_check_passed = 1;
                    end else begin
                        parity_check_passed = 0;
                    end
                end else begin
                    stop_bit_detected = 0;
                    parity_check_passed = 0;
                end
                
                if (stop_bit_detected && parity_check_passed) begin
                    out_byte = data_byte;
                    done = 1;
                end else begin
                    out_byte = 8'b0;
                    done = 0;
                end
                
                next_state = IDLE;
            end
        endcase
    end
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter PARITY_BIT = 2'b11;
    parameter STOP_BIT = 2'b100;

    // Define signals for the FSM
    reg [1:0] state, next_state;
    reg [7:0] data_byte;
    reg [2:0] bit_count;
    reg start_bit_detected, stop_bit_detected;
    reg parity_check_passed;
    reg odd_parity;
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            next_state <= IDLE;
            data_byte <= 8'b0;
            bit_count <= 0;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            parity_check_passed <= 0;
        end else begin
            state <= next_state;
        end
    end

    // State transition and data processing logic
    always @* begin
        case (state)
            IDLE: begin
                if (in == 0) begin
                    next_state = START_BIT;
                    start_bit_detected = 1;
                end else begin
                    next_state = IDLE;
                    start_bit_detected = 0;
                end
            end
            START_BIT: begin
                next_state = DATA_BITS;
            end
            DATA_BITS: begin
                if (bit_count < 8) begin
                    data_byte[bit_count] = in;
                    bit_count = bit_count + 1;
                    next_state = DATA_BITS;
                end else begin
                    next_state = PARITY_BIT;
                end
            end
            PARITY_BIT: begin
                odd_parity = in;
                next_state = STOP_BIT;
            end
            STOP_BIT: begin
                if (in == 1) begin
                    stop_bit_detected = 1;
                    if (odd_parity == 1) begin
                        parity_check_passed = 1;
                    end else begin
                        parity_check_passed = 0;
                    end
                end else begin
                    stop_bit_detected = 0;
                    parity_check_passed = 0;
                end
                
                if (stop_bit_detected && parity_check_passed) begin
                    out_byte = data_byte;
                    done = 1;
                end else begin
                    out_byte = 8'b0;
                    done = 0;
                end
                
                next_state = IDLE;
            end
        endcase
    end
endmodule
"
"    reg [2:0] state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;
    reg parity_check;

    wire odd_parity;
    parity parity_checking(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_reg <= 8'b0;
            bit_count <= 3'b000;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            parity_check <= 0;
            done <= 0;
        end else begin
            case (state)
                3'b000: begin // Idle state
                    if (in == 0) begin
                        state <= 3'b001; // Start bit detected
                        start_bit_detected <= 1;
                    end
                end
                3'b001: begin // Data receiving state
                    data_reg <= {data_reg[6:0], in};
                    bit_count <= bit_count + 1;
                    if (bit_count == 3'b100) begin
                        state <= 3'b010; // Parity bit received
                    end
                end
                3'b010: begin // Parity checking state
                    parity_check <= odd_parity;
                    state <= 3'b011; // Stop bit expected
                end
                3'b011: begin // Stop bit checking state
                    if (in == 1) begin
                        stop_bit_detected <= 1;
                        if (parity_check && start_bit_detected) begin
                            out_byte <= data_reg;
                            done <= 1;
                        end
                    end
                    state <= 3'b000; // Go back to idle state
                end
            endcase
        end
    end

endmodule
",-1.0,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    reg [2:0] state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;
    reg parity_check;

    wire odd_parity;
    parity parity_checking(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_reg <= 8'b0;
            bit_count <= 3'b000;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            parity_check <= 0;
            done <= 0;
        end else begin
            case (state)
                3'b000: begin // Idle state
                    if (in == 0) begin
                        state <= 3'b001; // Start bit detected
                        start_bit_detected <= 1;
                    end
                end
                3'b001: begin // Data receiving state
                    data_reg <= {data_reg[6:0], in};
                    bit_count <= bit_count + 1;
                    if (bit_count == 3'b100) begin
                        state <= 3'b010; // Parity bit received
                    end
                end
                3'b010: begin // Parity checking state
                    parity_check <= odd_parity;
                    state <= 3'b011; // Stop bit expected
                end
                3'b011: begin // Stop bit checking state
                    if (in == 1) begin
                        stop_bit_detected <= 1;
                        if (parity_check && start_bit_detected) begin
                            out_byte <= data_reg;
                            done <= 1;
                        end
                    end
                    state <= 3'b000; // Go back to idle state
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    reg [2:0] state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;
    reg parity_check;

    wire odd_parity;
    parity parity_checking(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_reg <= 8'b0;
            bit_count <= 3'b000;
            start_bit_detected <= 0;
            stop_bit_detected <= 0;
            parity_check <= 0;
            done <= 0;
        end else begin
            case (state)
                3'b000: begin // Idle state
                    if (in == 0) begin
                        state <= 3'b001; // Start bit detected
                        start_bit_detected <= 1;
                    end
                end
                3'b001: begin // Data receiving state
                    data_reg <= {data_reg[6:0], in};
                    bit_count <= bit_count + 1;
                    if (bit_count == 3'b100) begin
                        state <= 3'b010; // Parity bit received
                    end
                end
                3'b010: begin // Parity checking state
                    parity_check <= odd_parity;
                    state <= 3'b011; // Stop bit expected
                end
                3'b011: begin // Stop bit checking state
                    if (in == 1) begin
                        stop_bit_detected <= 1;
                        if (parity_check && start_bit_detected) begin
                            out_byte <= data_reg;
                            done <= 1;
                        end
                    end
                    state <= 3'b000; // Go back to idle state
                end
            endcase
        end
    end

endmodule
"
"    // Define states for the FSM
    parameter START = 2'b00;
    parameter BIT_0 = 2'b01;
    parameter BIT_1 = 2'b10;
    parameter PARITY = 2'b11;

    // Define signals for the FSM
    reg [1:0] state;
    reg [7:0] data_byte;
    reg parity_bit;
    reg stop_bit;
    reg done;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_bit)
    );

    always @(posedge clk) begin
        case(state)
            START: begin
                if (!in) begin
                    state <= BIT_0;
                    data_byte <= 0;
                end
            end
            BIT_0: begin
                data_byte <= {data_byte[6:0], in};
                state <= BIT_1;
            end
            BIT_1: begin
                data_byte <= {data_byte[6:0], in};
                state <= PARITY;
            end
            PARITY: begin
                parity_bit <= in;
                state <= START;
                if (parity_bit == odd) begin
                    out_byte <= data_byte[6:0];
                    done <= 1;
                end
            end
        endcase
    end

endmodule
",-1.0,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter START = 2'b00;
    parameter BIT_0 = 2'b01;
    parameter BIT_1 = 2'b10;
    parameter PARITY = 2'b11;

    // Define signals for the FSM
    reg [1:0] state;
    reg [7:0] data_byte;
    reg parity_bit;
    reg stop_bit;
    reg done;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_bit)
    );

    always @(posedge clk) begin
        case(state)
            START: begin
                if (!in) begin
                    state <= BIT_0;
                    data_byte <= 0;
                end
            end
            BIT_0: begin
                data_byte <= {data_byte[6:0], in};
                state <= BIT_1;
            end
            BIT_1: begin
                data_byte <= {data_byte[6:0], in};
                state <= PARITY;
            end
            PARITY: begin
                parity_bit <= in;
                state <= START;
                if (parity_bit == odd) begin
                    out_byte <= data_byte[6:0];
                    done <= 1;
                end
            end
        endcase
    end

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter START = 2'b00;
    parameter BIT_0 = 2'b01;
    parameter BIT_1 = 2'b10;
    parameter PARITY = 2'b11;

    // Define signals for the FSM
    reg [1:0] state;
    reg [7:0] data_byte;
    reg parity_bit;
    reg stop_bit;
    reg done;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_bit)
    );

    always @(posedge clk) begin
        case(state)
            START: begin
                if (!in) begin
                    state <= BIT_0;
                    data_byte <= 0;
                end
            end
            BIT_0: begin
                data_byte <= {data_byte[6:0], in};
                state <= BIT_1;
            end
            BIT_1: begin
                data_byte <= {data_byte[6:0], in};
                state <= PARITY;
            end
            PARITY: begin
                parity_bit <= in;
                state <= START;
                if (parity_bit == odd) begin
                    out_byte <= data_byte[6:0];
                    done <= 1;
                end
            end
        endcase
    end

endmodule
"
"    parameter IDLE = 2'b00;
    parameter START = 2'b01;
    parameter RECEIVE = 2'b10;
    parameter PARITY = 2'b11;
    
    reg [1:0] state;
    reg [2:0] count;
    reg [7:0] data_byte;
    reg start_bit;
    reg stop_bit;
    reg parity_bit;
    reg parity_check;
    reg odd_parity;
    wire parity_check_done;
    
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(parity_bit),
        .odd(odd_parity)
    );
    
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            count <= 0;
            data_byte <= 8'b0;
            start_bit <= 0;
            stop_bit <= 0;
            parity_bit <= 0;
            parity_check <= 0;
            odd_parity <= 0;
        end
        else begin
            case (state)
                IDLE: begin
                    if (in == 0) begin
                        state <= START;
                        count <= 0;
                        start_bit <= 0;
                        stop_bit <= 0;
                        parity_bit <= 0;
                        parity_check <= 0;
                        odd_parity <= 0;
                    end
                end
                START: begin
                    if (count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        count <= count + 1;
                    end
                    else begin
                        parity_bit <= in;
                        state <= PARITY;
                        count <= 0;
                    end
                end
                RECEIVE: begin
                    if (count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        count <= count + 1;
                    end
                    else begin
                        parity_bit <= in;
                        state <= PARITY;
                        count <= 0;
                    end
                end
                PARITY: begin
                    if (count == 0) begin
                        stop_bit <= in;
                        count <= count + 1;
                    end
                    else if (count == 1) begin
                        parity_check <= 1;
                        count <= count + 1;
                    end
                    else if (count == 2) begin
                        if (parity_check_done) begin
                            if (odd_parity) begin
                                if (parity_bit == 1) begin
                                    out_byte <= data_byte;
                                    done <= stop_bit;
                                end
                            end
                        end
                        state <= IDLE;
                        count <= 0;
                    end
                end
            endcase
        end
    end

endmodule
",-1.0,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    parameter IDLE = 2'b00;
    parameter START = 2'b01;
    parameter RECEIVE = 2'b10;
    parameter PARITY = 2'b11;
    
    reg [1:0] state;
    reg [2:0] count;
    reg [7:0] data_byte;
    reg start_bit;
    reg stop_bit;
    reg parity_bit;
    reg parity_check;
    reg odd_parity;
    wire parity_check_done;
    
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(parity_bit),
        .odd(odd_parity)
    );
    
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            count <= 0;
            data_byte <= 8'b0;
            start_bit <= 0;
            stop_bit <= 0;
            parity_bit <= 0;
            parity_check <= 0;
            odd_parity <= 0;
        end
        else begin
            case (state)
                IDLE: begin
                    if (in == 0) begin
                        state <= START;
                        count <= 0;
                        start_bit <= 0;
                        stop_bit <= 0;
                        parity_bit <= 0;
                        parity_check <= 0;
                        odd_parity <= 0;
                    end
                end
                START: begin
                    if (count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        count <= count + 1;
                    end
                    else begin
                        parity_bit <= in;
                        state <= PARITY;
                        count <= 0;
                    end
                end
                RECEIVE: begin
                    if (count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        count <= count + 1;
                    end
                    else begin
                        parity_bit <= in;
                        state <= PARITY;
                        count <= 0;
                    end
                end
                PARITY: begin
                    if (count == 0) begin
                        stop_bit <= in;
                        count <= count + 1;
                    end
                    else if (count == 1) begin
                        parity_check <= 1;
                        count <= count + 1;
                    end
                    else if (count == 2) begin
                        if (parity_check_done) begin
                            if (odd_parity) begin
                                if (parity_bit == 1) begin
                                    out_byte <= data_byte;
                                    done <= stop_bit;
                                end
                            end
                        end
                        state <= IDLE;
                        count <= 0;
                    end
                end
            endcase
        end
    end

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    parameter IDLE = 2'b00;
    parameter START = 2'b01;
    parameter RECEIVE = 2'b10;
    parameter PARITY = 2'b11;
    
    reg [1:0] state;
    reg [2:0] count;
    reg [7:0] data_byte;
    reg start_bit;
    reg stop_bit;
    reg parity_bit;
    reg parity_check;
    reg odd_parity;
    wire parity_check_done;
    
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(parity_bit),
        .odd(odd_parity)
    );
    
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            count <= 0;
            data_byte <= 8'b0;
            start_bit <= 0;
            stop_bit <= 0;
            parity_bit <= 0;
            parity_check <= 0;
            odd_parity <= 0;
        end
        else begin
            case (state)
                IDLE: begin
                    if (in == 0) begin
                        state <= START;
                        count <= 0;
                        start_bit <= 0;
                        stop_bit <= 0;
                        parity_bit <= 0;
                        parity_check <= 0;
                        odd_parity <= 0;
                    end
                end
                START: begin
                    if (count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        count <= count + 1;
                    end
                    else begin
                        parity_bit <= in;
                        state <= PARITY;
                        count <= 0;
                    end
                end
                RECEIVE: begin
                    if (count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        count <= count + 1;
                    end
                    else begin
                        parity_bit <= in;
                        state <= PARITY;
                        count <= 0;
                    end
                end
                PARITY: begin
                    if (count == 0) begin
                        stop_bit <= in;
                        count <= count + 1;
                    end
                    else if (count == 1) begin
                        parity_check <= 1;
                        count <= count + 1;
                    end
                    else if (count == 2) begin
                        if (parity_check_done) begin
                            if (odd_parity) begin
                                if (parity_bit == 1) begin
                                    out_byte <= data_byte;
                                    done <= stop_bit;
                                end
                            end
                        end
                        state <= IDLE;
                        count <= 0;
                    end
                end
            endcase
        end
    end

endmodule
"
"    reg [2:0] state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;
    reg parity_bit;
    reg odd_parity;
    wire odd_parity_check;

    // Instantiate the parity module
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    // Output the parity check result
    assign odd_parity_check = odd_parity;

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_reg <= 8'b0;
            bit_count <= 3'b000;
            start_bit_detected <= 1'b0;
            stop_bit_detected <= 1'b0;
            parity_bit <= 1'b0;
            done <= 1'b0;
        end else begin
            case(state)
                3'b000: begin // Idle state
                    if (in == 1'b0) begin
                        state <= 3'b001; // Transition to start bit detected state
                        start_bit_detected <= 1'b1;
                    end
                end
                3'b001: begin // Start bit detected state
                    if (bit_count < 3) begin
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        parity_bit <= in;
                        state <= 3'b010; // Transition to data and parity bits received state
                    end
                end
                3'b010: begin // Data and parity bits received state
                    if (bit_count < 8) begin
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        stop_bit_detected <= in;
                        if (odd_parity_check && stop_bit_detected) begin
                            out_byte <= data_reg;
                            done <= 1'b1;
                        end
                        state <= 3'b011; // Transition to stop bit detected state
                    end
                end
                3'b011: begin // Stop bit detected state
                    if (in == 1'b1) begin
                        state <= 3'b000; // Transition back to idle state
                        start_bit_detected <= 1'b0;
                        stop_bit_detected <= 1'b0;
                        parity_bit <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule
",-1.0,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    reg [2:0] state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;
    reg parity_bit;
    reg odd_parity;
    wire odd_parity_check;

    // Instantiate the parity module
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    // Output the parity check result
    assign odd_parity_check = odd_parity;

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_reg <= 8'b0;
            bit_count <= 3'b000;
            start_bit_detected <= 1'b0;
            stop_bit_detected <= 1'b0;
            parity_bit <= 1'b0;
            done <= 1'b0;
        end else begin
            case(state)
                3'b000: begin // Idle state
                    if (in == 1'b0) begin
                        state <= 3'b001; // Transition to start bit detected state
                        start_bit_detected <= 1'b1;
                    end
                end
                3'b001: begin // Start bit detected state
                    if (bit_count < 3) begin
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        parity_bit <= in;
                        state <= 3'b010; // Transition to data and parity bits received state
                    end
                end
                3'b010: begin // Data and parity bits received state
                    if (bit_count < 8) begin
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        stop_bit_detected <= in;
                        if (odd_parity_check && stop_bit_detected) begin
                            out_byte <= data_reg;
                            done <= 1'b1;
                        end
                        state <= 3'b011; // Transition to stop bit detected state
                    end
                end
                3'b011: begin // Stop bit detected state
                    if (in == 1'b1) begin
                        state <= 3'b000; // Transition back to idle state
                        start_bit_detected <= 1'b0;
                        stop_bit_detected <= 1'b0;
                        parity_bit <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    reg [2:0] state;
    reg [7:0] data_reg;
    reg [2:0] bit_count;
    reg start_bit_detected;
    reg stop_bit_detected;
    reg parity_bit;
    reg odd_parity;
    wire odd_parity_check;

    // Instantiate the parity module
    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    // Output the parity check result
    assign odd_parity_check = odd_parity;

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_reg <= 8'b0;
            bit_count <= 3'b000;
            start_bit_detected <= 1'b0;
            stop_bit_detected <= 1'b0;
            parity_bit <= 1'b0;
            done <= 1'b0;
        end else begin
            case(state)
                3'b000: begin // Idle state
                    if (in == 1'b0) begin
                        state <= 3'b001; // Transition to start bit detected state
                        start_bit_detected <= 1'b1;
                    end
                end
                3'b001: begin // Start bit detected state
                    if (bit_count < 3) begin
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        parity_bit <= in;
                        state <= 3'b010; // Transition to data and parity bits received state
                    end
                end
                3'b010: begin // Data and parity bits received state
                    if (bit_count < 8) begin
                        data_reg <= {data_reg[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        stop_bit_detected <= in;
                        if (odd_parity_check && stop_bit_detected) begin
                            out_byte <= data_reg;
                            done <= 1'b1;
                        end
                        state <= 3'b011; // Transition to stop bit detected state
                    end
                end
                3'b011: begin // Stop bit detected state
                    if (in == 1'b1) begin
                        state <= 3'b000; // Transition back to idle state
                        start_bit_detected <= 1'b0;
                        stop_bit_detected <= 1'b0;
                        parity_bit <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule
"
"    reg [2:0] state;
    reg [7:0] data_byte;
    reg start_bit;
    reg [2:0] bit_count;
    reg stop_bit;
    reg parity_bit;
    reg odd_parity;
    reg done;

    wire odd;

    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(parity_bit),
        .odd(odd)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_byte <= 8'b0;
            start_bit <= 1'b0;
            bit_count <= 3'b0;
            stop_bit <= 1'b0;
            parity_bit <= 1'b0;
            odd_parity <= 1'b0;
            done <= 1'b0;
        end
        else begin
            case (state)
                3'b000: begin // Wait for start bit
                    if (in == 1'b0) begin
                        start_bit <= 1'b1;
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Receive data bits
                    data_byte <= {data_byte[6:0], in};
                    bit_count <= bit_count + 1;
                    if (bit_count == 3'b111) begin
                        state <= 3'b010;
                    end
                end
                3'b010: begin // Receive parity bit
                    parity_bit <= in;
                    state <= 3'b011;
                end
                3'b011: begin // Check parity and stop bit
                    if (odd && in == 1'b0) begin
                        odd_parity <= 1'b1;
                    end
                    if (odd_parity && in == 1'b1) begin
                        stop_bit <= 1'b1;
                        done <= 1'b1;
                    end
                    state <= 3'b000;
                end
            endcase
        end
    end

    assign out_byte = data_byte;

endmodule
",-0.5,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    reg [2:0] state;
    reg [7:0] data_byte;
    reg start_bit;
    reg [2:0] bit_count;
    reg stop_bit;
    reg parity_bit;
    reg odd_parity;
    reg done;

    wire odd;

    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(parity_bit),
        .odd(odd)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_byte <= 8'b0;
            start_bit <= 1'b0;
            bit_count <= 3'b0;
            stop_bit <= 1'b0;
            parity_bit <= 1'b0;
            odd_parity <= 1'b0;
            done <= 1'b0;
        end
        else begin
            case (state)
                3'b000: begin // Wait for start bit
                    if (in == 1'b0) begin
                        start_bit <= 1'b1;
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Receive data bits
                    data_byte <= {data_byte[6:0], in};
                    bit_count <= bit_count + 1;
                    if (bit_count == 3'b111) begin
                        state <= 3'b010;
                    end
                end
                3'b010: begin // Receive parity bit
                    parity_bit <= in;
                    state <= 3'b011;
                end
                3'b011: begin // Check parity and stop bit
                    if (odd && in == 1'b0) begin
                        odd_parity <= 1'b1;
                    end
                    if (odd_parity && in == 1'b1) begin
                        stop_bit <= 1'b1;
                        done <= 1'b1;
                    end
                    state <= 3'b000;
                end
            endcase
        end
    end

    assign out_byte = data_byte;

endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    reg [2:0] state;
    reg [7:0] data_byte;
    reg start_bit;
    reg [2:0] bit_count;
    reg stop_bit;
    reg parity_bit;
    reg odd_parity;
    reg done;

    wire odd;

    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(parity_bit),
        .odd(odd)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_byte <= 8'b0;
            start_bit <= 1'b0;
            bit_count <= 3'b0;
            stop_bit <= 1'b0;
            parity_bit <= 1'b0;
            odd_parity <= 1'b0;
            done <= 1'b0;
        end
        else begin
            case (state)
                3'b000: begin // Wait for start bit
                    if (in == 1'b0) begin
                        start_bit <= 1'b1;
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Receive data bits
                    data_byte <= {data_byte[6:0], in};
                    bit_count <= bit_count + 1;
                    if (bit_count == 3'b111) begin
                        state <= 3'b010;
                    end
                end
                3'b010: begin // Receive parity bit
                    parity_bit <= in;
                    state <= 3'b011;
                end
                3'b011: begin // Check parity and stop bit
                    if (odd && in == 1'b0) begin
                        odd_parity <= 1'b1;
                    end
                    if (odd_parity && in == 1'b1) begin
                        stop_bit <= 1'b1;
                        done <= 1'b1;
                    end
                    state <= 3'b000;
                end
            endcase
        end
    end

    assign out_byte = data_byte;

endmodule
"
"    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter PARITY_BIT = 2'b11;
    parameter STOP_BIT = 2'b100;

    // Instantiate the parity module
    wire parity_bit;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_bit)
    );

    // Define registers for the FSM
    reg [2:0] state;
    reg [7:0] data_byte;
    reg [2:0] bit_count;

    // Output signals
    assign out_byte = data_byte;
    assign done = (state == STOP_BIT);

    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_byte <= 8'b0;
            bit_count <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (!in) begin
                        state <= START_BIT;
                        bit_count <= 0;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= PARITY_BIT;
                        bit_count <= 0;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= PARITY_BIT;
                        bit_count <= 0;
                    end
                end
                PARITY_BIT: begin
                    if (bit_count == 0) begin
                        parity_bit <= in;
                        bit_count <= bit_count + 1;
                    end else if (bit_count == 1) begin
                        if (parity_bit == 1) begin
                            state <= STOP_BIT;
                        end else begin
                            state <= IDLE;
                        end
                        bit_count <= 0;
                    end
                end
                STOP_BIT: begin
                    if (in) begin
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
endmodule
",-1.0,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter PARITY_BIT = 2'b11;
    parameter STOP_BIT = 2'b100;

    // Instantiate the parity module
    wire parity_bit;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_bit)
    );

    // Define registers for the FSM
    reg [2:0] state;
    reg [7:0] data_byte;
    reg [2:0] bit_count;

    // Output signals
    assign out_byte = data_byte;
    assign done = (state == STOP_BIT);

    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_byte <= 8'b0;
            bit_count <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (!in) begin
                        state <= START_BIT;
                        bit_count <= 0;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= PARITY_BIT;
                        bit_count <= 0;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= PARITY_BIT;
                        bit_count <= 0;
                    end
                end
                PARITY_BIT: begin
                    if (bit_count == 0) begin
                        parity_bit <= in;
                        bit_count <= bit_count + 1;
                    end else if (bit_count == 1) begin
                        if (parity_bit == 1) begin
                            state <= STOP_BIT;
                        end else begin
                            state <= IDLE;
                        end
                        bit_count <= 0;
                    end
                end
                STOP_BIT: begin
                    if (in) begin
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // Define states for the FSM
    parameter IDLE = 2'b00;
    parameter START_BIT = 2'b01;
    parameter DATA_BITS = 2'b10;
    parameter PARITY_BIT = 2'b11;
    parameter STOP_BIT = 2'b100;

    // Instantiate the parity module
    wire parity_bit;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_bit)
    );

    // Define registers for the FSM
    reg [2:0] state;
    reg [7:0] data_byte;
    reg [2:0] bit_count;

    // Output signals
    assign out_byte = data_byte;
    assign done = (state == STOP_BIT);

    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_byte <= 8'b0;
            bit_count <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (!in) begin
                        state <= START_BIT;
                        bit_count <= 0;
                    end
                end
                START_BIT: begin
                    if (bit_count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= PARITY_BIT;
                        bit_count <= 0;
                    end
                end
                DATA_BITS: begin
                    if (bit_count < 8) begin
                        data_byte <= {data_byte[6:0], in};
                        bit_count <= bit_count + 1;
                    end else begin
                        state <= PARITY_BIT;
                        bit_count <= 0;
                    end
                end
                PARITY_BIT: begin
                    if (bit_count == 0) begin
                        parity_bit <= in;
                        bit_count <= bit_count + 1;
                    end else if (bit_count == 1) begin
                        if (parity_bit == 1) begin
                            state <= STOP_BIT;
                        end else begin
                            state <= IDLE;
                        end
                        bit_count <= 0;
                    end
                end
                STOP_BIT: begin
                    if (in) begin
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
endmodule
"
"    reg [2:0] state;
    reg [7:0] data_reg;
    reg start_bit_detected;
    reg [3:0] bit_count;
    reg parity_bit;
    reg stop_bit_detected;
    reg odd_parity;

    wire odd_parity_check;

    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity_check)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_reg <= 8'b0;
            start_bit_detected <= 0;
            bit_count <= 0;
            parity_bit <= 0;
            stop_bit_detected <= 0;
            odd_parity <= 0;
        end else begin
            case (state)
                3'b000: begin // Wait for start bit
                    if (in == 0) begin
                        start_bit_detected <= 1;
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Receive data bits
                    if (bit_count < 8) begin
                        data_reg[bit_count] <= in;
                        bit_count <= bit_count + 1;
                    end else begin
                        parity_bit <= in;
                        state <= 3'b010;
                    end
                end
                3'b010: begin // Receive parity bit
                    odd_parity <= odd_parity_check;
                    state <= 3'b011;
                end
                3'b011: begin // Receive stop bit
                    if (in == 1) begin
                        stop_bit_detected <= 1;
                        state <= 3'b100;
                    end
                end
                3'b100: begin // Check parity and output data
                    if (odd_parity && stop_bit_detected) begin
                        out_byte <= data_reg;
                        done <= 1;
                    end
                    state <= 3'b000;
                end
            endcase
        end
    end
endmodule
",-1.0,Fsm_serialdp.v,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    // State definition
    typedef enum logic [2:0] {
        IDLE,
        START_WAIT,
        DATA_WAIT,
        PARITY_WAIT,
        STOP_WAIT
    } state_t;
    
    state_t state, next_state;
    
    // Counter to keep track of received bits
    reg [2:0] bit_count = 0;
    
    // Output register for holding the received byte
    reg [7:0] received_byte = 0;
    
    // Signal for the start and stop bits
    reg start_bit = 0;
    reg stop_bit = 1;
    
    // Signal to hold parity
    reg odd_parity = 0;
    
    // Parity module instantiation
    wire parity_out;
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(parity_out)
    );
    
    // Output registers
    reg [7:0] out_byte_reg = 0;
    reg done_reg = 0;

    // FSM
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Datapath
    always @(posedge clk) begin
        // Update next_state
        case (state)
            IDLE: next_state = (in == 0) ? START_WAIT : IDLE;
            START_WAIT: next_state = bit_count == 0 ? DATA_WAIT : START_WAIT;
            DATA_WAIT: next_state = bit_count == 8 ? PARITY_WAIT : DATA_WAIT;
            PARITY_WAIT: next_state = bit_count == 9 ? STOP_WAIT : PARITY_WAIT;
            STOP_WAIT: next_state = stop_bit == 1 ? IDLE : STOP_WAIT;
            default: next_state = IDLE;
        endcase
        
        // FSM actions
        case (state)
            IDLE: begin
                bit_count <= 0;
                received_byte <= 0;
                start_bit <= 0;
                stop_bit <= 1;
                odd_parity <= 0;
                out_byte_reg <= 0;
                done_reg <= 0;
            end
            START_WAIT: begin
                start_bit <= 1;
            end
            DATA_WAIT: begin
                received_byte <= {received_byte[6:0], in};
                bit_count <= bit_count + 1;
            end
            PARITY_WAIT: begin
                odd_parity <= parity_out;
                bit_count <= bit_count + 1;
            end
            STOP_WAIT: begin
                stop_bit <= in;
                bit_count <= 0;
                if (stop_bit == 1 && odd_parity == 1)
                    done_reg <= 1;
            end
        endcase
        
        // Output assignment
        out_byte_reg <= received_byte;
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule","// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    reg [2:0] state;
    reg [7:0] data_reg;
    reg start_bit_detected;
    reg [3:0] bit_count;
    reg parity_bit;
    reg stop_bit_detected;
    reg odd_parity;

    wire odd_parity_check;

    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity_check)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_reg <= 8'b0;
            start_bit_detected <= 0;
            bit_count <= 0;
            parity_bit <= 0;
            stop_bit_detected <= 0;
            odd_parity <= 0;
        end else begin
            case (state)
                3'b000: begin // Wait for start bit
                    if (in == 0) begin
                        start_bit_detected <= 1;
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Receive data bits
                    if (bit_count < 8) begin
                        data_reg[bit_count] <= in;
                        bit_count <= bit_count + 1;
                    end else begin
                        parity_bit <= in;
                        state <= 3'b010;
                    end
                end
                3'b010: begin // Receive parity bit
                    odd_parity <= odd_parity_check;
                    state <= 3'b011;
                end
                3'b011: begin // Receive stop bit
                    if (in == 1) begin
                        stop_bit_detected <= 1;
                        state <= 3'b100;
                    end
                end
                3'b100: begin // Check parity and output data
                    if (odd_parity && stop_bit_detected) begin
                        out_byte <= data_reg;
                        done <= 1;
                    end
                    state <= 3'b000;
                end
            endcase
        end
    end
endmodule
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

    reg [2:0] state;
    reg [7:0] data_reg;
    reg start_bit_detected;
    reg [3:0] bit_count;
    reg parity_bit;
    reg stop_bit_detected;
    reg odd_parity;

    wire odd_parity_check;

    parity parity_checker(
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity_check)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            data_reg <= 8'b0;
            start_bit_detected <= 0;
            bit_count <= 0;
            parity_bit <= 0;
            stop_bit_detected <= 0;
            odd_parity <= 0;
        end else begin
            case (state)
                3'b000: begin // Wait for start bit
                    if (in == 0) begin
                        start_bit_detected <= 1;
                        state <= 3'b001;
                    end
                end
                3'b001: begin // Receive data bits
                    if (bit_count < 8) begin
                        data_reg[bit_count] <= in;
                        bit_count <= bit_count + 1;
                    end else begin
                        parity_bit <= in;
                        state <= 3'b010;
                    end
                end
                3'b010: begin // Receive parity bit
                    odd_parity <= odd_parity_check;
                    state <= 3'b011;
                end
                3'b011: begin // Receive stop bit
                    if (in == 1) begin
                        stop_bit_detected <= 1;
                        state <= 3'b100;
                    end
                end
                3'b100: begin // Check parity and output data
                    if (odd_parity && stop_bit_detected) begin
                        out_byte <= data_reg;
                        done <= 1;
                    end
                    state <= 3'b000;
                end
            endcase
        end
    end
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b1;
            end
        endcase
    end

    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b1;
            end
        endcase
    end

    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b1;
            end
        endcase
    end

    assign out = out_reg;
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0; // Output 0
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0; // Output 0
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0; // Output 0
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0; // Output 0
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0; // Output 0
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0; // Output 0
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1; // Output 1
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0; // Output 0
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0; // Output 0
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0; // Output 0
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0; // Output 0
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0; // Output 0
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0; // Output 0
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0; // Output 0
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1; // Output 1
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0; // Output 0
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0; // Output 0
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0; // Output 0
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0; // Output 0
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0; // Output 0
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0; // Output 0
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0; // Output 0
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1; // Output 1
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0; // Output 0
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b1;
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b1;
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                end else begin
                    next_state = 2'b00; // Next state A
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                end else begin
                    next_state = 2'b10; // Next state C
                end
                out_reg = 1'b1;
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // State A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // State B
                end else begin
                    next_state = 2'b00; // State A
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // State B
                end else begin
                    next_state = 2'b10; // State C
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // State D
                end else begin
                    next_state = 2'b00; // State A
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // State B
                end else begin
                    next_state = 2'b10; // State C
                end
                out_reg = 1'b1;
            end
            default: begin
                next_state = 2'b00; // State A
                out_reg = 1'b0;
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // State A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // State B
                end else begin
                    next_state = 2'b00; // State A
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // State B
                end else begin
                    next_state = 2'b10; // State C
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // State D
                end else begin
                    next_state = 2'b00; // State A
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // State B
                end else begin
                    next_state = 2'b10; // State C
                end
                out_reg = 1'b1;
            end
            default: begin
                next_state = 2'b00; // State A
                out_reg = 1'b0;
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // State A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // State B
                end else begin
                    next_state = 2'b00; // State A
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // State B
                end else begin
                    next_state = 2'b10; // State C
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // State D
                end else begin
                    next_state = 2'b00; // State A
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // State B
                end else begin
                    next_state = 2'b10; // State C
                end
                out_reg = 1'b1;
            end
            default: begin
                next_state = 2'b00; // State A
                out_reg = 1'b0;
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end

    always @(*) begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end

    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end

    always @(*) begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end

    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end

    always @(*) begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end

    assign out = out_reg;
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b10; // Next state is C
                end else begin
                    next_state = 2'b01; // Next state is B
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b10; // Next state is C
                end else begin
                    next_state = 2'b01; // Next state is B
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b00; // Next state is A
                end else begin
                    next_state = 2'b11; // Next state is D
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b10; // Next state is C
                end else begin
                    next_state = 2'b01; // Next state is B
                end
                out_reg = 1'b1;
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b10; // Next state is C
                end else begin
                    next_state = 2'b01; // Next state is B
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b10; // Next state is C
                end else begin
                    next_state = 2'b01; // Next state is B
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b00; // Next state is A
                end else begin
                    next_state = 2'b11; // Next state is D
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b10; // Next state is C
                end else begin
                    next_state = 2'b01; // Next state is B
                end
                out_reg = 1'b1;
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b10; // Next state is C
                end else begin
                    next_state = 2'b01; // Next state is B
                end
                out_reg = 1'b0;
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b10; // Next state is C
                end else begin
                    next_state = 2'b01; // Next state is B
                end
                out_reg = 1'b0;
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b00; // Next state is A
                end else begin
                    next_state = 2'b11; // Next state is D
                end
                out_reg = 1'b0;
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b10; // Next state is C
                end else begin
                    next_state = 2'b01; // Next state is B
                end
                out_reg = 1'b1;
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end
    
    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end
    
    assign out = out_reg;
endmodule
"
"    reg [1:0] state, next_state;
    reg out_reg;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end

    assign out = out_reg;
endmodule
",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end

    assign out = out_reg;
endmodule
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic

    reg [1:0] state, next_state;
    reg out_reg;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= 2'b00; // Reset to state A
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        case(state)
            2'b00: begin // State A
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b01: begin // State B
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
            2'b10: begin // State C
                if (in) begin
                    next_state = 2'b11; // Next state D
                    out_reg = 1'b0;
                end else begin
                    next_state = 2'b00; // Next state A
                    out_reg = 1'b0;
                end
            end
            2'b11: begin // State D
                if (in) begin
                    next_state = 2'b01; // Next state B
                    out_reg = 1'b1;
                end else begin
                    next_state = 2'b10; // Next state C
                    out_reg = 1'b0;
                end
            end
        endcase
    end

    assign out = out_reg;
endmodule
"
"    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        2'b00;

    assign out = (state == D && in == 1) ? 1 : 0;
endmodule
",1.0,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        2'b00;

    assign out = (state == D && in == 1) ? 1 : 0;
endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        2'b00;

    assign out = (state == D && in == 1) ? 1 : 0;
endmodule
"
"    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        state;

    assign out = (state == D && in == 1) ? 1 : 0;

endmodule
",1.0,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        state;

    assign out = (state == D && in == 1) ? 1 : 0;

endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        state;

    assign out = (state == D && in == 1) ? 1 : 0;

endmodule
"
"    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == C && in == 0) ? A :
                        (state == D && in == 1) ? C :
                        state;

    assign out = (state == D && in == 1) ? 1 : 0;
endmodule
",-0.5,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == C && in == 0) ? A :
                        (state == D && in == 1) ? C :
                        state;

    assign out = (state == D && in == 1) ? 1 : 0;
endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == C && in == 0) ? A :
                        (state == D && in == 1) ? C :
                        state;

    assign out = (state == D && in == 1) ? 1 : 0;
endmodule
"
"    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        2'b00;

    assign out = (state == D && in == 1) ? 1 : 0;

endmodule
",1.0,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        2'b00;

    assign out = (state == D && in == 1) ? 1 : 0;

endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        2'b00;

    assign out = (state == D && in == 1) ? 1 : 0;

endmodule
"
"    assign next_state = (state == A && in == 1) ? B :
                         (state == B && in == 0) ? C :
                         (state == C && in == 1) ? D :
                         (state == D && in == 0) ? C :
                         state;

    assign out = (state == D && in == 0) ? 1 : 0;
endmodule
",-0.5,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                         (state == B && in == 0) ? C :
                         (state == C && in == 1) ? D :
                         (state == D && in == 0) ? C :
                         state;

    assign out = (state == D && in == 0) ? 1 : 0;
endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                         (state == B && in == 0) ? C :
                         (state == C && in == 1) ? D :
                         (state == D && in == 0) ? C :
                         state;

    assign out = (state == D && in == 0) ? 1 : 0;
endmodule
"
"    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C : A;

    assign out = (state == D && in == 0) ? 1 : 0;

endmodule
",-0.5,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C : A;

    assign out = (state == D && in == 0) ? 1 : 0;

endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C : A;

    assign out = (state == D && in == 0) ? 1 : 0;

endmodule
"
"    assign next_state = (state == A && in == 0) ? A :
                        (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B : 2'b00;

    assign out = (state == D) ? 1'b1 : 1'b0;
endmodule
",1.0,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 0) ? A :
                        (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B : 2'b00;

    assign out = (state == D) ? 1'b1 : 1'b0;
endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 0) ? A :
                        (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B : 2'b00;

    assign out = (state == D) ? 1'b1 : 1'b0;
endmodule
"
"    assign next_state = (state == A && in == 0) ? A :
                        (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B : 0;

    assign out = (state == D) ? 1 : 0;

endmodule
",1.0,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 0) ? A :
                        (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B : 0;

    assign out = (state == D) ? 1 : 0;

endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 0) ? A :
                        (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B : 0;

    assign out = (state == D) ? 1 : 0;

endmodule
"
"    // State transition logic
    always @(*)
    begin
        case(state)
            A: next_state = (in == 0) ? A : B;
            B: next_state = (in == 0) ? C : B;
            C: next_state = (in == 0) ? A : D;
            D: next_state = (in == 0) ? C : B;
        endcase
    end

    // Output logic
    assign out = (state == D) ? 1'b1 : 1'b0;

endmodule
",-1.0,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    // State transition logic
    always @(*)
    begin
        case(state)
            A: next_state = (in == 0) ? A : B;
            B: next_state = (in == 0) ? C : B;
            C: next_state = (in == 0) ? A : D;
            D: next_state = (in == 0) ? C : B;
        endcase
    end

    // Output logic
    assign out = (state == D) ? 1'b1 : 1'b0;

endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    // State transition logic
    always @(*)
    begin
        case(state)
            A: next_state = (in == 0) ? A : B;
            B: next_state = (in == 0) ? C : B;
            C: next_state = (in == 0) ? A : D;
            D: next_state = (in == 0) ? C : B;
        endcase
    end

    // Output logic
    assign out = (state == D) ? 1'b1 : 1'b0;

endmodule
"
"    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        state;
    
    assign out = (state == D && in == 1) ? 1 : 0;
endmodule
",1.0,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        state;
    
    assign out = (state == D && in == 1) ? 1 : 0;
endmodule
","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;



    assign next_state = (state == A && in == 1) ? B :
                        (state == B && in == 0) ? C :
                        (state == B && in == 1) ? B :
                        (state == C && in == 0) ? A :
                        (state == C && in == 1) ? D :
                        (state == D && in == 0) ? C :
                        (state == D && in == 1) ? B :
                        state;
    
    assign out = (state == D && in == 1) ? 1 : 0;
endmodule
"
"
    assign next_state[A] = !in ? state[B] : state[A];
    assign next_state[B] = in ? state[B] : state[C];
    assign next_state[C] = !in ? state[A] : state[D];
    assign next_state[D] = in ? state[B] : state[C];
    
    assign out = state[D]; // Output is the value of state D
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = !in ? state[B] : state[A];
    assign next_state[B] = in ? state[B] : state[C];
    assign next_state[C] = !in ? state[A] : state[D];
    assign next_state[D] = in ? state[B] : state[C];
    
    assign out = state[D]; // Output is the value of state D
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = !in ? state[B] : state[A];
    assign next_state[B] = in ? state[B] : state[C];
    assign next_state[C] = !in ? state[A] : state[D];
    assign next_state[D] = in ? state[B] : state[C];
    
    assign out = state[D]; // Output is the value of state D
endmodule
"
"
    assign next_state[A] = in ? C : B;
    assign next_state[B] = in ? B : D;
    assign next_state[C] = in ? A : B;
    assign next_state[D] = in ? C : B;
    
    assign out = (state == D) ? 1'b1 : 1'b0;
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = in ? C : B;
    assign next_state[B] = in ? B : D;
    assign next_state[C] = in ? A : B;
    assign next_state[D] = in ? C : B;
    
    assign out = (state == D) ? 1'b1 : 1'b0;
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = in ? C : B;
    assign next_state[B] = in ? B : D;
    assign next_state[C] = in ? A : B;
    assign next_state[D] = in ? C : B;
    
    assign out = (state == D) ? 1'b1 : 1'b0;
endmodule
"
"
    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[B]) | (in & state[D]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[B]) | (in & state[D]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[B]) | (in & state[D]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
"
"
    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
"
"
    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
"
"
    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[C]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
"
"
    assign next_state[A] = (state[B] & !in) | (state[C] & in);
    assign next_state[B] = (state[C] & !in) | (state[B] & in);
    assign next_state[C] = (state[A] & !in) | (state[D] & in);
    assign next_state[D] = (state[C] & !in) | (state[B] & in);

    assign out = state[D]; // Output is the value of state D
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (state[B] & !in) | (state[C] & in);
    assign next_state[B] = (state[C] & !in) | (state[B] & in);
    assign next_state[C] = (state[A] & !in) | (state[D] & in);
    assign next_state[D] = (state[C] & !in) | (state[B] & in);

    assign out = state[D]; // Output is the value of state D
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (state[B] & !in) | (state[C] & in);
    assign next_state[B] = (state[C] & !in) | (state[B] & in);
    assign next_state[C] = (state[A] & !in) | (state[D] & in);
    assign next_state[D] = (state[C] & !in) | (state[B] & in);

    assign out = state[D]; // Output is the value of state D
endmodule
"
"
    assign next_state[A] = (~in & state[B]) | (in & state[D]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[D]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (~in & state[B]) | (in & state[D]);
    assign next_state[B] = (~in & state[C]) | (in & state[B]);
    assign next_state[C] = (~in & state[A]) | (in & state[D]);
    assign next_state[D] = (~in & state[C]) | (in & state[B]);

    assign out = state[D]; // Output is the value of state D
endmodule
"
"
    assign next_state[A] = (state[B] & ~in) | (state[C] & in);
    assign next_state[B] = (state[C] & ~in) | (state[B] & in);
    assign next_state[C] = (state[A] & ~in) | (state[D] & in);
    assign next_state[D] = (state[C] & ~in) | (state[B] & in);

    assign out = state[D]; // Output is based on current state D
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (state[B] & ~in) | (state[C] & in);
    assign next_state[B] = (state[C] & ~in) | (state[B] & in);
    assign next_state[C] = (state[A] & ~in) | (state[D] & in);
    assign next_state[D] = (state[C] & ~in) | (state[B] & in);

    assign out = state[D]; // Output is based on current state D
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = (state[B] & ~in) | (state[C] & in);
    assign next_state[B] = (state[C] & ~in) | (state[B] & in);
    assign next_state[C] = (state[A] & ~in) | (state[D] & in);
    assign next_state[D] = (state[C] & ~in) | (state[B] & in);

    assign out = state[D]; // Output is based on current state D
endmodule
"
"
    assign next_state[A] = ~in & state[B] | in & state[B];
    assign next_state[B] = ~in & state[C] | in & state[B];
    assign next_state[C] = ~in & state[A] | in & state[D];
    assign next_state[D] = ~in & state[C] | in & state[B];

    assign out = state[D]; // Output is the value of state D
endmodule
",-1.0,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = ~in & state[B] | in & state[B];
    assign next_state[B] = ~in & state[C] | in & state[B];
    assign next_state[C] = ~in & state[A] | in & state[D];
    assign next_state[D] = ~in & state[C] | in & state[B];

    assign out = state[D]; // Output is the value of state D
endmodule
","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;

    assign next_state[A] = ~in & state[B] | in & state[B];
    assign next_state[B] = ~in & state[C] | in & state[B];
    assign next_state[C] = ~in & state[A] | in & state[D];
    assign next_state[D] = ~in & state[C] | in & state[B];

    assign out = state[D]; // Output is the value of state D
endmodule
"
"    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
"
"    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
"
"
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);


    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);


    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
"
"
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);


    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);


    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
"
"    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
"
"
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);


    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);


    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
"
"    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
"
"    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule
"
"
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);


    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);


    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
"
"    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
",1.0,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);

    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;
endmodule
"
"
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"
    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
"
"
    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate
    
    assign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate
    
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR gate
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate
    
    assign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate
    
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR gate
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate
    
    assign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate
    
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR gate
endmodule
"
"
    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
"
"
    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
"
"
    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate
    
    assign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate
    
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR gate
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate
    
    assign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate
    
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR gate
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate
    
    assign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate
    
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR gate
endmodule
"
"
    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
"
"
    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
"
"
    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
"
"
    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
endmodule
"
"
    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate
    
    assign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate
    
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR gate
endmodule
",1.0,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate
    
    assign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate
    
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR gate
endmodule
","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate
    
    assign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate
    
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR gate
endmodule
"
"
    assign out_both = in[99:1] & in[98:0];
    assign out_any = in | {1'b0, in[99:1]};
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in | {1'b0, in[99:1]};
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in | {1'b0, in[99:1]};
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
"
"
    assign out_both = in[99:1] & in[98:0];
    assign out_any = in | {1'b0, in[99:1]};
    assign out_different = in ^ {in[99], in[98:0]};
endmodule
",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in | {1'b0, in[99:1]};
    assign out_different = in ^ {in[99], in[98:0]};
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in | {1'b0, in[99:1]};
    assign out_different = in ^ {in[99], in[98:0]};
endmodule
"
"
    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[0:98] | in[1:99];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
",-1.0,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[0:98] | in[1:99];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[0:98] | in[1:99];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
"
"
    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[98:0] | in[99:1];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[98:0] | in[99:1];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[98:0] | in[99:1];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
"
"
    assign out_both = in[99:1] & in[98:0];
    assign out_any = {in[98:0], in[99]};
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = {in[98:0], in[99]};
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = {in[98:0], in[99]};
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
"
"
    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[0:98] | in[1:99];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
",-1.0,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[0:98] | in[1:99];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[0:98] | in[1:99];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
"
"
    assign out_both = in[99:1] & in[98:0];
    assign out_any = in | {1'b0, in[99:1]};
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in | {1'b0, in[99:1]};
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in | {1'b0, in[99:1]};
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
"
"
    assign out_both = in[99:1] & in[98:0];
    assign out_any = {in[0], in[99:1]} | {in[1:99], in[0]};
    assign out_different = in ^ {in[99], in[98:0]};
endmodule
",-1.0,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = {in[0], in[99:1]} | {in[1:99], in[0]};
    assign out_different = in ^ {in[99], in[98:0]};
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = {in[0], in[99:1]} | {in[1:99], in[0]};
    assign out_different = in ^ {in[99], in[98:0]};
endmodule
"
"
    assign out_both = in[98:0] & in[99:1];
    assign out_any = in[99:1] | in[98:0];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[98:0] & in[99:1];
    assign out_any = in[99:1] | in[98:0];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[98:0] & in[99:1];
    assign out_any = in[99:1] | in[98:0];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
"
"
    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[98:0] | in[99:1];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[98:0] | in[99:1];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );


    assign out_both = in[99:1] & in[98:0];
    assign out_any = in[98:0] | in[99:1];
    assign out_different = in ^ {in[99], in[98:0]}; 
endmodule
"
"
    // Define the sum and carry-out signals
    wire sum, cout;

    // Implement the half adder logic
    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    // Define the sum and carry-out signals
    wire sum, cout;

    // Implement the half adder logic
    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    // Define the sum and carry-out signals
    wire sum, cout;

    // Implement the half adder logic
    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
"
"
    // XOR gate for sum
    assign sum = a ^ b;
    
    // AND gate for carry-out
    assign cout = a & b;
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    // XOR gate for sum
    assign sum = a ^ b;
    
    // AND gate for carry-out
    assign cout = a & b;
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    // XOR gate for sum
    assign sum = a ^ b;
    
    // AND gate for carry-out
    assign cout = a & b;
endmodule
"
"
    assign sum = a ^ b; // XOR operation to calculate sum
    assign cout = a & b; // AND operation to calculate carry-out
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR operation to calculate sum
    assign cout = a & b; // AND operation to calculate carry-out
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR operation to calculate sum
    assign cout = a & b; // AND operation to calculate carry-out
endmodule
"
"
    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
"
"
    assign sum = a ^ b; // XOR operation to get the sum
    assign cout = a & b; // AND operation to get the carry-out
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR operation to get the sum
    assign cout = a & b; // AND operation to get the carry-out
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR operation to get the sum
    assign cout = a & b; // AND operation to get the carry-out
endmodule
"
"
    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
"
"
    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
"
"
    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
"
"
    // Logic for sum output
    assign sum = a ^ b;
    
    // Logic for carry-out output
    assign cout = a & b;
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    // Logic for sum output
    assign sum = a ^ b;
    
    // Logic for carry-out output
    assign cout = a & b;
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    // Logic for sum output
    assign sum = a ^ b;
    
    // Logic for carry-out output
    assign cout = a & b;
endmodule
"
"
    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
",1.0,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b; // XOR gate for sum
    assign cout = a & b; // AND gate for carry-out
endmodule
"
"
  assign out = !(a & !b & !c) | !(a & !b & c) | !(a & b & c) | !(a & b & !c);
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

  assign out = !(a & !b & !c) | !(a & !b & c) | !(a & b & c) | !(a & b & !c);
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

  assign out = !(a & !b & !c) | !(a & !b & c) | !(a & b & c) | !(a & b & !c);
endmodule
"
"
  assign out = (a & b) | (a & c) | (b & c) | (b & ~c); 
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

  assign out = (a & b) | (a & c) | (b & c) | (b & ~c); 
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

  assign out = (a & b) | (a & c) | (b & c) | (b & ~c); 
endmodule
"
"
    assign out = (a & b) | (a & c) | (b & c) | (b & !c); // Simplified circuit using sum-of-products form
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

    assign out = (a & b) | (a & c) | (b & c) | (b & !c); // Simplified circuit using sum-of-products form
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

    assign out = (a & b) | (a & c) | (b & c) | (b & !c); // Simplified circuit using sum-of-products form
endmodule
"
"
  assign out = (a & b) | (a & c) | (b & c) | (b & c & a); 
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

  assign out = (a & b) | (a & c) | (b & c) | (b & c & a); 
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

  assign out = (a & b) | (a & c) | (b & c) | (b & c & a); 
endmodule
"
"
    assign out = (a & b) | (a & c) | (b & c) | (b & !c); 
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

    assign out = (a & b) | (a & c) | (b & c) | (b & !c); 
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

    assign out = (a & b) | (a & c) | (b & c) | (b & !c); 
endmodule
"
"
  assign out = (a & b) | (a & c) | (b & c) | (a & b & c);
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

  assign out = (a & b) | (a & c) | (b & c) | (a & b & c);
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

  assign out = (a & b) | (a & c) | (b & c) | (a & b & c);
endmodule
"
"
  // Simplified circuit using product-of-sums form
  assign out = !(a & !b & !c) | !(a & !b & c) | !(a & b & c) | !(a & b & !c);
  
  // Simplified circuit using sum-of-products form
  assign out = (a | b | c) & (!a | b | !c) & (!a | !b | c) & (!a | !b | !c);
  
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

  // Simplified circuit using product-of-sums form
  assign out = !(a & !b & !c) | !(a & !b & c) | !(a & b & c) | !(a & b & !c);
  
  // Simplified circuit using sum-of-products form
  assign out = (a | b | c) & (!a | b | !c) & (!a | !b | c) & (!a | !b | !c);
  
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

  // Simplified circuit using product-of-sums form
  assign out = !(a & !b & !c) | !(a & !b & c) | !(a & b & c) | !(a & b & !c);
  
  // Simplified circuit using sum-of-products form
  assign out = (a | b | c) & (!a | b | !c) & (!a | !b | c) & (!a | !b | !c);
  
endmodule
"
"
    assign out = (a & b) | (a & c) | (b & c) | (b & ~c); // Simplified circuit implementation based on K-map
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

    assign out = (a & b) | (a & c) | (b & c) | (b & ~c); // Simplified circuit implementation based on K-map
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

    assign out = (a & b) | (a & c) | (b & c) | (b & ~c); // Simplified circuit implementation based on K-map
endmodule
"
"
  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = ~a & ~b & ~c;
  assign minterm2 = ~a & ~b & c;
  assign minterm3 = ~a & b & c;
  assign minterm4 = ~a & b & ~c;

  assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = ~a & ~b & ~c;
  assign minterm2 = ~a & ~b & c;
  assign minterm3 = ~a & b & c;
  assign minterm4 = ~a & b & ~c;

  assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = ~a & ~b & ~c;
  assign minterm2 = ~a & ~b & c;
  assign minterm3 = ~a & b & c;
  assign minterm4 = ~a & b & ~c;

  assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
"
"
    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = ~a & ~b & ~c;
    assign minterm2 = ~a & ~b & c;
    assign minterm3 = a & b & c;
    assign minterm4 = a & b & ~c;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );

    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = ~a & ~b & ~c;
    assign minterm2 = ~a & ~b & c;
    assign minterm3 = a & b & c;
    assign minterm4 = a & b & ~c;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
","module top_module(
    input a,
    input b,
    input c,
    output out  );

    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = ~a & ~b & ~c;
    assign minterm2 = ~a & ~b & c;
    assign minterm3 = a & b & c;
    assign minterm4 = a & b & ~c;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
"
"
    wire minterm1, minterm2, minterm3, minterm4, minterm5, minterm6, minterm7, minterm8;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & !b & !c & d;
    assign minterm3 = !a & b & c & !d;
    assign minterm4 = a & !b & c & !d;
    assign minterm5 = !a & b & c & d;
    assign minterm6 = a & b & !c & !d;
    assign minterm7 = a & b & !c & d;
    assign minterm8 = a & !b & c & d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4 | minterm5 | minterm6 | minterm7 | minterm8;
endmodule
",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


    wire minterm1, minterm2, minterm3, minterm4, minterm5, minterm6, minterm7, minterm8;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & !b & !c & d;
    assign minterm3 = !a & b & c & !d;
    assign minterm4 = a & !b & c & !d;
    assign minterm5 = !a & b & c & d;
    assign minterm6 = a & b & !c & !d;
    assign minterm7 = a & b & !c & d;
    assign minterm8 = a & !b & c & d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4 | minterm5 | minterm6 | minterm7 | minterm8;
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


    wire minterm1, minterm2, minterm3, minterm4, minterm5, minterm6, minterm7, minterm8;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & !b & !c & d;
    assign minterm3 = !a & b & c & !d;
    assign minterm4 = a & !b & c & !d;
    assign minterm5 = !a & b & c & d;
    assign minterm6 = a & b & !c & !d;
    assign minterm7 = a & b & !c & d;
    assign minterm8 = a & !b & c & d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4 | minterm5 | minterm6 | minterm7 | minterm8;
endmodule
"
"
// Simplified expression using product-of-sums form:
// out = (!a + !b + c) + (!a + b + !d) + (a + b + c) + (a + !b + !d)

// Simplified expression using sum-of-products form:
// out = (a'b'c) + (a'b!d) + (ab'c) + (ab!d)

assign out = (!a & !b & c) | (!a & b & !d) | (a & b & c) | (a & !b & !d);
",-1.0,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


// Simplified expression using product-of-sums form:
// out = (!a + !b + c) + (!a + b + !d) + (a + b + c) + (a + !b + !d)

// Simplified expression using sum-of-products form:
// out = (a'b'c) + (a'b!d) + (ab'c) + (ab!d)

assign out = (!a & !b & c) | (!a & b & !d) | (a & b & c) | (a & !b & !d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


// Simplified expression using product-of-sums form:
// out = (!a + !b + c) + (!a + b + !d) + (a + b + c) + (a + !b + !d)

// Simplified expression using sum-of-products form:
// out = (a'b'c) + (a'b!d) + (ab'c) + (ab!d)

assign out = (!a & !b & c) | (!a & b & !d) | (a & b & c) | (a & !b & !d);
"
"
  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = !a & !b & !c & !d;
  assign minterm2 = !a & !b & c & !d;
  assign minterm3 = a & b & !c & d;
  assign minterm4 = a & !b & !c & !d;

  // Output is the OR combination of all minterms
  assign out = minterm1 | minterm2 | minterm3 | minterm4;
  
endmodule
",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = !a & !b & !c & !d;
  assign minterm2 = !a & !b & c & !d;
  assign minterm3 = a & b & !c & d;
  assign minterm4 = a & !b & !c & !d;

  // Output is the OR combination of all minterms
  assign out = minterm1 | minterm2 | minterm3 | minterm4;
  
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = !a & !b & !c & !d;
  assign minterm2 = !a & !b & c & !d;
  assign minterm3 = a & b & !c & d;
  assign minterm4 = a & !b & !c & !d;

  // Output is the OR combination of all minterms
  assign out = minterm1 | minterm2 | minterm3 | minterm4;
  
endmodule
"
"// Implementing the simplified circuit in sum-of-products form

assign out = (~a & ~b & c & d) | (~a & b & ~c & d) | (a & b & c) | (a & ~b & ~d);
",-1.0,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Implementing the simplified circuit in sum-of-products form

assign out = (~a & ~b & c & d) | (~a & b & ~c & d) | (a & b & c) | (a & ~b & ~d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Implementing the simplified circuit in sum-of-products form

assign out = (~a & ~b & c & d) | (~a & b & ~c & d) | (a & b & c) | (a & ~b & ~d);
"
"
// Simplified expression using product-of-sums form:
// f = (a' + b' + d) * (a' + c + d) * (b + c + d)

// Simplified expression using sum-of-products form:
// f = (a' * c' * d) + (a' * b * d) + (a' * b' * c) + (b * c * d)

assign out = (~a & ~b & d) | (~a & c & d) | (~b & c & d) | (b & c & ~d);
",-1.0,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


// Simplified expression using product-of-sums form:
// f = (a' + b' + d) * (a' + c + d) * (b + c + d)

// Simplified expression using sum-of-products form:
// f = (a' * c' * d) + (a' * b * d) + (a' * b' * c) + (b * c * d)

assign out = (~a & ~b & d) | (~a & c & d) | (~b & c & d) | (b & c & ~d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


// Simplified expression using product-of-sums form:
// f = (a' + b' + d) * (a' + c + d) * (b + c + d)

// Simplified expression using sum-of-products form:
// f = (a' * c' * d) + (a' * b * d) + (a' * b' * c) + (b * c * d)

assign out = (~a & ~b & d) | (~a & c & d) | (~b & c & d) | (b & c & ~d);
"
"
    wire minterm1, minterm2, minterm3, minterm4, minterm5, minterm6, minterm7, minterm8;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & !b & !c & d;
    assign minterm3 = a & b & !c & d;
    assign minterm4 = !a & b & c & d;
    assign minterm5 = a & !b & c & d;
    assign minterm6 = a & !b & c & !d;
    assign minterm7 = !a & b & !c & !d;
    assign minterm8 = a & b & c & !d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4 | minterm5 | minterm6 | minterm7 | minterm8;

endmodule
",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


    wire minterm1, minterm2, minterm3, minterm4, minterm5, minterm6, minterm7, minterm8;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & !b & !c & d;
    assign minterm3 = a & b & !c & d;
    assign minterm4 = !a & b & c & d;
    assign minterm5 = a & !b & c & d;
    assign minterm6 = a & !b & c & !d;
    assign minterm7 = !a & b & !c & !d;
    assign minterm8 = a & b & c & !d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4 | minterm5 | minterm6 | minterm7 | minterm8;

endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


    wire minterm1, minterm2, minterm3, minterm4, minterm5, minterm6, minterm7, minterm8;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & !b & !c & d;
    assign minterm3 = a & b & !c & d;
    assign minterm4 = !a & b & c & d;
    assign minterm5 = a & !b & c & d;
    assign minterm6 = a & !b & c & !d;
    assign minterm7 = !a & b & !c & !d;
    assign minterm8 = a & b & c & !d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4 | minterm5 | minterm6 | minterm7 | minterm8;

endmodule
"
"
    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & b & !c & !d;
    assign minterm3 = a & b & c & d;
    assign minterm4 = a & !b & !c & d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & b & !c & !d;
    assign minterm3 = a & b & c & d;
    assign minterm4 = a & !b & !c & d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & b & !c & !d;
    assign minterm3 = a & b & c & d;
    assign minterm4 = a & !b & !c & d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
"
"
// Simplified circuit in sum-of-products form
assign out = (!a && !b && !c && d) || (!a && b && c) || (a && b && !d) || (a && !b && !c);

// Simplified circuit in product-of-sums form
// assign out = (!a + !b + c + d) * (!a + b + !c + d) * (a + b + d) * (a + !b + !c);
",-1.0,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


// Simplified circuit in sum-of-products form
assign out = (!a && !b && !c && d) || (!a && b && c) || (a && b && !d) || (a && !b && !c);

// Simplified circuit in product-of-sums form
// assign out = (!a + !b + c + d) * (!a + b + !c + d) * (a + b + d) * (a + !b + !c);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


// Simplified circuit in sum-of-products form
assign out = (!a && !b && !c && d) || (!a && b && c) || (a && b && !d) || (a && !b && !c);

// Simplified circuit in product-of-sums form
// assign out = (!a + !b + c + d) * (!a + b + !c + d) * (a + b + d) * (a + !b + !c);
"
"
// Simplified circuit using product-of-sums form
assign out = (!a && !b && c) || (!a && b && !d) || (a && b) || (a && !b && !d);

// Simplified circuit using sum-of-products form
assign out = (!a && !b && c) || (!a && b && !d) || (a && b) || (a && !b && !d);
",-1.0,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


// Simplified circuit using product-of-sums form
assign out = (!a && !b && c) || (!a && b && !d) || (a && b) || (a && !b && !d);

// Simplified circuit using sum-of-products form
assign out = (!a && !b && c) || (!a && b && !d) || (a && b) || (a && !b && !d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


// Simplified circuit using product-of-sums form
assign out = (!a && !b && c) || (!a && b && !d) || (a && b) || (a && !b && !d);

// Simplified circuit using sum-of-products form
assign out = (!a && !b && c) || (!a && b && !d) || (a && b) || (a && !b && !d);
"
"
    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & b & !c & !d;
    assign minterm3 = a & b & c & d;
    assign minterm4 = a & !b & !c & d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & b & !c & !d;
    assign minterm3 = a & b & c & d;
    assign minterm4 = a & !b & !c & d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );


    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = !a & !b & !c & !d;
    assign minterm2 = !a & b & !c & !d;
    assign minterm3 = a & b & c & d;
    assign minterm4 = a & !b & !c & d;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
"
"// Simplified Karnaugh map for the given truth table:
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |

// Simplified boolean expression:
// out = !a && c || b

// Circuit implementation:
assign out = (!a && c) || b;
",-1.0,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
// Simplified Karnaugh map for the given truth table:
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |

// Simplified boolean expression:
// out = !a && c || b

// Circuit implementation:
assign out = (!a && c) || b;
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
// Simplified Karnaugh map for the given truth table:
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |

// Simplified boolean expression:
// out = !a && c || b

// Circuit implementation:
assign out = (!a && c) || b;
"
"
    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = !a & !b & d;
    assign minterm2 = !b & (c & d' | c' & d);
    assign minterm3 = b & (c & d | c' & d);
    assign minterm4 = a & b & !c;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
",-1.0,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = !a & !b & d;
    assign minterm2 = !b & (c & d' | c' & d);
    assign minterm3 = b & (c & d | c' & d);
    assign minterm4 = a & b & !c;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    wire minterm1, minterm2, minterm3, minterm4;

    assign minterm1 = !a & !b & d;
    assign minterm2 = !b & (c & d' | c' & d);
    assign minterm3 = b & (c & d | c' & d);
    assign minterm4 = a & b & !c;

    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
"
"
    assign out = (c & !d & !a & b) | (!c & d & a & b) | (c & d & a) | (c & d & !a); 
endmodule
",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    assign out = (c & !d & !a & b) | (!c & d & a & b) | (c & d & a) | (c & d & !a); 
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    assign out = (c & !d & !a & b) | (!c & d & a & b) | (c & d & a) | (c & d & !a); 
endmodule
"
"
    assign out = (~a & ~b & d) | (~a & b & c) | (a & b) | (a & ~b & c);
endmodule
",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    assign out = (~a & ~b & d) | (~a & b & c) | (a & b) | (a & ~b & c);
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    assign out = (~a & ~b & d) | (~a & b & c) | (a & b) | (a & ~b & c);
endmodule
"
"
// Simplified circuit using product-of-sums form
assign out = !(a && b && c) || (b && d) || (c && d) || (a && !b && !d);

// Simplified circuit using sum-of-products form
assign out = (a && !b && !c && !d) || (!a && b && d) || (!a && c && d) || (a && !b && c && d);
",-1.0,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified circuit using product-of-sums form
assign out = !(a && b && c) || (b && d) || (c && d) || (a && !b && !d);

// Simplified circuit using sum-of-products form
assign out = (a && !b && !c && !d) || (!a && b && d) || (!a && c && d) || (a && !b && c && d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified circuit using product-of-sums form
assign out = !(a && b && c) || (b && d) || (c && d) || (a && !b && !d);

// Simplified circuit using sum-of-products form
assign out = (a && !b && !c && !d) || (!a && b && d) || (!a && c && d) || (a && !b && c && d);
"
"
// Simplified circuit using product-of-sums form
assign out = (!a && !b && d) || (!a && c && !d) || (b && c) || (a && b && !c);

// Simplified circuit using sum-of-products form
assign out = (a && b && c) || (!a && b && c) || (b && c && d) || (!a && !b && !c && d);
",-1.0,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified circuit using product-of-sums form
assign out = (!a && !b && d) || (!a && c && !d) || (b && c) || (a && b && !c);

// Simplified circuit using sum-of-products form
assign out = (a && b && c) || (!a && b && c) || (b && c && d) || (!a && !b && !c && d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified circuit using product-of-sums form
assign out = (!a && !b && d) || (!a && c && !d) || (b && c) || (a && b && !c);

// Simplified circuit using sum-of-products form
assign out = (a && b && c) || (!a && b && c) || (b && c && d) || (!a && !b && !c && d);
"
"
// Simplified expression using product-of-sums form:
// out = (a' + c) + (b + c' + d)

// Simplified expression using sum-of-products form:
// out = (a' * b' * c' * d) + (a' * b * c' * d) + (a * b * c * d) + (a * b' * c * d)

assign out = (!a || c) || (b || !c || d);
",-1.0,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified expression using product-of-sums form:
// out = (a' + c) + (b + c' + d)

// Simplified expression using sum-of-products form:
// out = (a' * b' * c' * d) + (a' * b * c' * d) + (a * b * c * d) + (a * b' * c * d)

assign out = (!a || c) || (b || !c || d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified expression using product-of-sums form:
// out = (a' + c) + (b + c' + d)

// Simplified expression using sum-of-products form:
// out = (a' * b' * c' * d) + (a' * b * c' * d) + (a * b * c * d) + (a * b' * c * d)

assign out = (!a || c) || (b || !c || d);
"
"// Simplified K-map in sum-of-products form:
// F = a'b'd' + a'b'c + abc' + abcd'

// Circuit implementation
assign out = (!a & !b & !d) | (!a & !b & c) | (a & b & !c) | (a & b & c & d);
",-1.0,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
// Simplified K-map in sum-of-products form:
// F = a'b'd' + a'b'c + abc' + abcd'

// Circuit implementation
assign out = (!a & !b & !d) | (!a & !b & c) | (a & b & !c) | (a & b & c & d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
// Simplified K-map in sum-of-products form:
// F = a'b'd' + a'b'c + abc' + abcd'

// Circuit implementation
assign out = (!a & !b & !d) | (!a & !b & c) | (a & b & !c) | (a & b & c & d);
"
"// Simplified expression in sum-of-products form:
// out = a'b' + b'c + bc' + cd

// Simplified expression in product-of-sums form:
// out = (a + b + c')(b' + c + d')(b' + c' + d)
",-1.0,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
// Simplified expression in sum-of-products form:
// out = a'b' + b'c + bc' + cd

// Simplified expression in product-of-sums form:
// out = (a + b + c')(b' + c + d')(b' + c' + d)
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
// Simplified expression in sum-of-products form:
// out = a'b' + b'c + bc' + cd

// Simplified expression in product-of-sums form:
// out = (a + b + c')(b' + c + d')(b' + c' + d)
"
"
// Simplified sum-of-products form:
// F = a'b'd' + a'b'c + abc + ab'c

// Circuit implementation:
assign out = (!a & !b & !d) | (!a & !b & c) | (a & b & c) | (a & !b & c);
",-1.0,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified sum-of-products form:
// F = a'b'd' + a'b'c + abc + ab'c

// Circuit implementation:
assign out = (!a & !b & !d) | (!a & !b & c) | (a & b & c) | (a & !b & c);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified sum-of-products form:
// F = a'b'd' + a'b'c + abc + ab'c

// Circuit implementation:
assign out = (!a & !b & !d) | (!a & !b & c) | (a & b & c) | (a & !b & c);
"
"
// Simplified expression in sum-of-products form:
// f = a'b'c'd' + a'b'cd + abcd' + abc'd

// Circuit implementation:
assign out = (~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (a & b & c & ~d) | (a & b & ~c & d);
",-1.0,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified expression in sum-of-products form:
// f = a'b'c'd' + a'b'cd + abcd' + abc'd

// Circuit implementation:
assign out = (~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (a & b & c & ~d) | (a & b & ~c & d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified expression in sum-of-products form:
// f = a'b'c'd' + a'b'cd + abcd' + abc'd

// Circuit implementation:
assign out = (~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (a & b & c & ~d) | (a & b & ~c & d);
"
"// Simplified Karnaugh map:
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Simplified expression:
// out = a'b'c'd' + a'bcd + ab'cd' + abcd'

// Circuit implementation:
assign out = (~a & ~b & ~c & ~d) | (~a & b & c & d) | (a & ~b & c & ~d) | (a & b & c & d);
",-1.0,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
// Simplified Karnaugh map:
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Simplified expression:
// out = a'b'c'd' + a'bcd + ab'cd' + abcd'

// Circuit implementation:
assign out = (~a & ~b & ~c & ~d) | (~a & b & c & d) | (a & ~b & c & ~d) | (a & b & c & d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
// Simplified Karnaugh map:
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Simplified expression:
// out = a'b'c'd' + a'bcd + ab'cd' + abcd'

// Circuit implementation:
assign out = (~a & ~b & ~c & ~d) | (~a & b & c & d) | (a & ~b & c & ~d) | (a & b & c & d);
"
"
  assign out = (a & b & c & d') | (a & b' & c' & d) | (a & b' & c & d) | (a & b' & c & d') | (a & b & c' & d) | (a & b & c' & d'); 
endmodule
",-1.0,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

  assign out = (a & b & c & d') | (a & b' & c' & d) | (a & b' & c & d) | (a & b' & c & d') | (a & b & c' & d) | (a & b & c' & d'); 
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

  assign out = (a & b & c & d') | (a & b' & c' & d) | (a & b' & c & d) | (a & b' & c & d') | (a & b & c' & d) | (a & b & c' & d'); 
endmodule
"
"
  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = !a & b & !c & d;
  assign minterm2 = a & !b & c & !d;
  assign minterm3 = !a & b & c & !d;
  assign minterm4 = a & !b & !c & d;

  assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = !a & b & !c & d;
  assign minterm2 = a & !b & c & !d;
  assign minterm3 = !a & b & c & !d;
  assign minterm4 = a & !b & !c & d;

  assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = !a & b & !c & d;
  assign minterm2 = a & !b & c & !d;
  assign minterm3 = !a & b & c & !d;
  assign minterm4 = a & !b & !c & d;

  assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
"
"
    assign out = (!a & !b & !c & d) | (!a & b & c & !d) | (a & b & !c & d) | (a & !b & c & !d);
endmodule
",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    assign out = (!a & !b & !c & d) | (!a & b & c & !d) | (a & b & !c & d) | (a & !b & c & !d);
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    assign out = (!a & !b & !c & d) | (!a & b & c & !d) | (a & b & !c & d) | (a & !b & c & !d);
endmodule
"
"
    wire minterm1, minterm2, minterm3, minterm4;

    // Implementing the simplified circuit in sum-of-products form
    assign minterm1 = !a & !b & c & !d;
    assign minterm2 = !a & b & !c & d;
    assign minterm3 = a & b & c & !d;
    assign minterm4 = a & !b & !c & d;

    // Final output is the OR of all minterms
    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    wire minterm1, minterm2, minterm3, minterm4;

    // Implementing the simplified circuit in sum-of-products form
    assign minterm1 = !a & !b & c & !d;
    assign minterm2 = !a & b & !c & d;
    assign minterm3 = a & b & c & !d;
    assign minterm4 = a & !b & !c & d;

    // Final output is the OR of all minterms
    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    wire minterm1, minterm2, minterm3, minterm4;

    // Implementing the simplified circuit in sum-of-products form
    assign minterm1 = !a & !b & c & !d;
    assign minterm2 = !a & b & !c & d;
    assign minterm3 = a & b & c & !d;
    assign minterm4 = a & !b & !c & d;

    // Final output is the OR of all minterms
    assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
"
"
    assign out = (!a & !b & c & d) | (!a & b & !c & d) | (a & !b & c & !d) | (a & b & !c & !d);
endmodule
",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    assign out = (!a & !b & c & d) | (!a & b & !c & d) | (a & !b & c & !d) | (a & b & !c & !d);
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

    assign out = (!a & !b & c & d) | (!a & b & !c & d) | (a & !b & c & !d) | (a & b & !c & !d);
endmodule
"
"
// Simplified circuit in product-of-sums form
assign out = (!a && !b && c && d) || (!a && b && !c && d) || (a && !b && c && !d) || (a && b && !c && !d);

// Simplified circuit in sum-of-products form
assign out = (!a || b || !c || d) && (!a || !b || c || d) && (a || !b || c || !d) && (a || b || !c || !d);
",-1.0,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified circuit in product-of-sums form
assign out = (!a && !b && c && d) || (!a && b && !c && d) || (a && !b && c && !d) || (a && b && !c && !d);

// Simplified circuit in sum-of-products form
assign out = (!a || b || !c || d) && (!a || !b || c || d) && (a || !b || c || !d) && (a || b || !c || !d);
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

// Simplified circuit in product-of-sums form
assign out = (!a && !b && c && d) || (!a && b && !c && d) || (a && !b && c && !d) || (a && b && !c && !d);

// Simplified circuit in sum-of-products form
assign out = (!a || b || !c || d) && (!a || !b || c || d) && (a || !b || c || !d) && (a || b || !c || !d);
"
"
  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = !a & !b & c & !d;
  assign minterm2 = !a & b & !c & d;
  assign minterm3 = a & b & c & d;
  assign minterm4 = a & !b & c & !d;

  assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = !a & !b & c & !d;
  assign minterm2 = !a & b & !c & d;
  assign minterm3 = a & b & c & d;
  assign minterm4 = a & !b & c & !d;

  assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

  wire minterm1, minterm2, minterm3, minterm4;

  // Implementing the simplified circuit in sum-of-products form
  assign minterm1 = !a & !b & c & !d;
  assign minterm2 = !a & b & !c & d;
  assign minterm3 = a & b & c & d;
  assign minterm4 = a & !b & c & !d;

  assign out = minterm1 | minterm2 | minterm3 | minterm4;
endmodule
"
"
  assign out = (a & b & c & d) | (a & b & !c & !d) | (!a & !b & c & d) | (!a & !b & !c & !d);
endmodule
",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

  assign out = (a & b & c & d) | (a & b & !c & !d) | (!a & !b & c & d) | (!a & !b & !c & !d);
endmodule
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );

  assign out = (a & b & c & d) | (a & b & !c & !d) | (!a & !b & c & d) | (!a & !b & !c & !d);
endmodule
"
"
    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
"
"    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
"
"
    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end

    assign q = state;
endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end

    assign q = state;
endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end

    assign q = state;
endmodule
"
"
    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;

    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
"
"
    reg [31:0] state;
    reg [31:0] next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        next_state[0] = state[31] ^ state[21] ^ state[1] ^ state[0];
        next_state[1] = state[0];
        next_state[2] = state[1];
        for (int i = 3; i < 32; i = i + 1) begin
            next_state[i] = state[i-1];
        end
    end

    assign q = state;
endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;
    reg [31:0] next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        next_state[0] = state[31] ^ state[21] ^ state[1] ^ state[0];
        next_state[1] = state[0];
        next_state[2] = state[1];
        for (int i = 3; i < 32; i = i + 1) begin
            next_state[i] = state[i-1];
        end
    end

    assign q = state;
endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;
    reg [31:0] next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        next_state[0] = state[31] ^ state[21] ^ state[1] ^ state[0];
        next_state[1] = state[0];
        next_state[2] = state[1];
        for (int i = 3; i < 32; i = i + 1) begin
            next_state[i] = state[i-1];
        end
    end

    assign q = state;
endmodule
"
"
    reg [31:0] state;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end
    
    assign q = state;
    
endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end
    
    assign q = state;
    
endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30]^state[20]^state[0]^state[31], state[31:1]};
        end
    end
    
    assign q = state;
    
endmodule
"
"    reg [31:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
    reg [31:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
    reg [31:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end

    assign q = state;

endmodule
"
"    reg [31:0] state;
    reg [31:0] next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        next_state[0] = state[31] ^ state[21] ^ state[1] ^ state[0];
        next_state[1] = state[0];
        next_state[2] = state[1];
        next_state[3] = state[2];
        // Continue for all 32 bits with appropriate taps
        // Make sure to follow the correct bit positions for the taps
    end

    assign q = state;
endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
    reg [31:0] state;
    reg [31:0] next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        next_state[0] = state[31] ^ state[21] ^ state[1] ^ state[0];
        next_state[1] = state[0];
        next_state[2] = state[1];
        next_state[3] = state[2];
        // Continue for all 32 bits with appropriate taps
        // Make sure to follow the correct bit positions for the taps
    end

    assign q = state;
endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
    reg [31:0] state;
    reg [31:0] next_state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= next_state;
        end
    end

    always @* begin
        next_state[0] = state[31] ^ state[21] ^ state[1] ^ state[0];
        next_state[1] = state[0];
        next_state[2] = state[1];
        next_state[3] = state[2];
        // Continue for all 32 bits with appropriate taps
        // Make sure to follow the correct bit positions for the taps
    end

    assign q = state;
endmodule
"
"
    reg [31:0] state; // 32-bit state register
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1; // Initialize state to 32'h1 on reset
        end else begin
            // Calculate new state using XOR of taps
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end
    
    assign q = state; // Output state as q
endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state; // 32-bit state register
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1; // Initialize state to 32'h1 on reset
        end else begin
            // Calculate new state using XOR of taps
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end
    
    assign q = state; // Output state as q
endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state; // 32-bit state register
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 32'h1; // Initialize state to 32'h1 on reset
        end else begin
            // Calculate new state using XOR of taps
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end
    
    assign q = state; // Output state as q
endmodule
"
"
    reg [31:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end
    
    assign q = state;

endmodule
",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end
    
    assign q = state;

endmodule
","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);

    reg [31:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 32'h1;
        end else begin
            state <= {state[30] ^ state[20] ^ state[0] ^ state[31], state[31:1]};
        end
    end
    
    assign q = state;

endmodule
"
"    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
"
"    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
"
"    wire [15:0] lower_sum;
    wire lower_cout;
    wire [15:0] upper_sum;
    wire upper_cout;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout(lower_cout));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(lower_cout), .sum(upper_sum), .cout(upper_cout));

    assign sum = {upper_sum, lower_sum};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] lower_sum;
    wire lower_cout;
    wire [15:0] upper_sum;
    wire upper_cout;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout(lower_cout));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(lower_cout), .sum(upper_sum), .cout(upper_cout));

    assign sum = {upper_sum, lower_sum};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] lower_sum;
    wire lower_cout;
    wire [15:0] upper_sum;
    wire upper_cout;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout(lower_cout));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(lower_cout), .sum(upper_sum), .cout(upper_cout));

    assign sum = {upper_sum, lower_sum};
endmodule
"
"    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout());
    
    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout());
    
    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout());
    
    assign sum = {sum2, sum1};
endmodule
"
"    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
"
"    wire [15:0] sum1;
    wire [15:0] sum2;
    wire cout1;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout());

    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire [15:0] sum2;
    wire cout1;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout());

    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire [15:0] sum2;
    wire cout1;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout());

    assign sum = {sum2, sum1};
endmodule
"
"    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
"
"    wire [15:0] sum1;
    wire [15:0] sum2;
    wire cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout2));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout2), .sum(sum2), .cout());
    
    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire [15:0] sum2;
    wire cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout2));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout2), .sum(sum2), .cout());
    
    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire [15:0] sum2;
    wire cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout2));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout2), .sum(sum2), .cout());
    
    assign sum = {sum2, sum1};
endmodule
"
"    wire [15:0] sum1;
    wire cout1;
    
    wire [15:0] sum2;
    wire cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));
    
    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    
    wire [15:0] sum2;
    wire cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));
    
    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    
    wire [15:0] sum2;
    wire cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));
    
    assign sum = {sum2, sum1};
endmodule
"
"    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .sum(sum2), .cout(cout2));

    assign sum = {sum2, sum1};
endmodule
"
"
    wire [15:0] a_upper = a[31:16];
    wire [15:0] a_lower = a[15:0];
    wire [15:0] b_upper = b[31:16];
    wire [15:0] b_lower = b[15:0];
    wire cin;

    // Invert b when sub is 1 using XOR gate
    wire [15:0] inverted_b_upper;
    wire [15:0] inverted_b_lower;
    wire inverted_sub;
    assign inverted_sub = sub;
    assign inverted_b_upper = b_upper ^ inverted_sub;
    assign inverted_b_lower = b_lower ^ inverted_sub;

    // Instantiate add16 module for upper 16 bits
    add16 adder_upper(
        .a(a_upper),
        .b(inverted_b_upper),
        .cin(cin),
        .sum(sum[31:16]),
        .cout()
    );

    // Connect sub input to carry-in of the adder
    assign cin = sub;

    // Instantiate add16 module for lower 16 bits
    add16 adder_lower(
        .a(a_lower),
        .b(inverted_b_lower),
        .cin(),
        .sum(sum[15:0]),
        .cout()
    );
endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire [15:0] a_upper = a[31:16];
    wire [15:0] a_lower = a[15:0];
    wire [15:0] b_upper = b[31:16];
    wire [15:0] b_lower = b[15:0];
    wire cin;

    // Invert b when sub is 1 using XOR gate
    wire [15:0] inverted_b_upper;
    wire [15:0] inverted_b_lower;
    wire inverted_sub;
    assign inverted_sub = sub;
    assign inverted_b_upper = b_upper ^ inverted_sub;
    assign inverted_b_lower = b_lower ^ inverted_sub;

    // Instantiate add16 module for upper 16 bits
    add16 adder_upper(
        .a(a_upper),
        .b(inverted_b_upper),
        .cin(cin),
        .sum(sum[31:16]),
        .cout()
    );

    // Connect sub input to carry-in of the adder
    assign cin = sub;

    // Instantiate add16 module for lower 16 bits
    add16 adder_lower(
        .a(a_lower),
        .b(inverted_b_lower),
        .cin(),
        .sum(sum[15:0]),
        .cout()
    );
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire [15:0] a_upper = a[31:16];
    wire [15:0] a_lower = a[15:0];
    wire [15:0] b_upper = b[31:16];
    wire [15:0] b_lower = b[15:0];
    wire cin;

    // Invert b when sub is 1 using XOR gate
    wire [15:0] inverted_b_upper;
    wire [15:0] inverted_b_lower;
    wire inverted_sub;
    assign inverted_sub = sub;
    assign inverted_b_upper = b_upper ^ inverted_sub;
    assign inverted_b_lower = b_lower ^ inverted_sub;

    // Instantiate add16 module for upper 16 bits
    add16 adder_upper(
        .a(a_upper),
        .b(inverted_b_upper),
        .cin(cin),
        .sum(sum[31:16]),
        .cout()
    );

    // Connect sub input to carry-in of the adder
    assign cin = sub;

    // Instantiate add16 module for lower 16 bits
    add16 adder_lower(
        .a(a_lower),
        .b(inverted_b_lower),
        .cin(),
        .sum(sum[15:0]),
        .cout()
    );
endmodule
"
"    wire [15:0] a_upper = a[31:16];
    wire [15:0] a_lower = a[15:0];
    
    wire [15:0] b_upper;
    wire [15:0] b_lower;
    
    wire cin;
    wire cout;
    
    wire [15:0] sum_upper;
    wire [15:0] sum_lower;
    
    xor #(.N(16)) xor_gate_b_upper (
        .a(b[31:16]),
        .b({16{sub}}),
        .y(b_upper)
    );
    
    xor #(.N(16)) xor_gate_b_lower (
        .a(b[15:0]),
        .b({16{sub}}),
        .y(b_lower)
    );
    
    add16 adder_upper (
        .a(a_upper),
        .b(b_upper),
        .cin(cin),
        .sum(sum_upper),
        .cout()
    );
    
    add16 adder_lower (
        .a(a_lower),
        .b(b_lower),
        .cin(adder_upper.cout),
        .sum(sum_lower),
        .cout(cout)
    );
    
    assign sum = {sum_upper, sum_lower};
endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a_upper = a[31:16];
    wire [15:0] a_lower = a[15:0];
    
    wire [15:0] b_upper;
    wire [15:0] b_lower;
    
    wire cin;
    wire cout;
    
    wire [15:0] sum_upper;
    wire [15:0] sum_lower;
    
    xor #(.N(16)) xor_gate_b_upper (
        .a(b[31:16]),
        .b({16{sub}}),
        .y(b_upper)
    );
    
    xor #(.N(16)) xor_gate_b_lower (
        .a(b[15:0]),
        .b({16{sub}}),
        .y(b_lower)
    );
    
    add16 adder_upper (
        .a(a_upper),
        .b(b_upper),
        .cin(cin),
        .sum(sum_upper),
        .cout()
    );
    
    add16 adder_lower (
        .a(a_lower),
        .b(b_lower),
        .cin(adder_upper.cout),
        .sum(sum_lower),
        .cout(cout)
    );
    
    assign sum = {sum_upper, sum_lower};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a_upper = a[31:16];
    wire [15:0] a_lower = a[15:0];
    
    wire [15:0] b_upper;
    wire [15:0] b_lower;
    
    wire cin;
    wire cout;
    
    wire [15:0] sum_upper;
    wire [15:0] sum_lower;
    
    xor #(.N(16)) xor_gate_b_upper (
        .a(b[31:16]),
        .b({16{sub}}),
        .y(b_upper)
    );
    
    xor #(.N(16)) xor_gate_b_lower (
        .a(b[15:0]),
        .b({16{sub}}),
        .y(b_lower)
    );
    
    add16 adder_upper (
        .a(a_upper),
        .b(b_upper),
        .cin(cin),
        .sum(sum_upper),
        .cout()
    );
    
    add16 adder_lower (
        .a(a_lower),
        .b(b_lower),
        .cin(adder_upper.cout),
        .sum(sum_lower),
        .cout(cout)
    );
    
    assign sum = {sum_upper, sum_lower};
endmodule
"
"    wire [15:0] a_low, a_high, b_low, b_high;
    wire cin, cout;
    wire [15:0] sum_low, sum_high;

    // Split the inputs into low and high halves
    assign a_low = a[15:0];
    assign a_high = a[31:16];
    assign b_low = b[15:0] ^ sub;
    assign b_high = b[31:16] ^ sub;

    // Instantiate the adder-subtractor for the low half
    add16 adder_low (
        .a(a_low),
        .b(b_low),
        .cin(cin),
        .sum(sum_low),
        .cout()
    );

    // Instantiate the adder-subtractor for the high half
    add16 adder_high (
        .a(a_high),
        .b(b_high),
        .cin(adder_low.cout),
        .sum(sum_high),
        .cout(cout)
    );

    // Combine the low and high halves to get the final sum
    assign sum = {sum_high, sum_low};
endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a_low, a_high, b_low, b_high;
    wire cin, cout;
    wire [15:0] sum_low, sum_high;

    // Split the inputs into low and high halves
    assign a_low = a[15:0];
    assign a_high = a[31:16];
    assign b_low = b[15:0] ^ sub;
    assign b_high = b[31:16] ^ sub;

    // Instantiate the adder-subtractor for the low half
    add16 adder_low (
        .a(a_low),
        .b(b_low),
        .cin(cin),
        .sum(sum_low),
        .cout()
    );

    // Instantiate the adder-subtractor for the high half
    add16 adder_high (
        .a(a_high),
        .b(b_high),
        .cin(adder_low.cout),
        .sum(sum_high),
        .cout(cout)
    );

    // Combine the low and high halves to get the final sum
    assign sum = {sum_high, sum_low};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a_low, a_high, b_low, b_high;
    wire cin, cout;
    wire [15:0] sum_low, sum_high;

    // Split the inputs into low and high halves
    assign a_low = a[15:0];
    assign a_high = a[31:16];
    assign b_low = b[15:0] ^ sub;
    assign b_high = b[31:16] ^ sub;

    // Instantiate the adder-subtractor for the low half
    add16 adder_low (
        .a(a_low),
        .b(b_low),
        .cin(cin),
        .sum(sum_low),
        .cout()
    );

    // Instantiate the adder-subtractor for the high half
    add16 adder_high (
        .a(a_high),
        .b(b_high),
        .cin(adder_low.cout),
        .sum(sum_high),
        .cout(cout)
    );

    // Combine the low and high halves to get the final sum
    assign sum = {sum_high, sum_low};
endmodule
"
"wire [15:0] a_inverted;
wire [15:0] b_inverted;

assign a_inverted = sub ? ~a[15:0] : a[15:0];
assign b_inverted = sub ? b[15:0] ^ 16'hFFFF : b[15:0] ;

add16 adder1 (
    .a(a_inverted),
    .b(b_inverted),
    .cin(sub),
    .sum(sum[15:0]),
    .cout()
);

add16 adder2 (
    .a(a[31:16]),
    .b(b[31:16]),
    .cin(adder1.cout),
    .sum(sum[31:16]),
    .cout()
);

endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
wire [15:0] a_inverted;
wire [15:0] b_inverted;

assign a_inverted = sub ? ~a[15:0] : a[15:0];
assign b_inverted = sub ? b[15:0] ^ 16'hFFFF : b[15:0] ;

add16 adder1 (
    .a(a_inverted),
    .b(b_inverted),
    .cin(sub),
    .sum(sum[15:0]),
    .cout()
);

add16 adder2 (
    .a(a[31:16]),
    .b(b[31:16]),
    .cin(adder1.cout),
    .sum(sum[31:16]),
    .cout()
);

endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
wire [15:0] a_inverted;
wire [15:0] b_inverted;

assign a_inverted = sub ? ~a[15:0] : a[15:0];
assign b_inverted = sub ? b[15:0] ^ 16'hFFFF : b[15:0] ;

add16 adder1 (
    .a(a_inverted),
    .b(b_inverted),
    .cin(sub),
    .sum(sum[15:0]),
    .cout()
);

add16 adder2 (
    .a(a[31:16]),
    .b(b[31:16]),
    .cin(adder1.cout),
    .sum(sum[31:16]),
    .cout()
);

endmodule
"
"wire [15:0] a1, b1, sum1;
wire cin1, cout1;

// Instantiate the first adder module
add16 adder1 (.a(a[15:0]), .b(b[15:0] ^ sub, .cin(sub), .sum(sum1), .cout(cout1));

// Instantiate the second adder module
add16 adder2 (.a(a[31:16]), .b(b[31:16] ^ sub, .cin(cout1), .sum(sum[15:0]), .cout());
    
endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
wire [15:0] a1, b1, sum1;
wire cin1, cout1;

// Instantiate the first adder module
add16 adder1 (.a(a[15:0]), .b(b[15:0] ^ sub, .cin(sub), .sum(sum1), .cout(cout1));

// Instantiate the second adder module
add16 adder2 (.a(a[31:16]), .b(b[31:16] ^ sub, .cin(cout1), .sum(sum[15:0]), .cout());
    
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
wire [15:0] a1, b1, sum1;
wire cin1, cout1;

// Instantiate the first adder module
add16 adder1 (.a(a[15:0]), .b(b[15:0] ^ sub, .cin(sub), .sum(sum1), .cout(cout1));

// Instantiate the second adder module
add16 adder2 (.a(a[31:16]), .b(b[31:16] ^ sub, .cin(cout1), .sum(sum[15:0]), .cout());
    
endmodule
"
"wire [15:0] a_0, a_1, b_0, b_1;
wire cin_0, cin_1;
wire cout_0, cout_1;

// Split the 32-bit inputs into two 16-bit inputs
assign a_0 = a[15:0];
assign a_1 = a[31:16];
assign b_0 = b[15:0] ^ sub;
assign b_1 = b[31:16] ^ sub;

// Instantiate the adder module twice
add16 adder_0 (.a(a_0), .b(b_0), .cin(cin_0), .sum(sum[15:0]), .cout(cout_0));
add16 adder_1 (.a(a_1), .b(b_1), .cin(cout_0), .sum(sum[31:16]), .cout(cout_1));

endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
wire [15:0] a_0, a_1, b_0, b_1;
wire cin_0, cin_1;
wire cout_0, cout_1;

// Split the 32-bit inputs into two 16-bit inputs
assign a_0 = a[15:0];
assign a_1 = a[31:16];
assign b_0 = b[15:0] ^ sub;
assign b_1 = b[31:16] ^ sub;

// Instantiate the adder module twice
add16 adder_0 (.a(a_0), .b(b_0), .cin(cin_0), .sum(sum[15:0]), .cout(cout_0));
add16 adder_1 (.a(a_1), .b(b_1), .cin(cout_0), .sum(sum[31:16]), .cout(cout_1));

endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
wire [15:0] a_0, a_1, b_0, b_1;
wire cin_0, cin_1;
wire cout_0, cout_1;

// Split the 32-bit inputs into two 16-bit inputs
assign a_0 = a[15:0];
assign a_1 = a[31:16];
assign b_0 = b[15:0] ^ sub;
assign b_1 = b[31:16] ^ sub;

// Instantiate the adder module twice
add16 adder_0 (.a(a_0), .b(b_0), .cin(cin_0), .sum(sum[15:0]), .cout(cout_0));
add16 adder_1 (.a(a_1), .b(b_1), .cin(cout_0), .sum(sum[31:16]), .cout(cout_1));

endmodule
"
"    wire [15:0] a_low, b_low, sum_low;
    wire cin, cout;
    
    // Instantiate the add16 module for the lower 16 bits
    add16 adder1 (.a(a_low), .b(b_low), .cin(cin), .sum(sum_low), .cout(cout));
    
    // Instantiate the add16 module for the higher 16 bits
    add16 adder2 (.a(a[31:16] ^ sub), .b(b[31:16] ^ sub), .cin(sub), .sum(sum[31:16]), .cout());
    
    // Connect the lower 16 bits of a and b
    assign a_low = a[15:0];
    assign b_low = b[15:0];
    
    // Concatenate the sum of lower and higher 16 bits
    assign sum = {sum[31:16], sum_low};
endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a_low, b_low, sum_low;
    wire cin, cout;
    
    // Instantiate the add16 module for the lower 16 bits
    add16 adder1 (.a(a_low), .b(b_low), .cin(cin), .sum(sum_low), .cout(cout));
    
    // Instantiate the add16 module for the higher 16 bits
    add16 adder2 (.a(a[31:16] ^ sub), .b(b[31:16] ^ sub), .cin(sub), .sum(sum[31:16]), .cout());
    
    // Connect the lower 16 bits of a and b
    assign a_low = a[15:0];
    assign b_low = b[15:0];
    
    // Concatenate the sum of lower and higher 16 bits
    assign sum = {sum[31:16], sum_low};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a_low, b_low, sum_low;
    wire cin, cout;
    
    // Instantiate the add16 module for the lower 16 bits
    add16 adder1 (.a(a_low), .b(b_low), .cin(cin), .sum(sum_low), .cout(cout));
    
    // Instantiate the add16 module for the higher 16 bits
    add16 adder2 (.a(a[31:16] ^ sub), .b(b[31:16] ^ sub), .cin(sub), .sum(sum[31:16]), .cout());
    
    // Connect the lower 16 bits of a and b
    assign a_low = a[15:0];
    assign b_low = b[15:0];
    
    // Concatenate the sum of lower and higher 16 bits
    assign sum = {sum[31:16], sum_low};
endmodule
"
"wire [15:0] a1, b1, a2, b2;
wire cin1, cin2;
wire [15:0] sum1, sum2;
wire cout1, cout2;

assign {b1, b2} = sub ? ~b : b;

add16 adder1 (.a(a[15:0]), .b(b1), .cin(cin1), .sum(sum1), .cout(cout1));
add16 adder2 (.a(a[31:16]), .b(b2), .cin(cin2), .sum(sum2), .cout(cout2));

assign sum = {sum2, sum1}; // Concatenate the outputs of the two adders to get the final sum

assign cin1 = sub;
assign cin2 = cout1; // Connect the carry-out of the first adder to the carry-in of the second adder

endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
wire [15:0] a1, b1, a2, b2;
wire cin1, cin2;
wire [15:0] sum1, sum2;
wire cout1, cout2;

assign {b1, b2} = sub ? ~b : b;

add16 adder1 (.a(a[15:0]), .b(b1), .cin(cin1), .sum(sum1), .cout(cout1));
add16 adder2 (.a(a[31:16]), .b(b2), .cin(cin2), .sum(sum2), .cout(cout2));

assign sum = {sum2, sum1}; // Concatenate the outputs of the two adders to get the final sum

assign cin1 = sub;
assign cin2 = cout1; // Connect the carry-out of the first adder to the carry-in of the second adder

endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
wire [15:0] a1, b1, a2, b2;
wire cin1, cin2;
wire [15:0] sum1, sum2;
wire cout1, cout2;

assign {b1, b2} = sub ? ~b : b;

add16 adder1 (.a(a[15:0]), .b(b1), .cin(cin1), .sum(sum1), .cout(cout1));
add16 adder2 (.a(a[31:16]), .b(b2), .cin(cin2), .sum(sum2), .cout(cout2));

assign sum = {sum2, sum1}; // Concatenate the outputs of the two adders to get the final sum

assign cin1 = sub;
assign cin2 = cout1; // Connect the carry-out of the first adder to the carry-in of the second adder

endmodule
"
"    wire [15:0] a_lsb, a_msb, b_lsb, b_msb;
    wire cin, cout;
    wire [15:0] sum_lsb, sum_msb;

    // Split the inputs into least significant and most significant bits
    assign a_lsb = a[15:0];
    assign a_msb = a[31:16];
    assign b_lsb = b[15:0];
    assign b_msb = b[31:16];

    // Instantiate the add16 module for least significant bits
    add16 adder_lsb (
        .a(a_lsb),
        .b(sub ? ~b_lsb : b_lsb),
        .cin(cin),
        .sum(sum_lsb),
        .cout()
    );

    // Instantiate the add16 module for most significant bits
    add16 adder_msb (
        .a(a_msb),
        .b(sub ? ~b_msb : b_msb),
        .cin(adder_lsb.cout),
        .sum(sum_msb),
        .cout(cout)
    );

    // Concatenate the sum of most significant and least significant bits
    assign sum = {sum_msb, sum_lsb};
endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a_lsb, a_msb, b_lsb, b_msb;
    wire cin, cout;
    wire [15:0] sum_lsb, sum_msb;

    // Split the inputs into least significant and most significant bits
    assign a_lsb = a[15:0];
    assign a_msb = a[31:16];
    assign b_lsb = b[15:0];
    assign b_msb = b[31:16];

    // Instantiate the add16 module for least significant bits
    add16 adder_lsb (
        .a(a_lsb),
        .b(sub ? ~b_lsb : b_lsb),
        .cin(cin),
        .sum(sum_lsb),
        .cout()
    );

    // Instantiate the add16 module for most significant bits
    add16 adder_msb (
        .a(a_msb),
        .b(sub ? ~b_msb : b_msb),
        .cin(adder_lsb.cout),
        .sum(sum_msb),
        .cout(cout)
    );

    // Concatenate the sum of most significant and least significant bits
    assign sum = {sum_msb, sum_lsb};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a_lsb, a_msb, b_lsb, b_msb;
    wire cin, cout;
    wire [15:0] sum_lsb, sum_msb;

    // Split the inputs into least significant and most significant bits
    assign a_lsb = a[15:0];
    assign a_msb = a[31:16];
    assign b_lsb = b[15:0];
    assign b_msb = b[31:16];

    // Instantiate the add16 module for least significant bits
    add16 adder_lsb (
        .a(a_lsb),
        .b(sub ? ~b_lsb : b_lsb),
        .cin(cin),
        .sum(sum_lsb),
        .cout()
    );

    // Instantiate the add16 module for most significant bits
    add16 adder_msb (
        .a(a_msb),
        .b(sub ? ~b_msb : b_msb),
        .cin(adder_lsb.cout),
        .sum(sum_msb),
        .cout(cout)
    );

    // Concatenate the sum of most significant and least significant bits
    assign sum = {sum_msb, sum_lsb};
endmodule
"
"    wire [15:0] a1, b1, sum1;
    wire cout1;
    wire [15:0] a2, b2, sum2;
    wire cout2;

    // Instantiate the adder-subtractor twice
    add16 adder1(.a(a[15:0]), .b(b[15:0] ^ sub, .cin(sub), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16] ^ sub, .cin(cout1), .sum(sum2), .cout(cout2));

    // Concatenate the results
    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a1, b1, sum1;
    wire cout1;
    wire [15:0] a2, b2, sum2;
    wire cout2;

    // Instantiate the adder-subtractor twice
    add16 adder1(.a(a[15:0]), .b(b[15:0] ^ sub, .cin(sub), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16] ^ sub, .cin(cout1), .sum(sum2), .cout(cout2));

    // Concatenate the results
    assign sum = {sum2, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0] a1, b1, sum1;
    wire cout1;
    wire [15:0] a2, b2, sum2;
    wire cout2;

    // Instantiate the adder-subtractor twice
    add16 adder1(.a(a[15:0]), .b(b[15:0] ^ sub, .cin(sub), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16] ^ sub, .cin(cout1), .sum(sum2), .cout(cout2));

    // Concatenate the results
    assign sum = {sum2, sum1};
endmodule
"
"
wire [15:0] sum1, sum2, sum3;
wire cout1, cout2;

add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(sum));

assign sum = {sum3, sum2}; 

endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

wire [15:0] sum1, sum2, sum3;
wire cout1, cout2;

add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(sum));

assign sum = {sum3, sum2}; 

endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

wire [15:0] sum1, sum2, sum3;
wire cout1, cout2;

add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(sum));

assign sum = {sum3, sum2}; 

endmodule
"
"    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;
    wire [15:0] sum3;
    wire cout3;

    add16 adder1(a[15:0], b[15:0], 0, sum1, cout1);
    add16 adder2(a[31:16], b[31:16], 0, sum2, cout2);
    add16 adder3({cin, sum1}, {cin, sum2}, 0, sum3, cout3);

    assign sum = {sum3, sum2}; 
endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;
    wire [15:0] sum3;
    wire cout3;

    add16 adder1(a[15:0], b[15:0], 0, sum1, cout1);
    add16 adder2(a[31:16], b[31:16], 0, sum2, cout2);
    add16 adder3({cin, sum1}, {cin, sum2}, 0, sum3, cout3);

    assign sum = {sum3, sum2}; 
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1;
    wire cout1;
    wire [15:0] sum2;
    wire cout2;
    wire [15:0] sum3;
    wire cout3;

    add16 adder1(a[15:0], b[15:0], 0, sum1, cout1);
    add16 adder2(a[31:16], b[31:16], 0, sum2, cout2);
    add16 adder3({cin, sum1}, {cin, sum2}, 0, sum3, cout3);

    assign sum = {sum3, sum2}; 
endmodule
"
"
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b,sum2, .cin(0), .sum(sum3), .cout());

    assign sum = {sum3, sum2};
endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b,sum2, .cin(0), .sum(sum3), .cout());

    assign sum = {sum3, sum2};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b,sum2, .cin(0), .sum(sum3), .cout());

    assign sum = {sum3, sum2};
endmodule
"
"
    wire [15:0] sum1;
    wire [15:0] sum2;
    wire cout1;
    wire cout2;

    add16 add1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 add2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));

    // 2-to-1 multiplexer
    wire [15:0] final_sum;
    wire final_cout;

    assign sum = {sum2, sum1};
    assign final_sum = (cout1) ? sum2 : sum1;
    assign final_cout = (cout1) ? cout2 : cout1;

    assign sum = {final_sum, sum1};
endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire [15:0] sum1;
    wire [15:0] sum2;
    wire cout1;
    wire cout2;

    add16 add1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 add2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));

    // 2-to-1 multiplexer
    wire [15:0] final_sum;
    wire final_cout;

    assign sum = {sum2, sum1};
    assign final_sum = (cout1) ? sum2 : sum1;
    assign final_cout = (cout1) ? cout2 : cout1;

    assign sum = {final_sum, sum1};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire [15:0] sum1;
    wire [15:0] sum2;
    wire cout1;
    wire cout2;

    add16 add1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 add2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));

    // 2-to-1 multiplexer
    wire [15:0] final_sum;
    wire final_cout;

    assign sum = {sum2, sum1};
    assign final_sum = (cout1) ? sum2 : sum1;
    assign final_cout = (cout1) ? cout2 : cout1;

    assign sum = {final_sum, sum1};
endmodule
"
"    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(sum));
    
endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(sum));
    
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(sum));
    
endmodule
"
"
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(cout2));
    
    assign sum = {sum3, sum2}; 
endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(cout2));
    
    assign sum = {sum3, sum2}; 
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(cout2));
    
    assign sum = {sum3, sum2}; 
endmodule
"
"    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b,sum2, .cin(cout1), .sum(sum3), .cout());
    
    assign sum = {sum3, sum2};
endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b,sum2, .cin(cout1), .sum(sum3), .cout());
    
    assign sum = {sum3, sum2};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b,sum2, .cin(cout1), .sum(sum3), .cout());
    
    assign sum = {sum3, sum2};
endmodule
"
"    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a({cin2, sum1}), .b({cin2, sum2}), .cin(cout1), .sum(sum3), .cout(cout3));

    mux2x1 mux1(.a(sum3), .b(sum2), .sel(cout3), .out(sum[31:16]));
    mux2x1 mux2(.a(sum3), .b(sum1), .sel(cout3), .out(sum[15:0]));
endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a({cin2, sum1}), .b({cin2, sum2}), .cin(cout1), .sum(sum3), .cout(cout3));

    mux2x1 mux1(.a(sum3), .b(sum2), .sel(cout3), .out(sum[31:16]));
    mux2x1 mux2(.a(sum3), .b(sum1), .sel(cout3), .out(sum[15:0]));
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a({cin2, sum1}), .b({cin2, sum2}), .cin(cout1), .sum(sum3), .cout(cout3));

    mux2x1 mux1(.a(sum3), .b(sum2), .sel(cout3), .out(sum[31:16]));
    mux2x1 mux2(.a(sum3), .b(sum1), .sel(cout3), .out(sum[15:0]));
endmodule
"
"    wire [15:0] sum1, sum2;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));

    wire [15:0] mux_out;
    wire mux_sel;

    // 2-to-1 multiplexer
    mux_2to1 mux(.in0(sum1), .in1(sum2), .sel(mux_sel), .out(mux_out));

    assign sum = {mux_out, sum2};
endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));

    wire [15:0] mux_out;
    wire mux_sel;

    // 2-to-1 multiplexer
    mux_2to1 mux(.in0(sum1), .in1(sum2), .sel(mux_sel), .out(mux_out));

    assign sum = {mux_out, sum2};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));

    wire [15:0] mux_out;
    wire mux_sel;

    // 2-to-1 multiplexer
    mux_2to1 mux(.in0(sum1), .in1(sum2), .sel(mux_sel), .out(mux_out));

    assign sum = {mux_out, sum2};
endmodule
"
"    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(sum));

    assign sum = {sum3, sum2};
endmodule
",-1.0,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(sum));

    assign sum = {sum3, sum2};
endmodule
","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2;

    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout(cout1));
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout(cout2));
    add16 adder3(.a(sum1, .b(sum2), .cin(cout1), .sum(sum3), .cout(sum));

    assign sum = {sum3, sum2};
endmodule
"
"
    wire [15:0] sum1;
    wire [15:0] sum2;

    add16 adder1 (.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout());
    add16 adder2 (.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout());

    assign sum = {sum2, sum1};
endmodule
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] sum1;
    wire [15:0] sum2;

    add16 adder1 (.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout());
    add16 adder2 (.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout());

    assign sum = {sum2, sum1};
endmodule
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] sum1;
    wire [15:0] sum2;

    add16 adder1 (.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum1), .cout());
    add16 adder2 (.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum2), .cout());

    assign sum = {sum2, sum1};
endmodule
"
"
  wire [15:0] sum_lower;
  wire [15:0] sum_upper;
  
  add16 adder_lower(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum_lower), .cout());
  add16 adder_upper(.a(a[31:16]), .b(b[31:16]), .cin(adder_lower.cout), .sum(sum_upper), .cout());
  
  assign sum = {sum_upper, sum_lower};
  
endmodule
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


  wire [15:0] sum_lower;
  wire [15:0] sum_upper;
  
  add16 adder_lower(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum_lower), .cout());
  add16 adder_upper(.a(a[31:16]), .b(b[31:16]), .cin(adder_lower.cout), .sum(sum_upper), .cout());
  
  assign sum = {sum_upper, sum_lower};
  
endmodule
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


  wire [15:0] sum_lower;
  wire [15:0] sum_upper;
  
  add16 adder_lower(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum_lower), .cout());
  add16 adder_upper(.a(a[31:16]), .b(b[31:16]), .cin(adder_lower.cout), .sum(sum_upper), .cout());
  
  assign sum = {sum_upper, sum_lower};
  
endmodule
"
"
    wire [15:0] sum_lower;
    wire [15:0] sum_upper;
    
    add16 adder_lower(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum_lower), .cout());
    add16 adder_upper(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum_upper), .cout());
    
    assign sum = {sum_upper, sum_lower};
endmodule
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] sum_lower;
    wire [15:0] sum_upper;
    
    add16 adder_lower(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum_lower), .cout());
    add16 adder_upper(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum_upper), .cout());
    
    assign sum = {sum_upper, sum_lower};
endmodule
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] sum_lower;
    wire [15:0] sum_upper;
    
    add16 adder_lower(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum_lower), .cout());
    add16 adder_upper(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum_upper), .cout());
    
    assign sum = {sum_upper, sum_lower};
endmodule
"
"
  wire [15:0] lower_sum;
  wire [15:0] upper_sum;

  add16 lower_adder(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout());
  add16 upper_adder(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(upper_sum), .cout());

  assign sum = {upper_sum, lower_sum};
endmodule
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


  wire [15:0] lower_sum;
  wire [15:0] upper_sum;

  add16 lower_adder(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout());
  add16 upper_adder(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(upper_sum), .cout());

  assign sum = {upper_sum, lower_sum};
endmodule
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


  wire [15:0] lower_sum;
  wire [15:0] upper_sum;

  add16 lower_adder(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout());
  add16 upper_adder(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(upper_sum), .cout());

  assign sum = {upper_sum, lower_sum};
endmodule
"
"
    wire [15:0] sum_lower;
    wire [15:0] sum_upper;

    add16 adder_lower (
        .a(a[15:0]),
        .b(b[15:0]),
        .cin(0),
        .sum(sum_lower),
        .cout()
    );

    add16 adder_upper (
        .a(a[31:16]),
        .b(b[31:16]),
        .cin(0),
        .sum(sum_upper),
        .cout()
    );

    assign sum = {sum_upper, sum_lower};
endmodule
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] sum_lower;
    wire [15:0] sum_upper;

    add16 adder_lower (
        .a(a[15:0]),
        .b(b[15:0]),
        .cin(0),
        .sum(sum_lower),
        .cout()
    );

    add16 adder_upper (
        .a(a[31:16]),
        .b(b[31:16]),
        .cin(0),
        .sum(sum_upper),
        .cout()
    );

    assign sum = {sum_upper, sum_lower};
endmodule
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] sum_lower;
    wire [15:0] sum_upper;

    add16 adder_lower (
        .a(a[15:0]),
        .b(b[15:0]),
        .cin(0),
        .sum(sum_lower),
        .cout()
    );

    add16 adder_upper (
        .a(a[31:16]),
        .b(b[31:16]),
        .cin(0),
        .sum(sum_upper),
        .cout()
    );

    assign sum = {sum_upper, sum_lower};
endmodule
"
"
    wire [15:0] lower_sum;
    wire [15:0] upper_sum;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout());
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(upper_sum), .cout());
    
    assign sum = {upper_sum, lower_sum}; 

endmodule
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] lower_sum;
    wire [15:0] upper_sum;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout());
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(upper_sum), .cout());
    
    assign sum = {upper_sum, lower_sum}; 

endmodule
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] lower_sum;
    wire [15:0] upper_sum;
    
    add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout());
    add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(upper_sum), .cout());
    
    assign sum = {upper_sum, lower_sum}; 

endmodule
"
"
    wire [15:0] lower_sum;
    wire [15:0] upper_sum;

    add16 lower_adder (
        .a(a[15:0]),
        .b(b[15:0]),
        .cin(0),
        .sum(lower_sum),
        .cout()
    );

    add16 upper_adder (
        .a(a[31:16]),
        .b(b[31:16]),
        .cin(0),
        .sum(upper_sum),
        .cout()
    );

    assign sum = {upper_sum, lower_sum};
endmodule
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] lower_sum;
    wire [15:0] upper_sum;

    add16 lower_adder (
        .a(a[15:0]),
        .b(b[15:0]),
        .cin(0),
        .sum(lower_sum),
        .cout()
    );

    add16 upper_adder (
        .a(a[31:16]),
        .b(b[31:16]),
        .cin(0),
        .sum(upper_sum),
        .cout()
    );

    assign sum = {upper_sum, lower_sum};
endmodule
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] lower_sum;
    wire [15:0] upper_sum;

    add16 lower_adder (
        .a(a[15:0]),
        .b(b[15:0]),
        .cin(0),
        .sum(lower_sum),
        .cout()
    );

    add16 upper_adder (
        .a(a[31:16]),
        .b(b[31:16]),
        .cin(0),
        .sum(upper_sum),
        .cout()
    );

    assign sum = {upper_sum, lower_sum};
endmodule
"
"
    wire [15:0] lower_sum;
    wire [15:0] upper_sum;
    
    add16 adder1 (.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout());
    add16 adder2 (.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(upper_sum), .cout());
    
    assign sum = {upper_sum, lower_sum};
endmodule
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] lower_sum;
    wire [15:0] upper_sum;
    
    add16 adder1 (.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout());
    add16 adder2 (.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(upper_sum), .cout());
    
    assign sum = {upper_sum, lower_sum};
endmodule
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


    wire [15:0] lower_sum;
    wire [15:0] upper_sum;
    
    add16 adder1 (.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(lower_sum), .cout());
    add16 adder2 (.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(upper_sum), .cout());
    
    assign sum = {upper_sum, lower_sum};
endmodule
"
"// Instantiate the two add16 modules
add16 adder1 (
    .a(a[15:0]),
    .b(b[15:0]),
    .cin(0),
    .sum(sum[15:0]),
    .cout()
);

add16 adder2 (
    .a(a[31:16]),
    .b(b[31:16]),
    .cin(0),
    .sum(sum[31:16]),
    .cout()
);
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// Instantiate the two add16 modules
add16 adder1 (
    .a(a[15:0]),
    .b(b[15:0]),
    .cin(0),
    .sum(sum[15:0]),
    .cout()
);

add16 adder2 (
    .a(a[31:16]),
    .b(b[31:16]),
    .cin(0),
    .sum(sum[31:16]),
    .cout()
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// Instantiate the two add16 modules
add16 adder1 (
    .a(a[15:0]),
    .b(b[15:0]),
    .cin(0),
    .sum(sum[15:0]),
    .cout()
);

add16 adder2 (
    .a(a[31:16]),
    .b(b[31:16]),
    .cin(0),
    .sum(sum[31:16]),
    .cout()
);
"
"
  wire [15:0] sum_low;
  wire [15:0] sum_high;

  add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum_low), .cout());
  add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum_high), .cout());

  assign sum = {sum_high, sum_low};
endmodule
",-1.0,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


  wire [15:0] sum_low;
  wire [15:0] sum_high;

  add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum_low), .cout());
  add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum_high), .cout());

  assign sum = {sum_high, sum_low};
endmodule
","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);


  wire [15:0] sum_low;
  wire [15:0] sum_high;

  add16 adder1(.a(a[15:0]), .b(b[15:0]), .cin(0), .sum(sum_low), .cout());
  add16 adder2(.a(a[31:16]), .b(b[31:16]), .cin(0), .sum(sum_high), .cout());

  assign sum = {sum_high, sum_low};
endmodule
"
"mod_a mod_instance (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_instance (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_instance (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
"
"
mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
"
"
mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
"
"
mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
"
"
mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
"
"
   mod_a instance_name (
      .out1(out1),
      .out2(out2),
      .in1(a),
      .in2(b),
      .in3(c),
      .in4(d)
   );
endmodule
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

   mod_a instance_name (
      .out1(out1),
      .out2(out2),
      .in1(a),
      .in2(b),
      .in3(c),
      .in4(d)
   );
endmodule
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

   mod_a instance_name (
      .out1(out1),
      .out2(out2),
      .in1(a),
      .in2(b),
      .in3(c),
      .in4(d)
   );
endmodule
"
"mod_a inst_mod_a (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst_mod_a (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst_mod_a (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
"
"
mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
"
"
mod_a module_instance (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a module_instance (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a module_instance (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
"
"
mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
",-1.0,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

mod_a instance_name (
    .out1(out1),
    .out2(out2),
    .in1(a),
    .in2(b),
    .in3(c),
    .in4(d)
);
"
"mod_a inst_mod_a (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst_mod_a (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst_mod_a (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
"
"mod_a inst_mod_a (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst_mod_a (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst_mod_a (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
"
"mod_a mod_instance (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_instance (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_instance (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
"
"mod_a mod_inst (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_inst (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_inst (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
"
"mod_a module_instance (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a module_instance (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a module_instance (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
"
"mod_a instance_name (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a instance_name (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a instance_name (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
"
"mod_a mod_instance (out1, out2, a, b, c, d);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_instance (out1, out2, a, b, c, d);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_instance (out1, out2, a, b, c, d);
"
"mod_a mod_instance (out1, out2, a, b, c, d);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_instance (out1, out2, a, b, c, d);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a mod_instance (out1, out2, a, b, c, d);
"
"mod_a inst_mod_a (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst_mod_a (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst_mod_a (
    .output(out1),
    .output(out2),
    .input(a),
    .input(b),
    .input(c),
    .input(d)
);
"
"mod_a inst1 (out1, out2, a, b, c, d);
",-1.0,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst1 (out1, out2, a, b, c, d);
","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
mod_a inst1 (out1, out2, a, b, c, d);
"
"
  // Instantiate three instances of my_dff
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  // Instantiate three instances of my_dff
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
","module top_module ( input clk, input d, output q );

  // Instantiate three instances of my_dff
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
"
"
  my_dff dff1(clk, d, intermediate_q1);
  my_dff dff2(clk, intermediate_q1, intermediate_q2);
  my_dff dff3(clk, intermediate_q2, q);
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, intermediate_q1);
  my_dff dff2(clk, intermediate_q1, intermediate_q2);
  my_dff dff3(clk, intermediate_q2, q);
endmodule
","module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, intermediate_q1);
  my_dff dff2(clk, intermediate_q1, intermediate_q2);
  my_dff dff3(clk, intermediate_q2, q);
endmodule
"
"
  // Instantiate three instances of my_dff
  my_dff dff1 ( .clk(clk), .d(d), .q(q1) );
  my_dff dff2 ( .clk(clk), .d(q1), .q(q2) );
  my_dff dff3 ( .clk(clk), .d(q2), .q(q) );
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  // Instantiate three instances of my_dff
  my_dff dff1 ( .clk(clk), .d(d), .q(q1) );
  my_dff dff2 ( .clk(clk), .d(q1), .q(q2) );
  my_dff dff3 ( .clk(clk), .d(q2), .q(q) );
endmodule
","module top_module ( input clk, input d, output q );

  // Instantiate three instances of my_dff
  my_dff dff1 ( .clk(clk), .d(d), .q(q1) );
  my_dff dff2 ( .clk(clk), .d(q1), .q(q2) );
  my_dff dff3 ( .clk(clk), .d(q2), .q(q) );
endmodule
"
"
  wire q1, q2, q3;
  
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q3);
  
  assign q = q3;
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  wire q1, q2, q3;
  
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q3);
  
  assign q = q3;
endmodule
","module top_module ( input clk, input d, output q );

  wire q1, q2, q3;
  
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q3);
  
  assign q = q3;
endmodule
"
"
  // Instantiate three instances of my_dff
  my_dff dff1 ( .clk(clk), .d(d), .q(q1) );
  my_dff dff2 ( .clk(clk), .d(q1), .q(q2) );
  my_dff dff3 ( .clk(clk), .d(q2), .q(q) );
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  // Instantiate three instances of my_dff
  my_dff dff1 ( .clk(clk), .d(d), .q(q1) );
  my_dff dff2 ( .clk(clk), .d(q1), .q(q2) );
  my_dff dff3 ( .clk(clk), .d(q2), .q(q) );
endmodule
","module top_module ( input clk, input d, output q );

  // Instantiate three instances of my_dff
  my_dff dff1 ( .clk(clk), .d(d), .q(q1) );
  my_dff dff2 ( .clk(clk), .d(q1), .q(q2) );
  my_dff dff3 ( .clk(clk), .d(q2), .q(q) );
endmodule
"
"
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
","module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
"
"
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
","module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
"
"
  // Instantiate three instances of my_dff module
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  // Instantiate three instances of my_dff module
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
","module top_module ( input clk, input d, output q );

  // Instantiate three instances of my_dff module
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
"
"
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
","module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
"
"
  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
",-1.0,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
","module top_module ( input clk, input d, output q );

  my_dff dff1(clk, d, q1);
  my_dff dff2(clk, q1, q2);
  my_dff dff3(clk, q2, q);
endmodule
"
"    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);
    
    always @ (sel) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end
    
endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);
    
    always @ (sel) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end
    
endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);
    
    always @ (sel) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end
    
endmodule
"
"    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);

    always @ (sel)
    begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end
endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);

    always @ (sel)
    begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end
endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);

    always @ (sel)
    begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end
endmodule
"
"    wire [7:0] q1, q2, q3;
    wire [7:0] mux_out;

    my_dff8 dff1(.clk(clk), .d(d), .q(q1));
    my_dff8 dff2(.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3(.clk(clk), .d(q2), .q(q3));

    // 4-to-1 multiplexer
    always @* begin
        case(sel)
            2'b00: mux_out = d;
            2'b01: mux_out = q1;
            2'b10: mux_out = q2;
            2'b11: mux_out = q3;
        endcase
    end

    assign q = mux_out;

endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    wire [7:0] q1, q2, q3;
    wire [7:0] mux_out;

    my_dff8 dff1(.clk(clk), .d(d), .q(q1));
    my_dff8 dff2(.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3(.clk(clk), .d(q2), .q(q3));

    // 4-to-1 multiplexer
    always @* begin
        case(sel)
            2'b00: mux_out = d;
            2'b01: mux_out = q1;
            2'b10: mux_out = q2;
            2'b11: mux_out = q3;
        endcase
    end

    assign q = mux_out;

endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    wire [7:0] q1, q2, q3;
    wire [7:0] mux_out;

    my_dff8 dff1(.clk(clk), .d(d), .q(q1));
    my_dff8 dff2(.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3(.clk(clk), .d(q2), .q(q3));

    // 4-to-1 multiplexer
    always @* begin
        case(sel)
            2'b00: mux_out = d;
            2'b01: mux_out = q1;
            2'b10: mux_out = q2;
            2'b11: mux_out = q3;
        endcase
    end

    assign q = mux_out;

endmodule
"
"    wire [7:0] q1, q2, q3;
    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);
    
    always @ (sel) begin
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
    end

endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    wire [7:0] q1, q2, q3;
    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);
    
    always @ (sel) begin
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
    end

endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    wire [7:0] q1, q2, q3;
    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);
    
    always @ (sel) begin
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
    end

endmodule
"
"    my_dff8 dff1 (.clk(clk), .d(d), .q(q1));
    my_dff8 dff2 (.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3 (.clk(clk), .d(q2), .q(q3));
    
    always @* begin
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
    end

endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    my_dff8 dff1 (.clk(clk), .d(d), .q(q1));
    my_dff8 dff2 (.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3 (.clk(clk), .d(q2), .q(q3));
    
    always @* begin
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
    end

endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    my_dff8 dff1 (.clk(clk), .d(d), .q(q1));
    my_dff8 dff2 (.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3 (.clk(clk), .d(q2), .q(q3));
    
    always @* begin
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
    end

endmodule
"
"    // Instantiate three instances of my_dff8
    my_dff8 dff1 (.clk(clk), .d(d), .q(q1));
    my_dff8 dff2 (.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3 (.clk(clk), .d(q2), .q(q3));
    
    // Create a 4-to-1 multiplexer to select the output based on sel
    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end

endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    // Instantiate three instances of my_dff8
    my_dff8 dff1 (.clk(clk), .d(d), .q(q1));
    my_dff8 dff2 (.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3 (.clk(clk), .d(q2), .q(q3));
    
    // Create a 4-to-1 multiplexer to select the output based on sel
    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end

endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    // Instantiate three instances of my_dff8
    my_dff8 dff1 (.clk(clk), .d(d), .q(q1));
    my_dff8 dff2 (.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3 (.clk(clk), .d(q2), .q(q3));
    
    // Create a 4-to-1 multiplexer to select the output based on sel
    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end

endmodule
"
"    // Instantiate three instances of my_dff8
    my_dff8 dff1(.clk(clk), .d(d), .q(q1));
    my_dff8 dff2(.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3(.clk(clk), .d(q2), .q(q3));
    
    // Create a 4-to-1 multiplexer to choose output based on sel
    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d; // Output the input d
            2'b01: q <= q1; // Output after the first D flip-flop
            2'b10: q <= q2; // Output after the second D flip-flop
            2'b11: q <= q3; // Output after the third D flip-flop
        endcase
    end

endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    // Instantiate three instances of my_dff8
    my_dff8 dff1(.clk(clk), .d(d), .q(q1));
    my_dff8 dff2(.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3(.clk(clk), .d(q2), .q(q3));
    
    // Create a 4-to-1 multiplexer to choose output based on sel
    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d; // Output the input d
            2'b01: q <= q1; // Output after the first D flip-flop
            2'b10: q <= q2; // Output after the second D flip-flop
            2'b11: q <= q3; // Output after the third D flip-flop
        endcase
    end

endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    // Instantiate three instances of my_dff8
    my_dff8 dff1(.clk(clk), .d(d), .q(q1));
    my_dff8 dff2(.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3(.clk(clk), .d(q2), .q(q3));
    
    // Create a 4-to-1 multiplexer to choose output based on sel
    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d; // Output the input d
            2'b01: q <= q1; // Output after the first D flip-flop
            2'b10: q <= q2; // Output after the second D flip-flop
            2'b11: q <= q3; // Output after the third D flip-flop
        endcase
    end

endmodule
"
"    wire [7:0] q1, q2, q3;
    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);

    always @ (sel) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end

endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    wire [7:0] q1, q2, q3;
    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);

    always @ (sel) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end

endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    wire [7:0] q1, q2, q3;
    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);

    always @ (sel) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end

endmodule
"
"    // Instantiate three instances of my_dff8
    my_dff8 dff1 (.clk(clk), .d(d), .q(q1));
    my_dff8 dff2 (.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3 (.clk(clk), .d(q2), .q(q3));

    // Create a 4-to-1 multiplexer to choose output based on sel
    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end

endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    // Instantiate three instances of my_dff8
    my_dff8 dff1 (.clk(clk), .d(d), .q(q1));
    my_dff8 dff2 (.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3 (.clk(clk), .d(q2), .q(q3));

    // Create a 4-to-1 multiplexer to choose output based on sel
    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end

endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    // Instantiate three instances of my_dff8
    my_dff8 dff1 (.clk(clk), .d(d), .q(q1));
    my_dff8 dff2 (.clk(clk), .d(q1), .q(q2));
    my_dff8 dff3 (.clk(clk), .d(q2), .q(q3));

    // Create a 4-to-1 multiplexer to choose output based on sel
    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end

endmodule
"
"    wire [7:0] q1, q2, q3;
    
    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);
    
    always @ (sel)
    begin
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
    end

endmodule
",-1.0,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    wire [7:0] q1, q2, q3;
    
    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);
    
    always @ (sel)
    begin
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
    end

endmodule
","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);


    wire [7:0] q1, q2, q3;
    
    my_dff8 dff1(clk, d, q1);
    my_dff8 dff2(clk, q1, q2);
    my_dff8 dff3(clk, q2, q3);
    
    always @ (sel)
    begin
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
    end

endmodule
"
"
  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
","module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
"
"
  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
","module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
"
"
  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
","module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
"
"module mod_a (
    input in1,
    input in2,
    output out
);

// Instantiate module mod_a
mod_a instance (
    .in1(a),
    .in2(b),
    .out(out)
);

endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
module mod_a (
    input in1,
    input in2,
    output out
);

// Instantiate module mod_a
mod_a instance (
    .in1(a),
    .in2(b),
    .out(out)
);

endmodule
","module top_module ( input a, input b, output out );
module mod_a (
    input in1,
    input in2,
    output out
);

// Instantiate module mod_a
mod_a instance (
    .in1(a),
    .in2(b),
    .out(out)
);

endmodule
"
"
  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
","module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
"
"
  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
","module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
"
"module mod_a (
    input in1,
    input in2,
    output out
);

// Instantiate module mod_a
mod_a instance_name (
    .in1(a),
    .in2(b),
    .out(out)
);

endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
module mod_a (
    input in1,
    input in2,
    output out
);

// Instantiate module mod_a
mod_a instance_name (
    .in1(a),
    .in2(b),
    .out(out)
);

endmodule
","module top_module ( input a, input b, output out );
module mod_a (
    input in1,
    input in2,
    output out
);

// Instantiate module mod_a
mod_a instance_name (
    .in1(a),
    .in2(b),
    .out(out)
);

endmodule
"
"module mod_a (
  input in1,
  input in2,
  output out
);

// Instantiate mod_a
mod_a instance_name (
  .in1(a),
  .in2(b),
  .out(out)
);

endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
module mod_a (
  input in1,
  input in2,
  output out
);

// Instantiate mod_a
mod_a instance_name (
  .in1(a),
  .in2(b),
  .out(out)
);

endmodule
","module top_module ( input a, input b, output out );
module mod_a (
  input in1,
  input in2,
  output out
);

// Instantiate mod_a
mod_a instance_name (
  .in1(a),
  .in2(b),
  .out(out)
);

endmodule
"
"
  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
","module top_module ( input a, input b, output out );

  mod_a instance_name ( .in1(a), .in2(b), .out(out) );
endmodule
"
"module mod_a (
    input in1,
    input in2,
    output out
);

top_module instance_name (
    .a(in1),
    .b(in2),
    .out(out)
);

endmodule
",-1.0,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
module mod_a (
    input in1,
    input in2,
    output out
);

top_module instance_name (
    .a(in1),
    .b(in2),
    .out(out)
);

endmodule
","module top_module ( input a, input b, output out );
module mod_a (
    input in1,
    input in2,
    output out
);

top_module instance_name (
    .a(in1),
    .b(in2),
    .out(out)
);

endmodule
"
"  xor gate1 (A[0], B[0], out1);
  xor gate2 (A[1], B[1], out2);
  and gate3 (out1, out2, z);
endmodule
",-1.0,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

  xor gate1 (A[0], B[0], out1);
  xor gate2 (A[1], B[1], out2);
  and gate3 (out1, out2, z);
endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

  xor gate1 (A[0], B[0], out1);
  xor gate2 (A[1], B[1], out2);
  and gate3 (out1, out2, z);
endmodule
"
"	assign z = (A == B) ? 1 : 0;
endmodule
",1.0,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

	assign z = (A == B) ? 1 : 0;
endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

	assign z = (A == B) ? 1 : 0;
endmodule
"
"  assign z = (A == B) ? 1 : 0;
endmodule
",1.0,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

  assign z = (A == B) ? 1 : 0;
endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

  assign z = (A == B) ? 1 : 0;
endmodule
"
"  // Using XOR gate to compare the two inputs
  assign z = (A == B) ? 1'b1 : 1'b0;
endmodule
",1.0,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

  // Using XOR gate to compare the two inputs
  assign z = (A == B) ? 1'b1 : 1'b0;
endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

  // Using XOR gate to compare the two inputs
  assign z = (A == B) ? 1'b1 : 1'b0;
endmodule
"
"  // Logic to compare the two 2-bit inputs A and B
  assign z = (A == B) ? 1 : 0;
endmodule
",1.0,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

  // Logic to compare the two 2-bit inputs A and B
  assign z = (A == B) ? 1 : 0;
endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

  // Logic to compare the two 2-bit inputs A and B
  assign z = (A == B) ? 1 : 0;
endmodule
"
"  assign z = (A == B) ? 1 : 0;
endmodule
",1.0,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

  assign z = (A == B) ? 1 : 0;
endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

  assign z = (A == B) ? 1 : 0;
endmodule
"
"  // XOR gate to compare the two 2-bit inputs A and B
  wire [1:0] xor_result;
  assign xor_result = A ^ B;

  // OR gate to check if any bit in the xor_result is 1
  assign z = |xor_result;

endmodule
",-0.5,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

  // XOR gate to compare the two 2-bit inputs A and B
  wire [1:0] xor_result;
  assign xor_result = A ^ B;

  // OR gate to check if any bit in the xor_result is 1
  assign z = |xor_result;

endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

  // XOR gate to compare the two 2-bit inputs A and B
  wire [1:0] xor_result;
  assign xor_result = A ^ B;

  // OR gate to check if any bit in the xor_result is 1
  assign z = |xor_result;

endmodule
"
"  // Use XOR gate to compare the two 2-bit inputs A and B
  // If the result of the XOR gate is 0, output z should be 1
  // If the result of the XOR gate is 1, output z should be 0
  assign z = (A[1] ^ B[1]) | (A[0] ^ B[0]);
endmodule
",-0.5,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

  // Use XOR gate to compare the two 2-bit inputs A and B
  // If the result of the XOR gate is 0, output z should be 1
  // If the result of the XOR gate is 1, output z should be 0
  assign z = (A[1] ^ B[1]) | (A[0] ^ B[0]);
endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

  // Use XOR gate to compare the two 2-bit inputs A and B
  // If the result of the XOR gate is 0, output z should be 1
  // If the result of the XOR gate is 1, output z should be 0
  assign z = (A[1] ^ B[1]) | (A[0] ^ B[0]);
endmodule
"
"  xor gate1 (XOR1, A[0], B[0]);
  xor gate2 (XOR2, A[1], B[1]);
  and gate3 (AND1, XOR1, XOR2);
  assign z = AND1;
endmodule
",-0.5,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

  xor gate1 (XOR1, A[0], B[0]);
  xor gate2 (XOR2, A[1], B[1]);
  and gate3 (AND1, XOR1, XOR2);
  assign z = AND1;
endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

  xor gate1 (XOR1, A[0], B[0]);
  xor gate2 (XOR2, A[1], B[1]);
  and gate3 (AND1, XOR1, XOR2);
  assign z = AND1;
endmodule
"
"  assign z = (A == B) ? 1 : 0;
endmodule
",1.0,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

  assign z = (A == B) ? 1 : 0;
endmodule
","module top_module ( input [1:0] A, input [1:0] B, output z );

  assign z = (A == B) ? 1 : 0;
endmodule
"
"    assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

    assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

    assign z = (x ** y) & x;
endmodule
"
"  assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
"
"  assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
"
"  assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
"
"  assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
"
"  assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
"
"  assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
"
"  assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
"
"  assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
"
"  assign z = (x ** y) & x;
endmodule
",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
","module top_module (input x, input y, output z);

  assign z = (x ** y) & x;
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel];
endmodule
",1.0,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );


    assign out = in[sel];
endmodule
"
"
    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
"
"
    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
"
"
    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
"
"    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    assign out = in[sel*4 +: 4];
endmodule
"
"
    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
"
"
    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
"
"
    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
"
"
    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
"
"
    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4 +: 4];
endmodule
"
"    assign out = in[sel*4 +: 4];
endmodule
",1.0,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    assign out = in[sel*4 +: 4];
endmodule
","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    assign out = in[sel*4 +: 4];
endmodule
"
"
    assign out = (sel ? b : a);
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel ? b : a);
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel ? b : a);
endmodule
"
"
    assign out = sel ? b : a;
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = sel ? b : a;
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = sel ? b : a;
endmodule
"
"
    assign out = sel ? b : a;
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = sel ? b : a;
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = sel ? b : a;
endmodule
"
"
    assign out = sel ? b : a;
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = sel ? b : a;
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = sel ? b : a;
endmodule
"
"
    assign out = (sel == 0) ? a : b;
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel == 0) ? a : b;
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel == 0) ? a : b;
endmodule
"
"
    assign out = (sel == 1) ? b : a;
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel == 1) ? b : a;
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel == 1) ? b : a;
endmodule
"
"
    assign out = (sel ? b : a);
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel ? b : a);
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel ? b : a);
endmodule
"
"
    assign out = (sel ? b : a);
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel ? b : a);
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel ? b : a);
endmodule
"
"
    assign out = (sel == 0) ? a : b;
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel == 0) ? a : b;
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel == 0) ? a : b;
endmodule
"
"
    assign out = (sel ? b : a);
endmodule
",1.0,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel ? b : a);
endmodule
","module top_module( 
    input a, b, sel,
    output out );

    assign out = (sel ? b : a);
endmodule
"
"
    assign out = sel ? b : a;
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
"
"
    assign out = (sel ? b : a);
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = (sel ? b : a);
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = (sel ? b : a);
endmodule
"
"
    assign out = sel ? b : a;
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
"
"
    assign out = (sel ? b : a);
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = (sel ? b : a);
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = (sel ? b : a);
endmodule
"
"
    assign out = sel ? b : a;
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
"
"
    assign out = (sel ? b : a);
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = (sel ? b : a);
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = (sel ? b : a);
endmodule
"
"
    assign out = sel ? b : a;
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
"
"
    assign out = sel ? b : a;
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
"
"
    assign out = (sel ? b : a);
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = (sel ? b : a);
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = (sel ? b : a);
endmodule
"
"
    assign out = sel ? b : a;
endmodule
",1.0,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel ? b : a;
endmodule
"
"
    assign out = 
        (sel == 0) ? a :
        (sel == 1) ? b :
        (sel == 2) ? c :
        (sel == 3) ? d :
        (sel == 4) ? e :
        (sel == 5) ? f :
        (sel == 6) ? g :
        (sel == 7) ? h :
        (sel == 8) ? i :
        16'b1;
endmodule
",-0.5,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = 
        (sel == 0) ? a :
        (sel == 1) ? b :
        (sel == 2) ? c :
        (sel == 3) ? d :
        (sel == 4) ? e :
        (sel == 5) ? f :
        (sel == 6) ? g :
        (sel == 7) ? h :
        (sel == 8) ? i :
        16'b1;
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = 
        (sel == 0) ? a :
        (sel == 1) ? b :
        (sel == 2) ? c :
        (sel == 3) ? d :
        (sel == 4) ? e :
        (sel == 5) ? f :
        (sel == 6) ? g :
        (sel == 7) ? h :
        (sel == 8) ? i :
        16'b1;
endmodule
"
"
    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
",-0.5,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
"
"
    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
",-0.5,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
"
"
    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
",-0.5,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
"
"
    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'hFFFF; // Set all output bits to '1' for sel=9 to 15
endmodule
",1.0,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'hFFFF; // Set all output bits to '1' for sel=9 to 15
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'hFFFF; // Set all output bits to '1' for sel=9 to 15
endmodule
"
"
    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'hFFFF;
endmodule
",1.0,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'hFFFF;
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'hFFFF;
endmodule
"
"
    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
",-0.5,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
"
"
    assign out = 
        (sel == 0) ? a :
        (sel == 1) ? b :
        (sel == 2) ? c :
        (sel == 3) ? d :
        (sel == 4) ? e :
        (sel == 5) ? f :
        (sel == 6) ? g :
        (sel == 7) ? h :
        (sel == 8) ? i :
        16'b1;
endmodule
",-0.5,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = 
        (sel == 0) ? a :
        (sel == 1) ? b :
        (sel == 2) ? c :
        (sel == 3) ? d :
        (sel == 4) ? e :
        (sel == 5) ? f :
        (sel == 6) ? g :
        (sel == 7) ? h :
        (sel == 8) ? i :
        16'b1;
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = 
        (sel == 0) ? a :
        (sel == 1) ? b :
        (sel == 2) ? c :
        (sel == 3) ? d :
        (sel == 4) ? e :
        (sel == 5) ? f :
        (sel == 6) ? g :
        (sel == 7) ? h :
        (sel == 8) ? i :
        16'b1;
endmodule
"
"
    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
",-0.5,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = (sel == 0) ? a :
                 (sel == 1) ? b :
                 (sel == 2) ? c :
                 (sel == 3) ? d :
                 (sel == 4) ? e :
                 (sel == 5) ? f :
                 (sel == 6) ? g :
                 (sel == 7) ? h :
                 (sel == 8) ? i :
                 16'b1;
endmodule
"
"
    assign out = 
        (sel == 0) ? a :
        (sel == 1) ? b :
        (sel == 2) ? c :
        (sel == 3) ? d :
        (sel == 4) ? e :
        (sel == 5) ? f :
        (sel == 6) ? g :
        (sel == 7) ? h :
        (sel == 8) ? i :
        16'b1;
endmodule
",-0.5,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = 
        (sel == 0) ? a :
        (sel == 1) ? b :
        (sel == 2) ? c :
        (sel == 3) ? d :
        (sel == 4) ? e :
        (sel == 5) ? f :
        (sel == 6) ? g :
        (sel == 7) ? h :
        (sel == 8) ? i :
        16'b1;
endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = 
        (sel == 0) ? a :
        (sel == 1) ? b :
        (sel == 2) ? c :
        (sel == 3) ? d :
        (sel == 4) ? e :
        (sel == 5) ? f :
        (sel == 6) ? g :
        (sel == 7) ? h :
        (sel == 8) ? i :
        16'b1;
endmodule
"
"    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
"
"    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
"
"
    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );


    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );


    assign out = ~(a | b);
endmodule
"
"    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
"
"    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
"
"
    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );


    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );


    assign out = ~(a | b);
endmodule
"
"    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
"
"    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
"
"
    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );


    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );


    assign out = ~(a | b);
endmodule
"
"    assign out = ~(a | b);
endmodule
",1.0,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a | b);
endmodule
"
"    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
","module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
"
"    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203] +
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203] +
","module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203] +
"
"
    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
endmodule
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
endmodule
","module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
endmodule
"
"    assign out = 0;
    integer i;
    
    always @(*) begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = 0;
    integer i;
    
    always @(*) begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
","module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = 0;
    integer i;
    
    always @(*) begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
"
"    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203] +
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203] +
","module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203] +
"
"    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203] +
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203] +
","module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203] +
"
"
    assign out = 0;
    integer i;
    
    always @(*) begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = 0;
    integer i;
    
    always @(*) begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
","module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = 0;
    integer i;
    
    always @(*) begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
"
"    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
","module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
"
"    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
","module top_module( 
    input [254:0] in,
    output [7:0] out );
    assign out = 0;
    integer i;
    
    always @* begin
        for(i = 0; i < 255; i = i + 1) begin
            if(in[i] == 1) begin
                out = out + 1;
            end
        end
    end
    
endmodule
"
"
    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203]
",-1.0,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203]
","module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7] + in[8] + in[9] + in[10] + in[11] + in[12] + in[13] + in[14] + in[15] + in[16] + in[17] + in[18] + in[19] + in[20] + in[21] + in[22] + in[23] + in[24] + in[25] + in[26] + in[27] + in[28] + in[29] + in[30] + in[31] + in[32] + in[33] + in[34] + in[35] + in[36] + in[37] + in[38] + in[39] + in[40] + in[41] + in[42] + in[43] + in[44] + in[45] + in[46] + in[47] + in[48] + in[49] + in[50] + in[51] + in[52] + in[53] + in[54] + in[55] + in[56] + in[57] + in[58] + in[59] + in[60] + in[61] + in[62] + in[63] + in[64] + in[65] + in[66] + in[67] + in[68] + in[69] + in[70] + in[71] + in[72] + in[73] + in[74] + in[75] + in[76] + in[77] + in[78] + in[79] + in[80] + in[81] + in[82] + in[83] + in[84] + in[85] + in[86] + in[87] + in[88] + in[89] + in[90] + in[91] + in[92] + in[93] + in[94] + in[95] + in[96] + in[97] + in[98] + in[99] + in[100] + in[101] + in[102] + in[103] + in[104] + in[105] + in[106] + in[107] + in[108] + in[109] + in[110] + in[111] + in[112] + in[113] + in[114] + in[115] + in[116] + in[117] + in[118] + in[119] + in[120] + in[121] + in[122] + in[123] + in[124] + in[125] + in[126] + in[127] + in[128] + in[129] + in[130] + in[131] + in[132] + in[133] + in[134] + in[135] + in[136] + in[137] + in[138] + in[139] + in[140] + in[141] + in[142] + in[143] + in[144] + in[145] + in[146] + in[147] + in[148] + in[149] + in[150] + in[151] + in[152] + in[153] + in[154] + in[155] + in[156] + in[157] + in[158] + in[159] + in[160] + in[161] + in[162] + in[163] + in[164] + in[165] + in[166] + in[167] + in[168] + in[169] + in[170] + in[171] + in[172] + in[173] + in[174] + in[175] + in[176] + in[177] + in[178] + in[179] + in[180] + in[181] + in[182] + in[183] + in[184] + in[185] + in[186] + in[187] + in[188] + in[189] + in[190] + in[191] + in[192] + in[193] + in[194] + in[195] + in[196] + in[197] + in[198] + in[199] + in[200] + in[201] + in[202] + in[203]
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign out = in[0] + in[1] + in[2];
endmodule
",1.0,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
","module top_module( 
    input [2:0] in,
    output [1:0] out );

    assign out = in[0] + in[1] + in[2];
endmodule
"
"    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
","module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
"
"    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
","module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
"
"    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
","module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
"
"    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
","module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
"
"    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7]; 
endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7]; 
endmodule
","module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7]; 
endmodule
"
"    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
","module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
"
"    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
","module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
"
"    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
","module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
"
"    wire parity_bit;

    assign parity_bit = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
    assign parity = parity_bit;

endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    wire parity_bit;

    assign parity_bit = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
    assign parity = parity_bit;

endmodule
","module top_module (
    input [7:0] in,
    output parity);


    wire parity_bit;

    assign parity_bit = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
    assign parity = parity_bit;

endmodule
"
"    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
",1.0,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
","module top_module (
    input [7:0] in,
    output parity);


    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];
endmodule
"
"assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
",-0.5,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
"
"assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ring;
",-1.0,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ring;
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ring;
"
"assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
",-0.5,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
"
"assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
",-0.5,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
"
"
assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
",-0.5,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);




assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);




assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
"
"// Assign statements to control the ringer and motor based on the inputs

assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
",-0.5,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



// Assign statements to control the ringer and motor based on the inputs

assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



// Assign statements to control the ringer and motor based on the inputs

assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
"
"assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
",-0.5,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
"
"// Define a wire to represent the condition when the phone is in vibrate mode
wire phone_in_vibrate_mode;

// Use an assign statement to set the value of phone_in_vibrate_mode based on the input vibrate_mode
assign phone_in_vibrate_mode = vibrate_mode;

// Use an assign statement to set the value of the ringer output based on the inputs
assign ringer = (phone_in_vibrate_mode) ? 0 : ring;

// Use an assign statement to set the value of the motor output based on the inputs
assign motor = (phone_in_vibrate_mode) ? 1 : ring;

endmodule
",-0.5,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



// Define a wire to represent the condition when the phone is in vibrate mode
wire phone_in_vibrate_mode;

// Use an assign statement to set the value of phone_in_vibrate_mode based on the input vibrate_mode
assign phone_in_vibrate_mode = vibrate_mode;

// Use an assign statement to set the value of the ringer output based on the inputs
assign ringer = (phone_in_vibrate_mode) ? 0 : ring;

// Use an assign statement to set the value of the motor output based on the inputs
assign motor = (phone_in_vibrate_mode) ? 1 : ring;

endmodule
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



// Define a wire to represent the condition when the phone is in vibrate mode
wire phone_in_vibrate_mode;

// Use an assign statement to set the value of phone_in_vibrate_mode based on the input vibrate_mode
assign phone_in_vibrate_mode = vibrate_mode;

// Use an assign statement to set the value of the ringer output based on the inputs
assign ringer = (phone_in_vibrate_mode) ? 0 : ring;

// Use an assign statement to set the value of the motor output based on the inputs
assign motor = (phone_in_vibrate_mode) ? 1 : ring;

endmodule
"
"assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
",-0.5,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
"
"assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
",-0.5,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);



assign ringer = ~vibrate_mode & ring;
assign motor = vibrate_mode & ~ring;

endmodule
"
"    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & ~q[i+1]) ^ 1);
        end
    end

endmodule
",-1.0,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & ~q[i+1]) ^ 1);
        end
    end

endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & ~q[i+1]) ^ 1);
        end
    end

endmodule
"
"    reg [511:0] q_next;
    reg [511:0] q_reg;

    always @(posedge clk) begin
        if (load) begin
            q_reg <= data;
        end else begin
            q_reg <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q_reg[1] & q_reg[0]) | (q_reg[1] & !q_reg[2]) | (!q_reg[1] & q_reg[2]);
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = (q_reg[i-1] & q_reg[i]) | (q_reg[i-1] & !q_reg[i+1]) | (!q_reg[i-1] & q_reg[i+1]);
        end
        q_next[511] = (q_reg[510] & q_reg[511]) | (q_reg[510] & 1'b0) | (1'b0 & 1'b0);
    end

    assign q = q_reg;
endmodule
",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;
    reg [511:0] q_reg;

    always @(posedge clk) begin
        if (load) begin
            q_reg <= data;
        end else begin
            q_reg <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q_reg[1] & q_reg[0]) | (q_reg[1] & !q_reg[2]) | (!q_reg[1] & q_reg[2]);
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = (q_reg[i-1] & q_reg[i]) | (q_reg[i-1] & !q_reg[i+1]) | (!q_reg[i-1] & q_reg[i+1]);
        end
        q_next[511] = (q_reg[510] & q_reg[511]) | (q_reg[510] & 1'b0) | (1'b0 & 1'b0);
    end

    assign q = q_reg;
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;
    reg [511:0] q_reg;

    always @(posedge clk) begin
        if (load) begin
            q_reg <= data;
        end else begin
            q_reg <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q_reg[1] & q_reg[0]) | (q_reg[1] & !q_reg[2]) | (!q_reg[1] & q_reg[2]);
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = (q_reg[i-1] & q_reg[i]) | (q_reg[i-1] & !q_reg[i+1]) | (!q_reg[i-1] & q_reg[i+1]);
        end
        q_next[511] = (q_reg[510] & q_reg[511]) | (q_reg[510] & 1'b0) | (1'b0 & 1'b0);
    end

    assign q = q_reg;
endmodule
"
"    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i++) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & q[i] & ~q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & ~q[i+1]) ^ 1);
        end
    end

endmodule
",-1.0,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i++) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & q[i] & ~q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & ~q[i+1]) ^ 1);
        end
    end

endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i++) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & q[i] & ~q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & ~q[i+1]) ^ 1);
        end
    end

endmodule
"
"    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0] & ~q[511]) | (q[1] & ~q[0] & q[511]) | (q[1] & ~q[0] & ~q[511]) | (~q[1] & q[0] & q[511]);
        for (int i = 1; i < 511; i=i+1) begin
            q_next[i] = (q[i+1] & q[i] & q[i-1]) | (q[i+1] & q[i-1] & ~q[i]) | (q[i+1] & ~q[i] & q[i-1]) | (~q[i+1] & q[i] & q[i-1]);
        end
        q_next[511] = (q[0] & q[511] & q[510]) | (q[0] & ~q[511] & q[510]) | (~q[0] & q[511] & q[510]) | (~q[0] & ~q[511] & ~q[510]);
    end

endmodule
",-1.0,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0] & ~q[511]) | (q[1] & ~q[0] & q[511]) | (q[1] & ~q[0] & ~q[511]) | (~q[1] & q[0] & q[511]);
        for (int i = 1; i < 511; i=i+1) begin
            q_next[i] = (q[i+1] & q[i] & q[i-1]) | (q[i+1] & q[i-1] & ~q[i]) | (q[i+1] & ~q[i] & q[i-1]) | (~q[i+1] & q[i] & q[i-1]);
        end
        q_next[511] = (q[0] & q[511] & q[510]) | (q[0] & ~q[511] & q[510]) | (~q[0] & q[511] & q[510]) | (~q[0] & ~q[511] & ~q[510]);
    end

endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0] & ~q[511]) | (q[1] & ~q[0] & q[511]) | (q[1] & ~q[0] & ~q[511]) | (~q[1] & q[0] & q[511]);
        for (int i = 1; i < 511; i=i+1) begin
            q_next[i] = (q[i+1] & q[i] & q[i-1]) | (q[i+1] & q[i-1] & ~q[i]) | (q[i+1] & ~q[i] & q[i-1]) | (~q[i+1] & q[i] & q[i-1]);
        end
        q_next[511] = (q[0] & q[511] & q[510]) | (q[0] & ~q[511] & q[510]) | (~q[0] & q[511] & q[510]) | (~q[0] & ~q[511] & ~q[510]);
    end

endmodule
"
"reg [511:0] q_next;
reg [511:0] q;

always @(posedge clk) begin
    if (load) begin
        q <= data;
    end else begin
        q <= q_next;
    end
end

always @* begin
    q_next[0] = (q[1] & q[0]);
    q_next[511] = (q[510] & q[511]);
    for (int i = 1; i < 511; i = i + 1) begin
        q_next[i] = ((q[i-1] & q[i]) | (q[i] & ~q[i+1]) | (~q[i-1] & ~q[i] & q[i+1]));
    end
end

endmodule
",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


reg [511:0] q_next;
reg [511:0] q;

always @(posedge clk) begin
    if (load) begin
        q <= data;
    end else begin
        q <= q_next;
    end
end

always @* begin
    q_next[0] = (q[1] & q[0]);
    q_next[511] = (q[510] & q[511]);
    for (int i = 1; i < 511; i = i + 1) begin
        q_next[i] = ((q[i-1] & q[i]) | (q[i] & ~q[i+1]) | (~q[i-1] & ~q[i] & q[i+1]));
    end
end

endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


reg [511:0] q_next;
reg [511:0] q;

always @(posedge clk) begin
    if (load) begin
        q <= data;
    end else begin
        q <= q_next;
    end
end

always @* begin
    q_next[0] = (q[1] & q[0]);
    q_next[511] = (q[510] & q[511]);
    for (int i = 1; i < 511; i = i + 1) begin
        q_next[i] = ((q[i-1] & q[i]) | (q[i] & ~q[i+1]) | (~q[i-1] & ~q[i] & q[i+1]));
    end
end

endmodule
"
"    reg [511:0] q_next;
    reg [511:0] q_reg;

    always @(posedge clk) begin
        if (load) begin
            q_reg <= data;
        end else begin
            q_reg <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q_reg[1] & q_reg[0]) ^ 1;
        q_next[511] = (q_reg[510] & q_reg[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q_reg[i-1] & q_reg[i] & q_reg[i+1]) ^ 1) | ((~q_reg[i-1] & q_reg[i] & q_reg[i+1]) ^ 1) | ((q_reg[i-1] & ~q_reg[i] & q_reg[i+1]) ^ 1) | ((q_reg[i-1] & ~q_reg[i] & ~q_reg[i+1]) ^ 1);
        end
    end

    assign q = q_reg;
endmodule
",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;
    reg [511:0] q_reg;

    always @(posedge clk) begin
        if (load) begin
            q_reg <= data;
        end else begin
            q_reg <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q_reg[1] & q_reg[0]) ^ 1;
        q_next[511] = (q_reg[510] & q_reg[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q_reg[i-1] & q_reg[i] & q_reg[i+1]) ^ 1) | ((~q_reg[i-1] & q_reg[i] & q_reg[i+1]) ^ 1) | ((q_reg[i-1] & ~q_reg[i] & q_reg[i+1]) ^ 1) | ((q_reg[i-1] & ~q_reg[i] & ~q_reg[i+1]) ^ 1);
        end
    end

    assign q = q_reg;
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;
    reg [511:0] q_reg;

    always @(posedge clk) begin
        if (load) begin
            q_reg <= data;
        end else begin
            q_reg <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q_reg[1] & q_reg[0]) ^ 1;
        q_next[511] = (q_reg[510] & q_reg[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q_reg[i-1] & q_reg[i] & q_reg[i+1]) ^ 1) | ((~q_reg[i-1] & q_reg[i] & q_reg[i+1]) ^ 1) | ((q_reg[i-1] & ~q_reg[i] & q_reg[i+1]) ^ 1) | ((q_reg[i-1] & ~q_reg[i] & ~q_reg[i+1]) ^ 1);
        end
    end

    assign q = q_reg;
endmodule
"
"    reg [511:0] q_next;

    always @(posedge clk) begin
        if(load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0] & ~q[511]) | (q[1] & ~q[0] & q[511]) | (q[1] & ~q[0] & ~q[511]) | (~q[1] & q[0] & q[511]);
        for(int i=1; i<511; i=i+1) begin
            q_next[i] = (q[i+1] & q[i] & q[i-1]) | (q[i+1] & q[i] & ~q[i-1]) | (q[i+1] & ~q[i] & q[i-1]) | (q[i+1] & ~q[i] & ~q[i-1]) | (~q[i+1] & q[i] & q[i-1]);
        end
        q_next[511] = (q[0] & q[511] & q[510]) | (q[0] & ~q[511] & q[510]) | (~q[0] & q[511] & q[510]) | (~q[0] & ~q[511] & q[510]);
    end

endmodule
",-1.0,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if(load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0] & ~q[511]) | (q[1] & ~q[0] & q[511]) | (q[1] & ~q[0] & ~q[511]) | (~q[1] & q[0] & q[511]);
        for(int i=1; i<511; i=i+1) begin
            q_next[i] = (q[i+1] & q[i] & q[i-1]) | (q[i+1] & q[i] & ~q[i-1]) | (q[i+1] & ~q[i] & q[i-1]) | (q[i+1] & ~q[i] & ~q[i-1]) | (~q[i+1] & q[i] & q[i-1]);
        end
        q_next[511] = (q[0] & q[511] & q[510]) | (q[0] & ~q[511] & q[510]) | (~q[0] & q[511] & q[510]) | (~q[0] & ~q[511] & q[510]);
    end

endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if(load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0] & ~q[511]) | (q[1] & ~q[0] & q[511]) | (q[1] & ~q[0] & ~q[511]) | (~q[1] & q[0] & q[511]);
        for(int i=1; i<511; i=i+1) begin
            q_next[i] = (q[i+1] & q[i] & q[i-1]) | (q[i+1] & q[i] & ~q[i-1]) | (q[i+1] & ~q[i] & q[i-1]) | (q[i+1] & ~q[i] & ~q[i-1]) | (~q[i+1] & q[i] & q[i-1]);
        end
        q_next[511] = (q[0] & q[511] & q[510]) | (q[0] & ~q[511] & q[510]) | (~q[0] & q[511] & q[510]) | (~q[0] & ~q[511] & q[510]);
    end

endmodule
"
"    reg [511:0] q_next;
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end
    
    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & q[i] & ~q[i+1]) ^ 1) | ((~q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & q[i+1]) ^ 1);
        end
    end
    
endmodule
",-1.0,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end
    
    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & q[i] & ~q[i+1]) ^ 1) | ((~q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & q[i+1]) ^ 1);
        end
    end
    
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end
    
    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & q[i] & ~q[i+1]) ^ 1) | ((~q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & q[i+1]) ^ 1);
        end
    end
    
endmodule
"
"    reg [511:0] q_next;

    always @ (posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]);
        q_next[511] = (q[510] & q[511]);
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = (q[i-1] & q[i] & ~q[i+1]) | (q[i-1] & ~q[i] & q[i+1]) | (~q[i-1] & q[i] & q[i+1]) | (~q[i-1] & ~q[i] & ~q[i+1]);
        end
    end

endmodule
",-1.0,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @ (posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]);
        q_next[511] = (q[510] & q[511]);
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = (q[i-1] & q[i] & ~q[i+1]) | (q[i-1] & ~q[i] & q[i+1]) | (~q[i-1] & q[i] & q[i+1]) | (~q[i-1] & ~q[i] & ~q[i+1]);
        end
    end

endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @ (posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]);
        q_next[511] = (q[510] & q[511]);
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = (q[i-1] & q[i] & ~q[i+1]) | (q[i-1] & ~q[i] & q[i+1]) | (~q[i-1] & q[i] & q[i+1]) | (~q[i-1] & ~q[i] & ~q[i+1]);
        end
    end

endmodule
"
"    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & q[i] & q[i+1]) ^ 1) | ((q[i-1] & ~q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & q[i+1]) ^ 1);
        end
    end

endmodule
",-1.0,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & q[i] & q[i+1]) ^ 1) | ((q[i-1] & ~q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & q[i+1]) ^ 1);
        end
    end

endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);


    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = (q[1] & q[0]) ^ 1;
        q_next[511] = (q[510] & q[511]) ^ 1;
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = ((q[i-1] & q[i] & q[i+1]) ^ 1) | ((~q[i-1] & q[i] & q[i+1]) ^ 1) | ((q[i-1] & ~q[i] & q[i+1]) ^ 1) | ((~q[i-1] & ~q[i] & q[i+1]) ^ 1);
        end
    end

endmodule
"
"    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = q[1] ^ q[0] ^ 0;
        for (int i = 1; i < 511; i=i+1) begin
            q_next[i] = q[i-1] ^ q[i] ^ q[i+1];
        end
        q_next[511] = q[510] ^ q[511] ^ 0;
    end

endmodule
",-1.0,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = q[1] ^ q[0] ^ 0;
        for (int i = 1; i < 511; i=i+1) begin
            q_next[i] = q[i-1] ^ q[i] ^ q[i+1];
        end
        q_next[511] = q[510] ^ q[511] ^ 0;
    end

endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] q_next;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end

    always @* begin
        q_next[0] = q[1] ^ q[0] ^ 0;
        for (int i = 1; i < 511; i=i+1) begin
            q_next[i] = q[i-1] ^ q[i] ^ q[i+1];
        end
        q_next[511] = q[510] ^ q[511] ^ 0;
    end

endmodule
"
"    reg [511:0] next_state;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_state[0] = q[1] ^ q[0] ^ 1'b0;
            next_state[511] = q[510] ^ q[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_state[i] = q[i-1] ^ q[i+1] ^ 1'b0;
            end
            q <= next_state;
        end
    end
endmodule
",-1.0,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_state;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_state[0] = q[1] ^ q[0] ^ 1'b0;
            next_state[511] = q[510] ^ q[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_state[i] = q[i-1] ^ q[i+1] ^ 1'b0;
            end
            q <= next_state;
        end
    end
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_state;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_state[0] = q[1] ^ q[0] ^ 1'b0;
            next_state[511] = q[510] ^ q[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_state[i] = q[i-1] ^ q[i+1] ^ 1'b0;
            end
            q <= next_state;
        end
    end
endmodule
"
"    reg [511:0] next_q;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_q[0] = q[1] ^ q[0] ^ 1'b0;
            next_q[511] = q[510] ^ q[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];
            end
            q <= next_q;
        end
    end
endmodule
",-1.0,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_q;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_q[0] = q[1] ^ q[0] ^ 1'b0;
            next_q[511] = q[510] ^ q[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];
            end
            q <= next_q;
        end
    end
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_q;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_q[0] = q[1] ^ q[0] ^ 1'b0;
            next_q[511] = q[510] ^ q[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];
            end
            q <= next_q;
        end
    end
endmodule
"
"
    reg [511:0] q_next;
    
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end
    
    always @* begin
        q_next[0] = q[1] ^ q[0] ^ 0;
        q_next[511] = 0;
        
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = q[i-1] ^ q[i] ^ q[i+1];
        end
    end
endmodule
",-1.0,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );


    reg [511:0] q_next;
    
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end
    
    always @* begin
        q_next[0] = q[1] ^ q[0] ^ 0;
        q_next[511] = 0;
        
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = q[i-1] ^ q[i] ^ q[i+1];
        end
    end
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );


    reg [511:0] q_next;
    
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            q <= q_next;
        end
    end
    
    always @* begin
        q_next[0] = q[1] ^ q[0] ^ 0;
        q_next[511] = 0;
        
        for (int i = 1; i < 511; i = i + 1) begin
            q_next[i] = q[i-1] ^ q[i] ^ q[i+1];
        end
    end
endmodule
"
"
    reg [511:0] next_q;
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_q[0] = q[1] ^ q[0] ^ 1'b0;
            next_q[511] = q[510] ^ q[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];
            end
            q <= next_q;
        end
    end
endmodule
",-1.0,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );


    reg [511:0] next_q;
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_q[0] = q[1] ^ q[0] ^ 1'b0;
            next_q[511] = q[510] ^ q[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];
            end
            q <= next_q;
        end
    end
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );


    reg [511:0] next_q;
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_q[0] = q[1] ^ q[0] ^ 1'b0;
            next_q[511] = q[510] ^ q[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];
            end
            q <= next_q;
        end
    end
endmodule
"
"    reg [511:0] next_state;
    reg [511:0] q;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_state[0] = q[1] ^ q[0] ^ 0;
            next_state[511] = 0 ^ q[510] ^ q[511];

            for (int i = 1; i < 511; i = i + 1) begin
                next_state[i] = q[i-1] ^ q[i] ^ q[i+1];
            end

            q <= next_state;
        end
    end

endmodule
",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_state;
    reg [511:0] q;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_state[0] = q[1] ^ q[0] ^ 0;
            next_state[511] = 0 ^ q[510] ^ q[511];

            for (int i = 1; i < 511; i = i + 1) begin
                next_state[i] = q[i-1] ^ q[i] ^ q[i+1];
            end

            q <= next_state;
        end
    end

endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_state;
    reg [511:0] q;

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_state[0] = q[1] ^ q[0] ^ 0;
            next_state[511] = 0 ^ q[510] ^ q[511];

            for (int i = 1; i < 511; i = i + 1) begin
                next_state[i] = q[i-1] ^ q[i] ^ q[i+1];
            end

            q <= next_state;
        end
    end

endmodule
"
"    reg [511:0] q_temp;

    always @(posedge clk) begin
        if (load) begin
            q_temp <= data;
        end else begin
            q_temp[0] = q_temp[1] ^ q_temp[511];
            q_temp[511] = q_temp[510] ^ q_temp[0];
            for (int i = 1; i < 511; i = i + 1) begin
                q_temp[i] = q_temp[i-1] ^ q_temp[i+1];
            end
        end
    end

    assign q = q_temp;
endmodule
",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] q_temp;

    always @(posedge clk) begin
        if (load) begin
            q_temp <= data;
        end else begin
            q_temp[0] = q_temp[1] ^ q_temp[511];
            q_temp[511] = q_temp[510] ^ q_temp[0];
            for (int i = 1; i < 511; i = i + 1) begin
                q_temp[i] = q_temp[i-1] ^ q_temp[i+1];
            end
        end
    end

    assign q = q_temp;
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] q_temp;

    always @(posedge clk) begin
        if (load) begin
            q_temp <= data;
        end else begin
            q_temp[0] = q_temp[1] ^ q_temp[511];
            q_temp[511] = q_temp[510] ^ q_temp[0];
            for (int i = 1; i < 511; i = i + 1) begin
                q_temp[i] = q_temp[i-1] ^ q_temp[i+1];
            end
        end
    end

    assign q = q_temp;
endmodule
"
"    reg [511:0] next_q;
    
    always @(posedge clk) begin
        if (load) begin
            next_q <= data;
        end else begin
            next_q[0] = data[1] ^ data[0] ^ 0;
            next_q[511] = data[510] ^ data[511] ^ 0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = data[i-1] ^ data[i] ^ data[i+1];
            end
        end
    end
    
    assign q = next_q;
endmodule
",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_q;
    
    always @(posedge clk) begin
        if (load) begin
            next_q <= data;
        end else begin
            next_q[0] = data[1] ^ data[0] ^ 0;
            next_q[511] = data[510] ^ data[511] ^ 0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = data[i-1] ^ data[i] ^ data[i+1];
            end
        end
    end
    
    assign q = next_q;
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_q;
    
    always @(posedge clk) begin
        if (load) begin
            next_q <= data;
        end else begin
            next_q[0] = data[1] ^ data[0] ^ 0;
            next_q[511] = data[510] ^ data[511] ^ 0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = data[i-1] ^ data[i] ^ data[i+1];
            end
        end
    end
    
    assign q = next_q;
endmodule
"
"    reg [511:0] next_q;
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_q[0] = q[1] ^ q[0] ^ 0;
            next_q[511] = 0 ^ q[510] ^ q[511];
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];
            end
            q <= next_q;
        end
    end
endmodule
",-1.0,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_q;
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_q[0] = q[1] ^ q[0] ^ 0;
            next_q[511] = 0 ^ q[510] ^ q[511];
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];
            end
            q <= next_q;
        end
    end
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_q;
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else begin
            next_q[0] = q[1] ^ q[0] ^ 0;
            next_q[511] = 0 ^ q[510] ^ q[511];
            for (int i = 1; i < 511; i = i + 1) begin
                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];
            end
            q <= next_q;
        end
    end
endmodule
"
"    reg [511:0] next_state;
    reg [511:0] q_reg;

    always @(posedge clk) begin
        if (load) begin
            q_reg <= data;
        end else begin
            next_state[0] = q_reg[1] ^ q_reg[0] ^ 1'b0;
            next_state[511] = q_reg[510] ^ q_reg[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_state[i] = q_reg[i-1] ^ q_reg[i] ^ q_reg[i+1];
            end
            q_reg <= next_state;
        end
    end

    assign q = q_reg;
endmodule
",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_state;
    reg [511:0] q_reg;

    always @(posedge clk) begin
        if (load) begin
            q_reg <= data;
        end else begin
            next_state[0] = q_reg[1] ^ q_reg[0] ^ 1'b0;
            next_state[511] = q_reg[510] ^ q_reg[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_state[i] = q_reg[i-1] ^ q_reg[i] ^ q_reg[i+1];
            end
            q_reg <= next_state;
        end
    end

    assign q = q_reg;
endmodule
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );

    reg [511:0] next_state;
    reg [511:0] q_reg;

    always @(posedge clk) begin
        if (load) begin
            q_reg <= data;
        end else begin
            next_state[0] = q_reg[1] ^ q_reg[0] ^ 1'b0;
            next_state[511] = q_reg[510] ^ q_reg[511] ^ 1'b0;
            for (int i = 1; i < 511; i = i + 1) begin
                next_state[i] = q_reg[i-1] ^ q_reg[i] ^ q_reg[i+1];
            end
            q_reg <= next_state;
        end
    end

    assign q = q_reg;
endmodule
"
"reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case(amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]}; // shift left by 1 bit
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]}; // shift left by 8 bits
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]}; // shift right by 1 bit
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]}; // shift right by 8 bits
        endcase
    end
end

assign q = shift_reg;

endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case(amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]}; // shift left by 1 bit
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]}; // shift left by 8 bits
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]}; // shift right by 1 bit
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]}; // shift right by 8 bits
        endcase
    end
end

assign q = shift_reg;

endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case(amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]}; // shift left by 1 bit
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]}; // shift left by 8 bits
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]}; // shift right by 1 bit
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]}; // shift right by 8 bits
        endcase
    end
end

assign q = shift_reg;

endmodule
"
"reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else begin
        case(amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]}; // shift left by 1 bit
            2'b01: shift_reg <= {shift_reg[55:0], 8'b0}; // shift left by 8 bits
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]}; // arithmetic right shift by 1 bit
            2'b11: shift_reg <= {8'b0, shift_reg[63:8]}; // arithmetic right shift by 8 bits
            default: shift_reg <= shift_reg; // no shift
        endcase
    end
end

always @* begin
    if (ena) begin
        q = shift_reg;
    end else begin
        q = q;
    end
end

endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else begin
        case(amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]}; // shift left by 1 bit
            2'b01: shift_reg <= {shift_reg[55:0], 8'b0}; // shift left by 8 bits
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]}; // arithmetic right shift by 1 bit
            2'b11: shift_reg <= {8'b0, shift_reg[63:8]}; // arithmetic right shift by 8 bits
            default: shift_reg <= shift_reg; // no shift
        endcase
    end
end

always @* begin
    if (ena) begin
        q = shift_reg;
    end else begin
        q = q;
    end
end

endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else begin
        case(amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]}; // shift left by 1 bit
            2'b01: shift_reg <= {shift_reg[55:0], 8'b0}; // shift left by 8 bits
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]}; // arithmetic right shift by 1 bit
            2'b11: shift_reg <= {8'b0, shift_reg[63:8]}; // arithmetic right shift by 8 bits
            default: shift_reg <= shift_reg; // no shift
        endcase
    end
end

always @* begin
    if (ena) begin
        q = shift_reg;
    end else begin
        q = q;
    end
end

endmodule
"
"reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};
        endcase
    end
end

assign q = shift_reg;

endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};
        endcase
    end
end

assign q = shift_reg;

endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};
        endcase
    end
end

assign q = shift_reg;

endmodule
"
"    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena) begin
            case(amount)
                2'b00: q <= {q[62:0], q[63]}; // shift left by 1 bit
                2'b01: q <= {q[55:0], q[63:56]}; // shift left by 8 bits
                2'b10: q <= {q[63], q[63:1]}; // shift right by 1 bit
                2'b11: q <= {q[7:0], q[63:8]}; // shift right by 8 bits
            endcase
        end
    end
endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena) begin
            case(amount)
                2'b00: q <= {q[62:0], q[63]}; // shift left by 1 bit
                2'b01: q <= {q[55:0], q[63:56]}; // shift left by 8 bits
                2'b10: q <= {q[63], q[63:1]}; // shift right by 1 bit
                2'b11: q <= {q[7:0], q[63:8]}; // shift right by 8 bits
            endcase
        end
    end
endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena) begin
            case(amount)
                2'b00: q <= {q[62:0], q[63]}; // shift left by 1 bit
                2'b01: q <= {q[55:0], q[63:56]}; // shift left by 8 bits
                2'b10: q <= {q[63], q[63:1]}; // shift right by 1 bit
                2'b11: q <= {q[7:0], q[63:8]}; // shift right by 8 bits
            endcase
        end
    end
endmodule
"
"reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]}; // shift left by 1 bit
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]}; // shift left by 8 bits
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]}; // shift right by 1 bit
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]}; // shift right by 8 bits
        endcase
    end
end

assign q = shift_reg;

endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]}; // shift left by 1 bit
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]}; // shift left by 8 bits
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]}; // shift right by 1 bit
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]}; // shift right by 8 bits
        endcase
    end
end

assign q = shift_reg;

endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]}; // shift left by 1 bit
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]}; // shift left by 8 bits
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]}; // shift right by 1 bit
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]}; // shift right by 8 bits
        endcase
    end
end

assign q = shift_reg;

endmodule
"
"reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};
            default: shift_reg <= shift_reg;
        endcase
    end
end

assign q = shift_reg;

endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};
            default: shift_reg <= shift_reg;
        endcase
    end
end

assign q = shift_reg;

endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};
            default: shift_reg <= shift_reg;
        endcase
    end
end

assign q = shift_reg;

endmodule
"
"reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};
        endcase
    end
end

assign q = shift_reg;

endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};
        endcase
    end
end

assign q = shift_reg;

endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};
        endcase
    end
end

assign q = shift_reg;

endmodule
"
"reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], 8'b0};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {8'b0, shift_reg[63:8]};
            default: shift_reg <= shift_reg;
        endcase
    end
end

assign q = shift_reg;

endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], 8'b0};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {8'b0, shift_reg[63:8]};
            default: shift_reg <= shift_reg;
        endcase
    end
end

assign q = shift_reg;

endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
reg [63:0] shift_reg;

always @(posedge clk) begin
    if (load) begin
        shift_reg <= data;
    end else if (ena) begin
        case (amount)
            2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};
            2'b01: shift_reg <= {shift_reg[55:0], 8'b0};
            2'b10: shift_reg <= {shift_reg[63], shift_reg[63:1]};
            2'b11: shift_reg <= {8'b0, shift_reg[63:8]};
            default: shift_reg <= shift_reg;
        endcase
    end
end

assign q = shift_reg;

endmodule
"
"    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena) begin
            case (amount)
                2'b00: q <= {q[62:0], q[63]};
                2'b01: q <= {q[55:0], q[63:56]};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[7:0], q[63:8]};
            endcase
        end
    end
endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena) begin
            case (amount)
                2'b00: q <= {q[62:0], q[63]};
                2'b01: q <= {q[55:0], q[63:56]};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[7:0], q[63:8]};
            endcase
        end
    end
endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena) begin
            case (amount)
                2'b00: q <= {q[62:0], q[63]};
                2'b01: q <= {q[55:0], q[63:56]};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[7:0], q[63:8]};
            endcase
        end
    end
endmodule
"
"    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena) begin
            case(amount)
                2'b00: q <= {q[62:0], q[63]};
                2'b01: q <= {q[55:0], q[63:56]};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[7:0], q[63:8]};
            endcase
        end
    end
endmodule
",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena) begin
            case(amount)
                2'b00: q <= {q[62:0], q[63]};
                2'b01: q <= {q[55:0], q[63:56]};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[7:0], q[63:8]};
            endcase
        end
    end
endmodule
","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena) begin
            case(amount)
                2'b00: q <= {q[62:0], q[63]};
                2'b01: q <= {q[55:0], q[63:56]};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[7:0], q[63:8]};
            endcase
        end
    end
endmodule
"
"    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0;
        end else begin
            if (load) begin
                q <= data;
            end else if (ena) begin
                q <= {q[2:0], 1'b0};
            end
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0;
        end else begin
            if (load) begin
                q <= data;
            end else if (ena) begin
                q <= {q[2:0], 1'b0};
            end
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0;
        end else begin
            if (load) begin
                q <= data;
            end else if (ena) begin
                q <= {q[2:0], 1'b0};
            end
        end
    end
endmodule
"
"    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
"
"    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
"
"    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
"
"    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[3], q[2:0]};
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[3], q[2:0]};
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[3], q[2:0]};
        end
    end
endmodule
"
"    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else begin
            if (load) begin
                q <= data;
            end else if (ena) begin
                q <= {q[2:0], 1'b0};
            end
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else begin
            if (load) begin
                q <= data;
            end else if (ena) begin
                q <= {q[2:0], 1'b0};
            end
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else begin
            if (load) begin
                q <= data;
            end else if (ena) begin
                q <= {q[2:0], 1'b0};
            end
        end
    end
endmodule
"
"    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else if (load) begin
            q <= data;
        end else if (ena) begin
            q <= {q[2:0], 1'b0};
        end
    end
endmodule
"
"    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else begin
            if (load) begin
                q <= data;
            end else if (ena) begin
                q <= {q[2:0], 1'b0};
            end
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else begin
            if (load) begin
                q <= data;
            end else if (ena) begin
                q <= {q[2:0], 1'b0};
            end
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;
        end else begin
            if (load) begin
                q <= data;
            end else if (ena) begin
                q <= {q[2:0], 1'b0};
            end
        end
    end
endmodule
"
"
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;  // reset to zero
        end else begin
            if (load) begin
                q <= data;  // load data[3:0]
            end else if (ena) begin
                q <= {q[2:0], 1'b0};  // shift right
            end
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);


    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;  // reset to zero
        end else begin
            if (load) begin
                q <= data;  // load data[3:0]
            end else if (ena) begin
                q <= {q[2:0], 1'b0};  // shift right
            end
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);


    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000;  // reset to zero
        end else begin
            if (load) begin
                q <= data;  // load data[3:0]
            end else if (ena) begin
                q <= {q[2:0], 1'b0};  // shift right
            end
        end
    end
endmodule
"
"    // Internal signals
    reg [3:0] q_temp; // Temporary variable for shifting
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000; // Reset to zero
        end else begin
            if (load) begin
                q <= data; // Load data[3:0] into shift register
            end else if (ena) begin
                q_temp[0] <= q[3]; // Shift right
                q_temp[1] <= q[0];
                q_temp[2] <= q[1];
                q_temp[3] <= q[2];
                q <= q_temp;
            end
        end
    end
endmodule
",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    // Internal signals
    reg [3:0] q_temp; // Temporary variable for shifting
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000; // Reset to zero
        end else begin
            if (load) begin
                q <= data; // Load data[3:0] into shift register
            end else if (ena) begin
                q_temp[0] <= q[3]; // Shift right
                q_temp[1] <= q[0];
                q_temp[2] <= q[1];
                q_temp[3] <= q[2];
                q <= q_temp;
            end
        end
    end
endmodule
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);

    // Internal signals
    reg [3:0] q_temp; // Temporary variable for shifting
    
    always @(posedge clk or posedge areset) begin
        if (areset) begin
            q <= 4'b0000; // Reset to zero
        end else begin
            if (load) begin
                q <= data; // Load data[3:0] into shift register
            end else if (ena) begin
                q_temp[0] <= q[3]; // Shift right
                q_temp[1] <= q[0];
                q_temp[2] <= q[1];
                q_temp[3] <= q[2];
                q <= q_temp;
            end
        end
    end
endmodule
"
"
    assign one = 1'b1;
endmodule
",1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
","module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
"
"
    assign one = 1'b1;
endmodule
",1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
","module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
"
"
    assign one = 1'b1;
endmodule
",1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
","module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
"
"
    assign one = 1'b1; // always drive logic high
endmodule
",1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1; // always drive logic high
endmodule
","module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1; // always drive logic high
endmodule
"
"
    assign one = 1'b1; // Output always drives 1 (logic high)
endmodule
",1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1; // Output always drives 1 (logic high)
endmodule
","module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1; // Output always drives 1 (logic high)
endmodule
"
"assign one = 1'b1; // output always drives 1
",-1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
assign one = 1'b1; // output always drives 1
","module top_module( output one );
    //assign one = [fixme];
assign one = 1'b1; // output always drives 1
"
"
    assign one = 1'b1;
endmodule
",1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
","module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
"
"
    assign one = 1'b1;
endmodule
",1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
","module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
"
"
    assign one = 1'b1;
endmodule
",1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
","module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
"
"
    assign one = 1'b1;
endmodule
",1.0,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
","module top_module( output one );
    //assign one = [fixme];

    assign one = 1'b1;
endmodule
"
"`timescale 1ps/1ps

module top_module;

reg clk;

// Instantiate dut module
dut dut_inst (
    .clk(clk)
);

// Generate clock signal with period of 10 ps
always begin
    #5 clk = 0;
    #5 clk = 1;
end

endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

`timescale 1ps/1ps

module top_module;

reg clk;

// Instantiate dut module
dut dut_inst (
    .clk(clk)
);

// Generate clock signal with period of 10 ps
always begin
    #5 clk = 0;
    #5 clk = 1;
end

endmodule
","module top_module ( );

`timescale 1ps/1ps

module top_module;

reg clk;

// Instantiate dut module
dut dut_inst (
    .clk(clk)
);

// Generate clock signal with period of 10 ps
always begin
    #5 clk = 0;
    #5 clk = 1;
end

endmodule
"
"`timescale 1ps/1ps

module top_module();

reg clk;

// Instantiate dut module
dut dut_instance(.clk(clk));

// Initialize clock signal
initial begin
    clk = 0;
    #5; // Wait for half of the clock period
    forever begin
        #5 clk = ~clk; // Toggle clock every 10 ps
    end
end

endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

`timescale 1ps/1ps

module top_module();

reg clk;

// Instantiate dut module
dut dut_instance(.clk(clk));

// Initialize clock signal
initial begin
    clk = 0;
    #5; // Wait for half of the clock period
    forever begin
        #5 clk = ~clk; // Toggle clock every 10 ps
    end
end

endmodule
","module top_module ( );

`timescale 1ps/1ps

module top_module();

reg clk;

// Instantiate dut module
dut dut_instance(.clk(clk));

// Initialize clock signal
initial begin
    clk = 0;
    #5; // Wait for half of the clock period
    forever begin
        #5 clk = ~clk; // Toggle clock every 10 ps
    end
end

endmodule
"
"
  reg clk;

  initial begin
    clk = 0;
    #5; // delay to ensure clock starts at 0
    forever begin
      #5 clk = ~clk; // toggle clock every 10 ps
    end
  end

  dut dut_inst (
    .clk(clk)
  );

endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );


  reg clk;

  initial begin
    clk = 0;
    #5; // delay to ensure clock starts at 0
    forever begin
      #5 clk = ~clk; // toggle clock every 10 ps
    end
  end

  dut dut_inst (
    .clk(clk)
  );

endmodule
","module top_module ( );


  reg clk;

  initial begin
    clk = 0;
    #5; // delay to ensure clock starts at 0
    forever begin
      #5 clk = ~clk; // toggle clock every 10 ps
    end
  end

  dut dut_inst (
    .clk(clk)
  );

endmodule
"
"`timescale 1ps/1ps

module dut_tb;

reg clk;
initial
begin
    clk = 0;
    #5;
    forever #5 clk = ~clk;
end

dut dut_inst (
    .clk(clk)
);

endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

`timescale 1ps/1ps

module dut_tb;

reg clk;
initial
begin
    clk = 0;
    #5;
    forever #5 clk = ~clk;
end

dut dut_inst (
    .clk(clk)
);

endmodule
","module top_module ( );

`timescale 1ps/1ps

module dut_tb;

reg clk;
initial
begin
    clk = 0;
    #5;
    forever #5 clk = ~clk;
end

dut dut_inst (
    .clk(clk)
);

endmodule
"
"`timescale 1ps/1ps

module top_module();

reg clk;

initial begin
    clk = 0;
    #5; // delay to start clock at time 5 ps
    forever begin
        #5 clk = ~clk; // toggle clock every 5 ps
    end
end

dut dut_inst (
    .clk(clk)
);

endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

`timescale 1ps/1ps

module top_module();

reg clk;

initial begin
    clk = 0;
    #5; // delay to start clock at time 5 ps
    forever begin
        #5 clk = ~clk; // toggle clock every 5 ps
    end
end

dut dut_inst (
    .clk(clk)
);

endmodule
","module top_module ( );

`timescale 1ps/1ps

module top_module();

reg clk;

initial begin
    clk = 0;
    #5; // delay to start clock at time 5 ps
    forever begin
        #5 clk = ~clk; // toggle clock every 5 ps
    end
end

dut dut_inst (
    .clk(clk)
);

endmodule
"
"
  reg clk;
  
  dut dut_inst (
    .clk(clk)
  );
  
  always begin
    #5 clk = 0;
    #5 clk = 1;
  end
  
endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );


  reg clk;
  
  dut dut_inst (
    .clk(clk)
  );
  
  always begin
    #5 clk = 0;
    #5 clk = 1;
  end
  
endmodule
","module top_module ( );


  reg clk;
  
  dut dut_inst (
    .clk(clk)
  );
  
  always begin
    #5 clk = 0;
    #5 clk = 1;
  end
  
endmodule
"
"`timescale 1ps/1ps

module top_module;

reg clk;
initial begin
    clk = 0;
    #5; // delay of 5 ps
    forever begin
        #5 clk = ~clk; // toggle the clock every 5 ps
    end
end

dut dut_inst (
    .clk(clk)
);

endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

`timescale 1ps/1ps

module top_module;

reg clk;
initial begin
    clk = 0;
    #5; // delay of 5 ps
    forever begin
        #5 clk = ~clk; // toggle the clock every 5 ps
    end
end

dut dut_inst (
    .clk(clk)
);

endmodule
","module top_module ( );

`timescale 1ps/1ps

module top_module;

reg clk;
initial begin
    clk = 0;
    #5; // delay of 5 ps
    forever begin
        #5 clk = ~clk; // toggle the clock every 5 ps
    end
end

dut dut_inst (
    .clk(clk)
);

endmodule
"
"`timescale 1ps/1ps

module top_module;

reg clk;
dut dut_inst (.clk(clk));

initial begin
    clk = 0;
    #5; // delay for half the clock period
    forever begin
        #5 clk = ~clk; // toggle clock every 10 ps
    end
end

endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

`timescale 1ps/1ps

module top_module;

reg clk;
dut dut_inst (.clk(clk));

initial begin
    clk = 0;
    #5; // delay for half the clock period
    forever begin
        #5 clk = ~clk; // toggle clock every 10 ps
    end
end

endmodule
","module top_module ( );

`timescale 1ps/1ps

module top_module;

reg clk;
dut dut_inst (.clk(clk));

initial begin
    clk = 0;
    #5; // delay for half the clock period
    forever begin
        #5 clk = ~clk; // toggle clock every 10 ps
    end
end

endmodule
"
"`timescale 1ps/1ps

module top_module;

reg clk;
initial begin
    clk = 0;
    #5; // delay to start clock at time 5 ps
    forever begin
        #5 clk = ~clk; // toggle clock every 5 ps
    end
end

dut dut_inst (
    .clk(clk)
);

endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

`timescale 1ps/1ps

module top_module;

reg clk;
initial begin
    clk = 0;
    #5; // delay to start clock at time 5 ps
    forever begin
        #5 clk = ~clk; // toggle clock every 5 ps
    end
end

dut dut_inst (
    .clk(clk)
);

endmodule
","module top_module ( );

`timescale 1ps/1ps

module top_module;

reg clk;
initial begin
    clk = 0;
    #5; // delay to start clock at time 5 ps
    forever begin
        #5 clk = ~clk; // toggle clock every 5 ps
    end
end

dut dut_inst (
    .clk(clk)
);

endmodule
"
"`timescale 1ps/1ps

module dut_tb;

reg clk;
wire clk;
dut dut_instance (.clk(clk));

initial begin
    clk = 0;
    #5;
    forever begin
        #5 clk = ~clk;
    end
end

endmodule
",-1.0,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

`timescale 1ps/1ps

module dut_tb;

reg clk;
wire clk;
dut dut_instance (.clk(clk));

initial begin
    clk = 0;
    #5;
    forever begin
        #5 clk = ~clk;
    end
end

endmodule
","module top_module ( );

`timescale 1ps/1ps

module dut_tb;

reg clk;
wire clk;
dut dut_instance (.clk(clk));

initial begin
    clk = 0;
    #5;
    forever begin
        #5 clk = ~clk;
    end
end

endmodule
"
"`timescale 1ns/1ns

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    // Initialize inputs
    clk = 0;
    reset = 1;
    t = 0;
    
    // Reset the T flip-flop
    #10 reset = 0;
    
    // Toggle the T flip-flop
    #10 t = 1;
    
    // Add additional test cases here if needed
    
    // Stop simulation
    #10 $finish;
end

always begin
    #5 clk = ~clk;
end

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



`timescale 1ns/1ns

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    // Initialize inputs
    clk = 0;
    reset = 1;
    t = 0;
    
    // Reset the T flip-flop
    #10 reset = 0;
    
    // Toggle the T flip-flop
    #10 t = 1;
    
    // Add additional test cases here if needed
    
    // Stop simulation
    #10 $finish;
end

always begin
    #5 clk = ~clk;
end

endmodule
","module top_module ();



`timescale 1ns/1ns

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    // Initialize inputs
    clk = 0;
    reset = 1;
    t = 0;
    
    // Reset the T flip-flop
    #10 reset = 0;
    
    // Toggle the T flip-flop
    #10 t = 1;
    
    // Add additional test cases here if needed
    
    // Stop simulation
    #10 $finish;
end

always begin
    #5 clk = ~clk;
end

endmodule
"
"`timescale 1ns/1ns

module testbench;

reg clk, reset, t;
wire q;

tff dut (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    $dumpfile(""tff.vcd"");
    $dumpvars(0, testbench);

    clk = 0;
    reset = 1;
    t = 0;

    #10 reset = 0;

    #5 t = 1;
    #5 t = 0;

    #20 $finish;
end

always begin
    #5 clk = ~clk;
end

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



`timescale 1ns/1ns

module testbench;

reg clk, reset, t;
wire q;

tff dut (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    $dumpfile(""tff.vcd"");
    $dumpvars(0, testbench);

    clk = 0;
    reset = 1;
    t = 0;

    #10 reset = 0;

    #5 t = 1;
    #5 t = 0;

    #20 $finish;
end

always begin
    #5 clk = ~clk;
end

endmodule
","module top_module ();



`timescale 1ns/1ns

module testbench;

reg clk, reset, t;
wire q;

tff dut (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    $dumpfile(""tff.vcd"");
    $dumpvars(0, testbench);

    clk = 0;
    reset = 1;
    t = 0;

    #10 reset = 0;

    #5 t = 1;
    #5 t = 0;

    #20 $finish;
end

always begin
    #5 clk = ~clk;
end

endmodule
"
"`timescale 1ns/1ns

module tb_tff;
    reg clk;
    reg reset;
    reg t;
    wire q;

    tff tff_inst (
        .clk(clk),
        .reset(reset),
        .t(t),
        .q(q)
    );

    initial begin
        $dumpfile(""tb_tff.vcd"");
        $dumpvars(0, tb_tff);

        // Initialize inputs
        clk = 0;
        reset = 1;
        t = 0;

        // Reset the T flip-flop
        #5 reset = 0;

        // Toggle the T flip-flop to the ""1"" state
        #5 t = 1;

        // Add some delay for simulation
        #10 $finish;
    end

    always begin
        #1 clk = ~clk; // Toggle clock every cycle
    end

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



`timescale 1ns/1ns

module tb_tff;
    reg clk;
    reg reset;
    reg t;
    wire q;

    tff tff_inst (
        .clk(clk),
        .reset(reset),
        .t(t),
        .q(q)
    );

    initial begin
        $dumpfile(""tb_tff.vcd"");
        $dumpvars(0, tb_tff);

        // Initialize inputs
        clk = 0;
        reset = 1;
        t = 0;

        // Reset the T flip-flop
        #5 reset = 0;

        // Toggle the T flip-flop to the ""1"" state
        #5 t = 1;

        // Add some delay for simulation
        #10 $finish;
    end

    always begin
        #1 clk = ~clk; // Toggle clock every cycle
    end

endmodule
","module top_module ();



`timescale 1ns/1ns

module tb_tff;
    reg clk;
    reg reset;
    reg t;
    wire q;

    tff tff_inst (
        .clk(clk),
        .reset(reset),
        .t(t),
        .q(q)
    );

    initial begin
        $dumpfile(""tb_tff.vcd"");
        $dumpvars(0, tb_tff);

        // Initialize inputs
        clk = 0;
        reset = 1;
        t = 0;

        // Reset the T flip-flop
        #5 reset = 0;

        // Toggle the T flip-flop to the ""1"" state
        #5 t = 1;

        // Add some delay for simulation
        #10 $finish;
    end

    always begin
        #1 clk = ~clk; // Toggle clock every cycle
    end

endmodule
"
"`timescale 1ns / 1ps

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff dut (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    $dumpfile(""tb_tff.vcd"");
    $dumpvars(0, tb_tff);

    clk = 0;
    reset = 1;
    t = 0;
    #10 reset = 0;
    #10 reset = 1;
    #10 reset = 0;
    #10 t = 1;
    #10 t = 0;
    #10 t = 1;
    #10 t = 0;
    #10 $finish;
end

always #5 clk = ~clk;

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



`timescale 1ns / 1ps

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff dut (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    $dumpfile(""tb_tff.vcd"");
    $dumpvars(0, tb_tff);

    clk = 0;
    reset = 1;
    t = 0;
    #10 reset = 0;
    #10 reset = 1;
    #10 reset = 0;
    #10 t = 1;
    #10 t = 0;
    #10 t = 1;
    #10 t = 0;
    #10 $finish;
end

always #5 clk = ~clk;

endmodule
","module top_module ();



`timescale 1ns / 1ps

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff dut (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    $dumpfile(""tb_tff.vcd"");
    $dumpvars(0, tb_tff);

    clk = 0;
    reset = 1;
    t = 0;
    #10 reset = 0;
    #10 reset = 1;
    #10 reset = 0;
    #10 t = 1;
    #10 t = 0;
    #10 t = 1;
    #10 t = 0;
    #10 $finish;
end

always #5 clk = ~clk;

endmodule
"
"`timescale 1ns/1ns

module tb_tff;

reg clk, reset, t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    $dumpfile(""tb_tff.vcd"");
    $dumpvars(0, tb_tff);

    // Initialize inputs
    clk = 0;
    reset = 1;
    t = 0;

    // Apply reset
    #5 reset = 0;

    // Toggle T to ""1"" state
    #5 t = 1;

    // Finish simulation
    #10 $finish;
end

always #1 clk = ~clk;

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



`timescale 1ns/1ns

module tb_tff;

reg clk, reset, t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    $dumpfile(""tb_tff.vcd"");
    $dumpvars(0, tb_tff);

    // Initialize inputs
    clk = 0;
    reset = 1;
    t = 0;

    // Apply reset
    #5 reset = 0;

    // Toggle T to ""1"" state
    #5 t = 1;

    // Finish simulation
    #10 $finish;
end

always #1 clk = ~clk;

endmodule
","module top_module ();



`timescale 1ns/1ns

module tb_tff;

reg clk, reset, t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    $dumpfile(""tb_tff.vcd"");
    $dumpvars(0, tb_tff);

    // Initialize inputs
    clk = 0;
    reset = 1;
    t = 0;

    // Apply reset
    #5 reset = 0;

    // Toggle T to ""1"" state
    #5 t = 1;

    // Finish simulation
    #10 $finish;
end

always #1 clk = ~clk;

endmodule
"
"`timescale 1ns/1ns

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    clk = 0;
    reset = 1;
    t = 0;
    
    #5 reset = 0; // De-assert reset after 5ns
    #5 t = 1; // Toggle T input after 5ns
    #5 t = 0; // Toggle T input back to 0 after 5ns
    
    // Add more test cases here if needed
    
    $finish;
end

always #1 clk = ~clk;

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



`timescale 1ns/1ns

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    clk = 0;
    reset = 1;
    t = 0;
    
    #5 reset = 0; // De-assert reset after 5ns
    #5 t = 1; // Toggle T input after 5ns
    #5 t = 0; // Toggle T input back to 0 after 5ns
    
    // Add more test cases here if needed
    
    $finish;
end

always #1 clk = ~clk;

endmodule
","module top_module ();



`timescale 1ns/1ns

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    clk = 0;
    reset = 1;
    t = 0;
    
    #5 reset = 0; // De-assert reset after 5ns
    #5 t = 1; // Toggle T input after 5ns
    #5 t = 0; // Toggle T input back to 0 after 5ns
    
    // Add more test cases here if needed
    
    $finish;
end

always #1 clk = ~clk;

endmodule
"
"`timescale 1ns/1ns

module top_module;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    // Initialize inputs
    clk = 0;
    reset = 1;
    t = 0;

    // Reset the T flip-flop
    #1 reset = 0;

    // Toggle the T flip-flop to the ""1"" state
    #1 t = 1;

    // Add any additional test cases or simulations here

    // End simulation
    #10 $finish;
end

always begin
    #0.5 clk = ~clk; // Toggle clock every 0.5ns
end

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



`timescale 1ns/1ns

module top_module;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    // Initialize inputs
    clk = 0;
    reset = 1;
    t = 0;

    // Reset the T flip-flop
    #1 reset = 0;

    // Toggle the T flip-flop to the ""1"" state
    #1 t = 1;

    // Add any additional test cases or simulations here

    // End simulation
    #10 $finish;
end

always begin
    #0.5 clk = ~clk; // Toggle clock every 0.5ns
end

endmodule
","module top_module ();



`timescale 1ns/1ns

module top_module;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    // Initialize inputs
    clk = 0;
    reset = 1;
    t = 0;

    // Reset the T flip-flop
    #1 reset = 0;

    // Toggle the T flip-flop to the ""1"" state
    #1 t = 1;

    // Add any additional test cases or simulations here

    // End simulation
    #10 $finish;
end

always begin
    #0.5 clk = ~clk; // Toggle clock every 0.5ns
end

endmodule
"
"`timescale 1ns / 1ps

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    clk = 0;
    reset = 1;
    t = 0;
    
    #5 reset = 0;
    #5 t = 1;
    #5 t = 0;
    
    #5 $finish;
end

always begin
    #1 clk = ~clk;
end

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



`timescale 1ns / 1ps

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    clk = 0;
    reset = 1;
    t = 0;
    
    #5 reset = 0;
    #5 t = 1;
    #5 t = 0;
    
    #5 $finish;
end

always begin
    #1 clk = ~clk;
end

endmodule
","module top_module ();



`timescale 1ns / 1ps

module tb_tff;

reg clk;
reg reset;
reg t;
wire q;

tff tff_inst (
    .clk(clk),
    .reset(reset),
    .t(t),
    .q(q)
);

initial begin
    clk = 0;
    reset = 1;
    t = 0;
    
    #5 reset = 0;
    #5 t = 1;
    #5 t = 0;
    
    #5 $finish;
end

always begin
    #1 clk = ~clk;
end

endmodule
"
"// Include the T flip-flop module
`include ""tff_module.v""

// Define the testbench module
module tb_top_module ();

    // Declare signals for the testbench
    reg clk;
    reg reset;
    reg t;
    wire q;

    // Instantiate the T flip-flop module
    tff tff_inst (
        .clk(clk),
        .reset(reset),
        .t(t),
        .q(q)
    );

    // Initial values for signals
    initial begin
        clk = 0;
        reset = 1; // Active-high synchronous reset
        t = 0;
        
        // Reset the T flip-flop
        #10 reset = 0;
        
        // Toggle the T flip-flop to the ""1"" state
        #10 t = 1;
    end

    // Clock generation
    always begin
        #5 clk = ~clk;
    end

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



// Include the T flip-flop module
`include ""tff_module.v""

// Define the testbench module
module tb_top_module ();

    // Declare signals for the testbench
    reg clk;
    reg reset;
    reg t;
    wire q;

    // Instantiate the T flip-flop module
    tff tff_inst (
        .clk(clk),
        .reset(reset),
        .t(t),
        .q(q)
    );

    // Initial values for signals
    initial begin
        clk = 0;
        reset = 1; // Active-high synchronous reset
        t = 0;
        
        // Reset the T flip-flop
        #10 reset = 0;
        
        // Toggle the T flip-flop to the ""1"" state
        #10 t = 1;
    end

    // Clock generation
    always begin
        #5 clk = ~clk;
    end

endmodule
","module top_module ();



// Include the T flip-flop module
`include ""tff_module.v""

// Define the testbench module
module tb_top_module ();

    // Declare signals for the testbench
    reg clk;
    reg reset;
    reg t;
    wire q;

    // Instantiate the T flip-flop module
    tff tff_inst (
        .clk(clk),
        .reset(reset),
        .t(t),
        .q(q)
    );

    // Initial values for signals
    initial begin
        clk = 0;
        reset = 1; // Active-high synchronous reset
        t = 0;
        
        // Reset the T flip-flop
        #10 reset = 0;
        
        // Toggle the T flip-flop to the ""1"" state
        #10 t = 1;
    end

    // Clock generation
    always begin
        #5 clk = ~clk;
    end

endmodule
"
"// Include the T flip-flop module
`include ""tff.v""

// Define the top module
module top_module ();

    // Instantiate the T flip-flop module
    tff tff_inst (
        .clk(clk),
        .reset(reset),
        .t(t),
        .q(q)
    );

    // Declare signals
    reg clk;
    reg reset;
    reg t;
    wire q;

    // Clock generation
    always begin
        #5 clk = ~clk; // Toggle the clock every 5 time units
    end

    // Reset the T flip-flop
    initial begin
        reset = 1; // Assert reset
        #10 reset = 0; // De-assert reset after 10 time units
    end

    // Toggle the T flip-flop to the ""1"" state
    initial begin
        #15 t = 1; // Toggle the T input to ""1"" after 15 time units
        #20 t = 0; // Toggle the T input back to ""0"" after 20 time units
        #25 $stop; // Stop the simulation after 25 time units
    end

endmodule
",-1.0,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();



// Include the T flip-flop module
`include ""tff.v""

// Define the top module
module top_module ();

    // Instantiate the T flip-flop module
    tff tff_inst (
        .clk(clk),
        .reset(reset),
        .t(t),
        .q(q)
    );

    // Declare signals
    reg clk;
    reg reset;
    reg t;
    wire q;

    // Clock generation
    always begin
        #5 clk = ~clk; // Toggle the clock every 5 time units
    end

    // Reset the T flip-flop
    initial begin
        reset = 1; // Assert reset
        #10 reset = 0; // De-assert reset after 10 time units
    end

    // Toggle the T flip-flop to the ""1"" state
    initial begin
        #15 t = 1; // Toggle the T input to ""1"" after 15 time units
        #20 t = 0; // Toggle the T input back to ""0"" after 20 time units
        #25 $stop; // Stop the simulation after 25 time units
    end

endmodule
","module top_module ();



// Include the T flip-flop module
`include ""tff.v""

// Define the top module
module top_module ();

    // Instantiate the T flip-flop module
    tff tff_inst (
        .clk(clk),
        .reset(reset),
        .t(t),
        .q(q)
    );

    // Declare signals
    reg clk;
    reg reset;
    reg t;
    wire q;

    // Clock generation
    always begin
        #5 clk = ~clk; // Toggle the clock every 5 time units
    end

    // Reset the T flip-flop
    initial begin
        reset = 1; // Assert reset
        #10 reset = 0; // De-assert reset after 10 time units
    end

    // Toggle the T flip-flop to the ""1"" state
    initial begin
        #15 t = 1; // Toggle the T input to ""1"" after 15 time units
        #20 t = 0; // Toggle the T input back to ""0"" after 20 time units
        #25 $stop; // Stop the simulation after 25 time units
    end

endmodule
"
"assign heater = (mode == 1) && too_cold;
assign aircon = (mode == 0) && too_hot;
assign fan = heater || aircon || fan_on;
",-1.0,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
assign heater = (mode == 1) && too_cold;
assign aircon = (mode == 0) && too_hot;
assign fan = heater || aircon || fan_on;
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
assign heater = (mode == 1) && too_cold;
assign aircon = (mode == 0) && too_hot;
assign fan = heater || aircon || fan_on;
"
"assign heater = (mode & too_cold) | fan_on;
assign aircon = (~mode & too_hot) | fan_on;
assign fan = heater | aircon | fan_on;
",-1.0,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
assign heater = (mode & too_cold) | fan_on;
assign aircon = (~mode & too_hot) | fan_on;
assign fan = heater | aircon | fan_on;
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
assign heater = (mode & too_cold) | fan_on;
assign aircon = (~mode & too_hot) | fan_on;
assign fan = heater | aircon | fan_on;
"
"    assign heater = (mode & too_cold) | fan_on;
    assign aircon = (~mode & too_hot) | fan_on;
    assign fan = heater | aircon | fan_on;
",-1.0,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode & too_cold) | fan_on;
    assign aircon = (~mode & too_hot) | fan_on;
    assign fan = heater | aircon | fan_on;
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode & too_cold) | fan_on;
    assign aircon = (~mode & too_hot) | fan_on;
    assign fan = heater | aircon | fan_on;
"
"
    assign heater = (mode & too_cold) | fan_on;
    assign aircon = (~mode & too_hot) | fan_on;
    assign fan = heater | aircon | fan_on; 
endmodule
",-0.5,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);

    assign heater = (mode & too_cold) | fan_on;
    assign aircon = (~mode & too_hot) | fan_on;
    assign fan = heater | aircon | fan_on; 
endmodule
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);

    assign heater = (mode & too_cold) | fan_on;
    assign aircon = (~mode & too_hot) | fan_on;
    assign fan = heater | aircon | fan_on; 
endmodule
"
"    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = heater || aircon || fan_on; 
endmodule
",1.0,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = heater || aircon || fan_on; 
endmodule
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = heater || aircon || fan_on; 
endmodule
"
"assign heater = (mode == 1) && too_cold;
assign aircon = (mode == 0) && too_hot;
assign fan = ((heater || aircon) || fan_on);
",-1.0,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
assign heater = (mode == 1) && too_cold;
assign aircon = (mode == 0) && too_hot;
assign fan = ((heater || aircon) || fan_on);
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
assign heater = (mode == 1) && too_cold;
assign aircon = (mode == 0) && too_hot;
assign fan = ((heater || aircon) || fan_on);
"
"    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = fan_on || heater || aircon; 
endmodule
",1.0,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = fan_on || heater || aircon; 
endmodule
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = fan_on || heater || aircon; 
endmodule
"
"
    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = fan_on || heater || aircon; 
endmodule
",1.0,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);

    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = fan_on || heater || aircon; 
endmodule
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);

    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = fan_on || heater || aircon; 
endmodule
"
"    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = heater || aircon || fan_on; 
endmodule
",1.0,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = heater || aircon || fan_on; 
endmodule
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = heater || aircon || fan_on; 
endmodule
"
"    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = heater || aircon || fan_on; 
endmodule
",1.0,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = heater || aircon || fan_on; 
endmodule
","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign heater = (mode == 1) && too_cold;
    assign aircon = (mode == 0) && too_hot;
    assign fan = heater || aircon || fan_on; 
endmodule
"
"    wire row_2, row_3, row_5, row_7;

    // Detect when the input matches each row
    and gate_2 (row_2, !x3, x2, !x1);
    and gate_3 (row_3, !x3, x2, x1);
    and gate_5 (row_5, x3, !x2, x1);
    and gate_7 (row_7, x3, x2, x1);

    // OR the rows that result in a '1' output
    or gate_output (f, row_2, row_3, row_5, row_7);

endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row_2, row_3, row_5, row_7;

    // Detect when the input matches each row
    and gate_2 (row_2, !x3, x2, !x1);
    and gate_3 (row_3, !x3, x2, x1);
    and gate_5 (row_5, x3, !x2, x1);
    and gate_7 (row_7, x3, x2, x1);

    // OR the rows that result in a '1' output
    or gate_output (f, row_2, row_3, row_5, row_7);

endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row_2, row_3, row_5, row_7;

    // Detect when the input matches each row
    and gate_2 (row_2, !x3, x2, !x1);
    and gate_3 (row_3, !x3, x2, x1);
    and gate_5 (row_5, x3, !x2, x1);
    and gate_7 (row_7, x3, x2, x1);

    // OR the rows that result in a '1' output
    or gate_output (f, row_2, row_3, row_5, row_7);

endmodule
"
"
    wire row2, row3, row5, row7; // wires to detect matching rows
    
    // Implementing AND gates for each row
    and gate_row2(row2, !x3, x2, !x1);
    and gate_row3(row3, !x3, x2, x1);
    and gate_row5(row5, x3, !x2, x1);
    and gate_row7(row7, x3, x2, x1);
    
    // Implementing OR gate to combine the outputs of the AND gates
    or gate_output(f, row2, row3, row5, row7);
    
endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);


    wire row2, row3, row5, row7; // wires to detect matching rows
    
    // Implementing AND gates for each row
    and gate_row2(row2, !x3, x2, !x1);
    and gate_row3(row3, !x3, x2, x1);
    and gate_row5(row5, x3, !x2, x1);
    and gate_row7(row7, x3, x2, x1);
    
    // Implementing OR gate to combine the outputs of the AND gates
    or gate_output(f, row2, row3, row5, row7);
    
endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);


    wire row2, row3, row5, row7; // wires to detect matching rows
    
    // Implementing AND gates for each row
    and gate_row2(row2, !x3, x2, !x1);
    and gate_row3(row3, !x3, x2, x1);
    and gate_row5(row5, x3, !x2, x1);
    and gate_row7(row7, x3, x2, x1);
    
    // Implementing OR gate to combine the outputs of the AND gates
    or gate_output(f, row2, row3, row5, row7);
    
endmodule
"
"    wire row2, row3, row5, row7;
    
    // Detect when the input matches each row
    and gate_row2(row2, !x3, x2, !x1);
    and gate_row3(row3, !x3, x2, x1);
    and gate_row5(row5, x3, !x2, x1);
    and gate_row7(row7, x3, x2, x1);
    
    // OR the rows together to get the output
    or gate_output(f, row2, row3, row5, row7);
    
endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row2, row3, row5, row7;
    
    // Detect when the input matches each row
    and gate_row2(row2, !x3, x2, !x1);
    and gate_row3(row3, !x3, x2, x1);
    and gate_row5(row5, x3, !x2, x1);
    and gate_row7(row7, x3, x2, x1);
    
    // OR the rows together to get the output
    or gate_output(f, row2, row3, row5, row7);
    
endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row2, row3, row5, row7;
    
    // Detect when the input matches each row
    and gate_row2(row2, !x3, x2, !x1);
    and gate_row3(row3, !x3, x2, x1);
    and gate_row5(row5, x3, !x2, x1);
    and gate_row7(row7, x3, x2, x1);
    
    // OR the rows together to get the output
    or gate_output(f, row2, row3, row5, row7);
    
endmodule
"
"    wire row_2, row_3, row_5, row_7;

    // Implementing row 2: x3=0, x2=1, x1=0
    assign row_2 = ~x3 & x2 & ~x1;

    // Implementing row 3: x3=0, x2=1, x1=1
    assign row_3 = ~x3 & x2 & x1;

    // Implementing row 5: x3=1, x2=0, x1=1
    assign row_5 = x3 & ~x2 & x1;

    // Implementing row 7: x3=1, x2=1, x1=1
    assign row_7 = x3 & x2 & x1;

    // Output f is 1 if any of the rows 2, 3, 5, or 7 are true
    assign f = row_2 | row_3 | row_5 | row_7;

endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row_2, row_3, row_5, row_7;

    // Implementing row 2: x3=0, x2=1, x1=0
    assign row_2 = ~x3 & x2 & ~x1;

    // Implementing row 3: x3=0, x2=1, x1=1
    assign row_3 = ~x3 & x2 & x1;

    // Implementing row 5: x3=1, x2=0, x1=1
    assign row_5 = x3 & ~x2 & x1;

    // Implementing row 7: x3=1, x2=1, x1=1
    assign row_7 = x3 & x2 & x1;

    // Output f is 1 if any of the rows 2, 3, 5, or 7 are true
    assign f = row_2 | row_3 | row_5 | row_7;

endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row_2, row_3, row_5, row_7;

    // Implementing row 2: x3=0, x2=1, x1=0
    assign row_2 = ~x3 & x2 & ~x1;

    // Implementing row 3: x3=0, x2=1, x1=1
    assign row_3 = ~x3 & x2 & x1;

    // Implementing row 5: x3=1, x2=0, x1=1
    assign row_5 = x3 & ~x2 & x1;

    // Implementing row 7: x3=1, x2=1, x1=1
    assign row_7 = x3 & x2 & x1;

    // Output f is 1 if any of the rows 2, 3, 5, or 7 are true
    assign f = row_2 | row_3 | row_5 | row_7;

endmodule
"
"
    wire row2, row3, row5, row7; // wires to represent each row
    
    // AND gates for each row
    and gate_row2(row2, !x3, x2, !x1); // row 2: x3=0, x2=1, x1=0
    and gate_row3(row3, !x3, x2, x1);  // row 3: x3=0, x2=1, x1=1
    and gate_row5(row5, x3, !x2, x1);  // row 5: x3=1, x2=0, x1=1
    and gate_row7(row7, x3, x2, x1);   // row 7: x3=1, x2=1, x1=1
    
    // OR gate to combine the outputs of the AND gates
    or gate_output(f, row2, row3, row5, row7); // output is 1 if input matches row 2, 3, 5, or 7
    
endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);


    wire row2, row3, row5, row7; // wires to represent each row
    
    // AND gates for each row
    and gate_row2(row2, !x3, x2, !x1); // row 2: x3=0, x2=1, x1=0
    and gate_row3(row3, !x3, x2, x1);  // row 3: x3=0, x2=1, x1=1
    and gate_row5(row5, x3, !x2, x1);  // row 5: x3=1, x2=0, x1=1
    and gate_row7(row7, x3, x2, x1);   // row 7: x3=1, x2=1, x1=1
    
    // OR gate to combine the outputs of the AND gates
    or gate_output(f, row2, row3, row5, row7); // output is 1 if input matches row 2, 3, 5, or 7
    
endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);


    wire row2, row3, row5, row7; // wires to represent each row
    
    // AND gates for each row
    and gate_row2(row2, !x3, x2, !x1); // row 2: x3=0, x2=1, x1=0
    and gate_row3(row3, !x3, x2, x1);  // row 3: x3=0, x2=1, x1=1
    and gate_row5(row5, x3, !x2, x1);  // row 5: x3=1, x2=0, x1=1
    and gate_row7(row7, x3, x2, x1);   // row 7: x3=1, x2=1, x1=1
    
    // OR gate to combine the outputs of the AND gates
    or gate_output(f, row2, row3, row5, row7); // output is 1 if input matches row 2, 3, 5, or 7
    
endmodule
"
"    wire term1, term2, term3, term4;

    // Implementing the AND gates for each row
    and gate1(term1, ~x3, x2, ~x1); // row 2
    and gate2(term2, ~x3, x2, x1);  // row 3
    and gate3(term3, x3, ~x2, x1);  // row 5
    and gate4(term4, x3, x2, x1);   // row 7

    // Implementing the OR gate to combine the outputs of the AND gates
    or or_gate(f, term1, term2, term3, term4);

endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire term1, term2, term3, term4;

    // Implementing the AND gates for each row
    and gate1(term1, ~x3, x2, ~x1); // row 2
    and gate2(term2, ~x3, x2, x1);  // row 3
    and gate3(term3, x3, ~x2, x1);  // row 5
    and gate4(term4, x3, x2, x1);   // row 7

    // Implementing the OR gate to combine the outputs of the AND gates
    or or_gate(f, term1, term2, term3, term4);

endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire term1, term2, term3, term4;

    // Implementing the AND gates for each row
    and gate1(term1, ~x3, x2, ~x1); // row 2
    and gate2(term2, ~x3, x2, x1);  // row 3
    and gate3(term3, x3, ~x2, x1);  // row 5
    and gate4(term4, x3, x2, x1);   // row 7

    // Implementing the OR gate to combine the outputs of the AND gates
    or or_gate(f, term1, term2, term3, term4);

endmodule
"
"    wire row2, row3, row5, row7; // create wires for each row
    wire output; // create wire for final output
    
    // Implement AND gates for each row
    and gate1(row2, !x3, x2, !x1); // row 2: x3=0, x2=1, x1=0
    and gate2(row3, !x3, x2, x1); // row 3: x3=0, x2=1, x1=1
    and gate3(row5, x3, !x2, x1); // row 5: x3=1, x2=0, x1=1
    and gate4(row7, x3, x2, x1); // row 7: x3=1, x2=1, x1=1
    
    // Implement OR gate for final output
    or gate5(output, row2, row3, row5, row7); // output is 1 if any of the rows are true
    
    assign f = output; // assign final output to f
endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row2, row3, row5, row7; // create wires for each row
    wire output; // create wire for final output
    
    // Implement AND gates for each row
    and gate1(row2, !x3, x2, !x1); // row 2: x3=0, x2=1, x1=0
    and gate2(row3, !x3, x2, x1); // row 3: x3=0, x2=1, x1=1
    and gate3(row5, x3, !x2, x1); // row 5: x3=1, x2=0, x1=1
    and gate4(row7, x3, x2, x1); // row 7: x3=1, x2=1, x1=1
    
    // Implement OR gate for final output
    or gate5(output, row2, row3, row5, row7); // output is 1 if any of the rows are true
    
    assign f = output; // assign final output to f
endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row2, row3, row5, row7; // create wires for each row
    wire output; // create wire for final output
    
    // Implement AND gates for each row
    and gate1(row2, !x3, x2, !x1); // row 2: x3=0, x2=1, x1=0
    and gate2(row3, !x3, x2, x1); // row 3: x3=0, x2=1, x1=1
    and gate3(row5, x3, !x2, x1); // row 5: x3=1, x2=0, x1=1
    and gate4(row7, x3, x2, x1); // row 7: x3=1, x2=1, x1=1
    
    // Implement OR gate for final output
    or gate5(output, row2, row3, row5, row7); // output is 1 if any of the rows are true
    
    assign f = output; // assign final output to f
endmodule
"
"    wire row2, row3, row5, row7; // wires to store the output of each row
    
    // AND gates to detect each row
    and gate2(row2, !x3, x2, !x1); // row 2: x3=0, x2=1, x1=0
    and gate3(row3, !x3, x2, x1); // row 3: x3=0, x2=1, x1=1
    and gate5(row5, x3, !x2, x1); // row 5: x3=1, x2=0, x1=1
    and gate7(row7, x3, x2, x1); // row 7: x3=1, x2=1, x1=1
    
    // OR gate to combine the outputs of the AND gates
    or gate_out(f, row2, row3, row5, row7); // output is 1 if input matches row 2, 3, 5, or 7
endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row2, row3, row5, row7; // wires to store the output of each row
    
    // AND gates to detect each row
    and gate2(row2, !x3, x2, !x1); // row 2: x3=0, x2=1, x1=0
    and gate3(row3, !x3, x2, x1); // row 3: x3=0, x2=1, x1=1
    and gate5(row5, x3, !x2, x1); // row 5: x3=1, x2=0, x1=1
    and gate7(row7, x3, x2, x1); // row 7: x3=1, x2=1, x1=1
    
    // OR gate to combine the outputs of the AND gates
    or gate_out(f, row2, row3, row5, row7); // output is 1 if input matches row 2, 3, 5, or 7
endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row2, row3, row5, row7; // wires to store the output of each row
    
    // AND gates to detect each row
    and gate2(row2, !x3, x2, !x1); // row 2: x3=0, x2=1, x1=0
    and gate3(row3, !x3, x2, x1); // row 3: x3=0, x2=1, x1=1
    and gate5(row5, x3, !x2, x1); // row 5: x3=1, x2=0, x1=1
    and gate7(row7, x3, x2, x1); // row 7: x3=1, x2=1, x1=1
    
    // OR gate to combine the outputs of the AND gates
    or gate_out(f, row2, row3, row5, row7); // output is 1 if input matches row 2, 3, 5, or 7
endmodule
"
"    wire row2, row3, row5, row7;

    // Detect when the input matches each row
    assign row2 = ~x3 & x2 & ~x1;
    assign row3 = ~x3 & x2 & x1;
    assign row5 = x3 & ~x2 & x1;
    assign row7 = x3 & x2 & x1;

    // Output is 1 if the input matches row 2 or row 3 or row 5 or row 7
    assign f = row2 | row3 | row5 | row7;

endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row2, row3, row5, row7;

    // Detect when the input matches each row
    assign row2 = ~x3 & x2 & ~x1;
    assign row3 = ~x3 & x2 & x1;
    assign row5 = x3 & ~x2 & x1;
    assign row7 = x3 & x2 & x1;

    // Output is 1 if the input matches row 2 or row 3 or row 5 or row 7
    assign f = row2 | row3 | row5 | row7;

endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

    wire row2, row3, row5, row7;

    // Detect when the input matches each row
    assign row2 = ~x3 & x2 & ~x1;
    assign row3 = ~x3 & x2 & x1;
    assign row5 = x3 & ~x2 & x1;
    assign row7 = x3 & x2 & x1;

    // Output is 1 if the input matches row 2 or row 3 or row 5 or row 7
    assign f = row2 | row3 | row5 | row7;

endmodule
"
"
    wire row2, row3, row5, row7; // wires to represent each row
    
    // detecting when input matches each row
    and gate2 (row2, !x3, x2, !x1); // row 2
    and gate3 (row3, !x3, x2, x1); // row 3
    and gate5 (row5, x3, !x2, x1); // row 5
    and gate7 (row7, x3, x2, x1); // row 7
    
    // ORing the rows to get the output
    or gate_output (f, row2, row3, row5, row7);
    
endmodule
",-1.0,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);


    wire row2, row3, row5, row7; // wires to represent each row
    
    // detecting when input matches each row
    and gate2 (row2, !x3, x2, !x1); // row 2
    and gate3 (row3, !x3, x2, x1); // row 3
    and gate5 (row5, x3, !x2, x1); // row 5
    and gate7 (row7, x3, x2, x1); // row 7
    
    // ORing the rows to get the output
    or gate_output (f, row2, row3, row5, row7);
    
endmodule
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);


    wire row2, row3, row5, row7; // wires to represent each row
    
    // detecting when input matches each row
    and gate2 (row2, !x3, x2, !x1); // row 2
    and gate3 (row3, !x3, x2, x1); // row 3
    and gate5 (row5, x3, !x2, x1); // row 5
    and gate7 (row7, x3, x2, x1); // row 7
    
    // ORing the rows to get the output
    or gate_output (f, row2, row3, row5, row7);
    
endmodule
"
"
    assign {o2, o1, o0} = vec; // Split the input vector into three separate 1-bit outputs
    assign outv = vec; // Output the same vector as the input
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec; // Split the input vector into three separate 1-bit outputs
    assign outv = vec; // Output the same vector as the input
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec; // Split the input vector into three separate 1-bit outputs
    assign outv = vec; // Output the same vector as the input
endmodule
"
"
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule
"
"
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule
"
"
    assign outv = vec;
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];
endmodule
"
"
    assign {o2, o1, o0} = vec; // Assigning the individual bits of the input vector to the output bits
    assign outv = vec; // Assigning the input vector to the output vector
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec; // Assigning the individual bits of the input vector to the output bits
    assign outv = vec; // Assigning the input vector to the output vector
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec; // Assigning the individual bits of the input vector to the output bits
    assign outv = vec; // Assigning the input vector to the output vector
endmodule
"
"
    assign {o2, o1, o0} = vec; // Splitting the input vector into three separate 1-bit outputs
    assign outv = vec; // Outputting the same vector as input
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec; // Splitting the input vector into three separate 1-bit outputs
    assign outv = vec; // Outputting the same vector as input
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec; // Splitting the input vector into three separate 1-bit outputs
    assign outv = vec; // Outputting the same vector as input
endmodule
"
"
    assign outv = vec;
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];
endmodule
"
"
    assign outv = vec;
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];
endmodule
"
"
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule
"
"
    assign {o2, o1, o0} = vec; // Splitting the input vector into three separate 1-bit outputs
    assign outv = vec; // Outputting the same vector as input
endmodule
",1.0,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec; // Splitting the input vector into three separate 1-bit outputs
    assign outv = vec; // Outputting the same vector as input
endmodule
","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign {o2, o1, o0} = vec; // Splitting the input vector into three separate 1-bit outputs
    assign outv = vec; // Outputting the same vector as input
endmodule
"
"    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
",1.0,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
endmodule
"
"
    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99 - i];
        end
    end
endmodule
",-1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99 - i];
        end
    end
endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99 - i];
        end
    end
endmodule
"
"
    assign out = 0;
    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
",-1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = 0;
    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = 0;
    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
"
"
    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
",-1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
"
"
    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
",-1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
"
"
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], 
                 in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19],
                 in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29],
                 in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39],
                 in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49],
                 in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59],
                 in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69],
                 in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79],
                 in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89],
                 in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99]};
endmodule
",1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], 
                 in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19],
                 in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29],
                 in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39],
                 in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49],
                 in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59],
                 in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69],
                 in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79],
                 in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89],
                 in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99]};
endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], 
                 in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19],
                 in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29],
                 in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39],
                 in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49],
                 in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59],
                 in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69],
                 in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79],
                 in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89],
                 in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99]};
endmodule
"
"
    assign out = 0;
    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99-i];
        end
    end
endmodule
",-1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = 0;
    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99-i];
        end
    end
endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = 0;
    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99-i];
        end
    end
endmodule
"
"
    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99 - i];
        end
    end
endmodule
",-1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99 - i];
        end
    end
endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99 - i];
        end
    end
endmodule
"
"
    assign out = 0;
    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
",-1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = 0;
    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = 0;
    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
"
"
    // Combinational always block to reverse the bit ordering
    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99 - i];
        end
    end

endmodule
",-1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    // Combinational always block to reverse the bit ordering
    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99 - i];
        end
    end

endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    // Combinational always block to reverse the bit ordering
    always @* begin
        for (int i = 0; i < 100; i = i + 1) begin
            out[i] = in[99 - i];
        end
    end

endmodule
"
"
    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
",-1.0,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @* begin
        for (int i = 0; i < 100; i=i+1) begin
            out[i] = in[99-i];
        end
    end
endmodule
"
"
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"
    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
","module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};
endmodule
"
"
    // Concatenate input vectors
    wire [29:0] concatenated_input;
    assign concatenated_input = {a, b, c, d, e, f};

    // Split concatenated input into output vectors
    assign {w, x, y, z} = {concatenated_input[31:24], concatenated_input[23:16], concatenated_input[15:8], concatenated_input[7:0]};
    // Add two 1 bits to the end of the output
    assign {w[7], x[7], y[7], z[7]} = 2'b11; 
endmodule
",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    // Concatenate input vectors
    wire [29:0] concatenated_input;
    assign concatenated_input = {a, b, c, d, e, f};

    // Split concatenated input into output vectors
    assign {w, x, y, z} = {concatenated_input[31:24], concatenated_input[23:16], concatenated_input[15:8], concatenated_input[7:0]};
    // Add two 1 bits to the end of the output
    assign {w[7], x[7], y[7], z[7]} = 2'b11; 
endmodule
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    // Concatenate input vectors
    wire [29:0] concatenated_input;
    assign concatenated_input = {a, b, c, d, e, f};

    // Split concatenated input into output vectors
    assign {w, x, y, z} = {concatenated_input[31:24], concatenated_input[23:16], concatenated_input[15:8], concatenated_input[7:0]};
    // Add two 1 bits to the end of the output
    assign {w[7], x[7], y[7], z[7]} = 2'b11; 
endmodule
"
"
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11}; 
endmodule
",1.0,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11}; 
endmodule
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11}; 
endmodule
"
"
    assign {a, b, c, d, e, f, 2'b11} = {w, x, y, z}; 
endmodule
",-1.0,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {a, b, c, d, e, f, 2'b11} = {w, x, y, z}; 
endmodule
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {a, b, c, d, e, f, 2'b11} = {w, x, y, z}; 
endmodule
"
"
    wire [29:0] input_concatenated;
    wire [31:0] output_concatenated;

    assign input_concatenated = {a, b, c, d, e, f};
    assign output_concatenated = {input_concatenated, 2'b11};

    assign w = output_concatenated[7:0];
    assign x = output_concatenated[15:8];
    assign y = output_concatenated[23:16];
    assign z = output_concatenated[31:24];
endmodule
",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    wire [29:0] input_concatenated;
    wire [31:0] output_concatenated;

    assign input_concatenated = {a, b, c, d, e, f};
    assign output_concatenated = {input_concatenated, 2'b11};

    assign w = output_concatenated[7:0];
    assign x = output_concatenated[15:8];
    assign y = output_concatenated[23:16];
    assign z = output_concatenated[31:24];
endmodule
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    wire [29:0] input_concatenated;
    wire [31:0] output_concatenated;

    assign input_concatenated = {a, b, c, d, e, f};
    assign output_concatenated = {input_concatenated, 2'b11};

    assign w = output_concatenated[7:0];
    assign x = output_concatenated[15:8];
    assign y = output_concatenated[23:16];
    assign z = output_concatenated[31:24];
endmodule
"
"
    wire [29:0] input_concatenated;
    wire [31:0] output_concatenated;

    assign input_concatenated = {a, b, c, d, e, f};
    assign output_concatenated = {input_concatenated, 2'b11};

    assign w = output_concatenated[7:0];
    assign x = output_concatenated[15:8];
    assign y = output_concatenated[23:16];
    assign z = output_concatenated[31:24];
endmodule
",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    wire [29:0] input_concatenated;
    wire [31:0] output_concatenated;

    assign input_concatenated = {a, b, c, d, e, f};
    assign output_concatenated = {input_concatenated, 2'b11};

    assign w = output_concatenated[7:0];
    assign x = output_concatenated[15:8];
    assign y = output_concatenated[23:16];
    assign z = output_concatenated[31:24];
endmodule
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    wire [29:0] input_concatenated;
    wire [31:0] output_concatenated;

    assign input_concatenated = {a, b, c, d, e, f};
    assign output_concatenated = {input_concatenated, 2'b11};

    assign w = output_concatenated[7:0];
    assign x = output_concatenated[15:8];
    assign y = output_concatenated[23:16];
    assign z = output_concatenated[31:24];
endmodule
"
"
    // Concatenate input vectors
    wire [29:0] input_concatenated;
    assign input_concatenated = {a, b, c, d, e, f};

    // Split concatenated input into output vectors
    assign {w, x, y, z} = {input_concatenated[31:24], input_concatenated[23:16], input_concatenated[15:8], input_concatenated[7:0], 2'b11};
endmodule
",1.0,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    // Concatenate input vectors
    wire [29:0] input_concatenated;
    assign input_concatenated = {a, b, c, d, e, f};

    // Split concatenated input into output vectors
    assign {w, x, y, z} = {input_concatenated[31:24], input_concatenated[23:16], input_concatenated[15:8], input_concatenated[7:0], 2'b11};
endmodule
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    // Concatenate input vectors
    wire [29:0] input_concatenated;
    assign input_concatenated = {a, b, c, d, e, f};

    // Split concatenated input into output vectors
    assign {w, x, y, z} = {input_concatenated[31:24], input_concatenated[23:16], input_concatenated[15:8], input_concatenated[7:0], 2'b11};
endmodule
"
"
    // Concatenate input vectors
    wire [29:0] input_concatenated;
    assign input_concatenated = {a, b, c, d, e, f};

    // Split concatenated input into output vectors
    assign {w, x, y, z} = input_concatenated[31:0];

    // Add two 1 bits to the end of the output
    assign {w, x, y, z} = {w, x, y, z, 2'b11};
endmodule
",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    // Concatenate input vectors
    wire [29:0] input_concatenated;
    assign input_concatenated = {a, b, c, d, e, f};

    // Split concatenated input into output vectors
    assign {w, x, y, z} = input_concatenated[31:0];

    // Add two 1 bits to the end of the output
    assign {w, x, y, z} = {w, x, y, z, 2'b11};
endmodule
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    // Concatenate input vectors
    wire [29:0] input_concatenated;
    assign input_concatenated = {a, b, c, d, e, f};

    // Split concatenated input into output vectors
    assign {w, x, y, z} = input_concatenated[31:0];

    // Add two 1 bits to the end of the output
    assign {w, x, y, z} = {w, x, y, z, 2'b11};
endmodule
"
"
    assign {a, b, c, d, e, f, 2'b11} = {w, x, y, z}; 
endmodule
",-1.0,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {a, b, c, d, e, f, 2'b11} = {w, x, y, z}; 
endmodule
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {a, b, c, d, e, f, 2'b11} = {w, x, y, z}; 
endmodule
"
"
    assign {a, b, c, d, e, f, 2'b11} = {w, x, y, z};
",-1.0,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {a, b, c, d, e, f, 2'b11} = {w, x, y, z};
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {a, b, c, d, e, f, 2'b11} = {w, x, y, z};
"
"
    wire [29:0] concatenated_input;
    wire [31:0] output_concatenated;

    assign concatenated_input = {a, b, c, d, e, f};
    assign output_concatenated = {concatenated_input, 2'b11};

    assign w = output_concatenated[7:0];
    assign x = output_concatenated[15:8];
    assign y = output_concatenated[23:16];
    assign z = output_concatenated[31:24];
endmodule
",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    wire [29:0] concatenated_input;
    wire [31:0] output_concatenated;

    assign concatenated_input = {a, b, c, d, e, f};
    assign output_concatenated = {concatenated_input, 2'b11};

    assign w = output_concatenated[7:0];
    assign x = output_concatenated[15:8];
    assign y = output_concatenated[23:16];
    assign z = output_concatenated[31:24];
endmodule
","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    wire [29:0] concatenated_input;
    wire [31:0] output_concatenated;

    assign concatenated_input = {a, b, c, d, e, f};
    assign output_concatenated = {concatenated_input, 2'b11};

    assign w = output_concatenated[7:0];
    assign x = output_concatenated[15:8];
    assign y = output_concatenated[23:16];
    assign z = output_concatenated[31:24];
endmodule
"
"
    assign out = {24{in[7]}, in};
endmodule
",-1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in};
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in};
endmodule
"
"
    assign out = {24{in[7]}, in}; // Sign-extend 8-bit number to 32 bits
endmodule
",-1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in}; // Sign-extend 8-bit number to 32 bits
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in}; // Sign-extend 8-bit number to 32 bits
endmodule
"
"
    assign out = { {24{in[7]}}, in }; 
endmodule
",1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = { {24{in[7]}}, in }; 
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = { {24{in[7]}}, in }; 
endmodule
"
"
    assign out = {24{in[7]}, in}; 
endmodule
",-1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in}; 
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in}; 
endmodule
"
"
    assign out = {24{in[7]}, in}; // Concatenates 24 copies of in[7] followed by the 8-bit number in
endmodule
",-1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in}; // Concatenates 24 copies of in[7] followed by the 8-bit number in
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in}; // Concatenates 24 copies of in[7] followed by the 8-bit number in
endmodule
"
"
    assign out = { {24{in[7]}}, in };
endmodule
",1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = { {24{in[7]}}, in };
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = { {24{in[7]}}, in };
endmodule
"
"
    assign out = {24{in[7]}, in};
endmodule
",-1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in};
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in};
endmodule
"
"
    assign out = {24{in[7]}, in};
endmodule
",-1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in};
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in};
endmodule
"
"
    assign out = {24{in[7]}, in}; // Sign extend 8-bit number to 32 bits
endmodule
",-1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in}; // Sign extend 8-bit number to 32 bits
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in}; // Sign extend 8-bit number to 32 bits
endmodule
"
"
    assign out = {24{in[7]}, in};
endmodule
",-1.0,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in};
endmodule
","module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out = {24{in[7]}, in};
endmodule
"
"
    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
"
"
    assign out = ~{a,a,a,a,a} ^ {b,b,c,d,e};
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,c,d,e};
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,c,d,e};
endmodule
"
"
    assign out = ~{a,a,a,a,a} ^ {b,b,c,d,e};
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,c,d,e};
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,c,d,e};
endmodule
"
"
    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c} ^ {d,d,d,d,d,d,d,d,d,d} ^ {e,e,e,e,e,e,e,e,e,e} ; 
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c} ^ {d,d,d,d,d,d,d,d,d,d} ^ {e,e,e,e,e,e,e,e,e,e} ; 
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c} ^ {d,d,d,d,d,d,d,d,d,d} ^ {e,e,e,e,e,e,e,e,e,e} ; 
endmodule
"
"
    assign out = ~{a,a,a,a,a} ^ {b,b,c,d,e};
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,c,d,e};
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,c,d,e};
endmodule
"
"
    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e}; 
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e}; 
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e}; 
endmodule
"
"
    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
"
"
    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
"
"
    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{a,a,a,a,a} ^ {b,b,b,b,b,c,c,c,c,c,d,d,d,d,d,e,e,e,e,e};
endmodule
"
"
    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ { {a,a,a,a,a}, {b,b,b,b,b}, {c,c,c,c,c}, {d,d,d,d,d}, {e,e,e,e,e} };
endmodule
",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule"," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ { {a,a,a,a,a}, {b,b,b,b,b}, {c,c,c,c,c}, {d,d,d,d,d}, {e,e,e,e,e} };
endmodule
","module top_module (
    input a, b, c, d, e,
    output [24:0] out );

    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ { {a,a,a,a,a}, {b,b,b,b,b}, {c,c,c,c,c}, {d,d,d,d,d}, {e,e,e,e,e} };
endmodule
"
"    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
"
"    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 0) || (b != 0);
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 0) || (b != 0);
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 0) || (b != 0);
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
"
"    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
"
"    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
"
"    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a, b};
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
"
"    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 3'b000) || (b != 3'b000);
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 3'b000) || (b != 3'b000);
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 3'b000) || (b != 3'b000);
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
"
"    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 0) || (b != 0);
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 0) || (b != 0);
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 0) || (b != 0);
    
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
"
"    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a,b};
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a,b};
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = |{a,b};
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
"
"    // Wire declarations
    wire [2:0] a_not, b_not;
    
    // Compute the bitwise OR of a and b
    assign out_or_bitwise = a | b;
    
    // Compute the logical OR of a and b
    assign out_or_logical = |{a, b};
    
    // Compute the inverse of a and b
    assign a_not = ~a;
    assign b_not = ~b;
    
    // Assign the inverse of b in the upper half of out_not and the inverse of a in the lower half
    assign out_not[5:3] = b_not;
    assign out_not[2:0] = a_not;
    
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    // Wire declarations
    wire [2:0] a_not, b_not;
    
    // Compute the bitwise OR of a and b
    assign out_or_bitwise = a | b;
    
    // Compute the logical OR of a and b
    assign out_or_logical = |{a, b};
    
    // Compute the inverse of a and b
    assign a_not = ~a;
    assign b_not = ~b;
    
    // Assign the inverse of b in the upper half of out_not and the inverse of a in the lower half
    assign out_not[5:3] = b_not;
    assign out_not[2:0] = a_not;
    
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    // Wire declarations
    wire [2:0] a_not, b_not;
    
    // Compute the bitwise OR of a and b
    assign out_or_bitwise = a | b;
    
    // Compute the logical OR of a and b
    assign out_or_logical = |{a, b};
    
    // Compute the inverse of a and b
    assign a_not = ~a;
    assign b_not = ~b;
    
    // Assign the inverse of b in the upper half of out_not and the inverse of a in the lower half
    assign out_not[5:3] = b_not;
    assign out_not[2:0] = a_not;
    
endmodule
"
"    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 0) || (b != 0);
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
",-1.0,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 0) || (b != 0);
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = (a != 0) || (b != 0);
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule
"
"
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);

    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);

    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);

    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);

    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);

    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);

    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
",1.0,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
","module top_module( 
    input [7:0] in,
    output [7:0] out
);


    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
"
"
    assign out = in;
endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );

    assign out = in;
endmodule
","module top_module( input in, output out );

    assign out = in;
endmodule
"
"
assign out = in;

endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );

assign out = in;

endmodule
","module top_module( input in, output out );

assign out = in;

endmodule
"
"
  assign out = in;
endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );

  assign out = in;
endmodule
","module top_module( input in, output out );

  assign out = in;
endmodule
"
"
  // Assign the input directly to the output
  assign out = in;
  
endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );

  // Assign the input directly to the output
  assign out = in;
  
endmodule
","module top_module( input in, output out );

  // Assign the input directly to the output
  assign out = in;
  
endmodule
"
"
  assign out = in;
endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );

  assign out = in;
endmodule
","module top_module( input in, output out );

  assign out = in;
endmodule
"
"
    assign out = in;
endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );

    assign out = in;
endmodule
","module top_module( input in, output out );

    assign out = in;
endmodule
"
"
  assign out = in;
endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );

  assign out = in;
endmodule
","module top_module( input in, output out );

  assign out = in;
endmodule
"
"
  assign out = in;
endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );

  assign out = in;
endmodule
","module top_module( input in, output out );

  assign out = in;
endmodule
"
"
  assign out = in;
endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );

  assign out = in;
endmodule
","module top_module( input in, output out );

  assign out = in;
endmodule
"
"   assign out = in;
endmodule
",1.0,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
   assign out = in;
endmodule
","module top_module( input in, output out );
   assign out = in;
endmodule
"
"
    assign {w,x,y,z} = {a,b,b,c}; 
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w,x,y,z} = {a,b,b,c}; 
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w,x,y,z} = {a,b,b,c}; 
endmodule
"
"
  wire w, x, y, z;

  assign {w, x, y, z} = {a, b, b, c};
  
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


  wire w, x, y, z;

  assign {w, x, y, z} = {a, b, b, c};
  
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


  wire w, x, y, z;

  assign {w, x, y, z} = {a, b, b, c};
  
endmodule
"
"
    assign {w, x, y, z} = {a, b, b, c};
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w, x, y, z} = {a, b, b, c};
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w, x, y, z} = {a, b, b, c};
endmodule
"
"
  assign {w, x, y, z} = {a, b, b, c};
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


  assign {w, x, y, z} = {a, b, b, c};
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


  assign {w, x, y, z} = {a, b, b, c};
endmodule
"
"
  // Define internal signals
  wire w, x, y, z;

  // Assign inputs to outputs
  assign w = a;
  assign x = b;
  assign y = b;
  assign z = c;
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


  // Define internal signals
  wire w, x, y, z;

  // Assign inputs to outputs
  assign w = a;
  assign x = b;
  assign y = b;
  assign z = c;
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


  // Define internal signals
  wire w, x, y, z;

  // Assign inputs to outputs
  assign w = a;
  assign x = b;
  assign y = b;
  assign z = c;
endmodule
"
"
  assign {w, x, y, z} = {a, b, b, c};
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


  assign {w, x, y, z} = {a, b, b, c};
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


  assign {w, x, y, z} = {a, b, b, c};
endmodule
"
"
    assign {w, x, y, z} = {a, b, b, c};
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w, x, y, z} = {a, b, b, c};
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w, x, y, z} = {a, b, b, c};
endmodule
"
"
    assign {w, x, y, z} = {a, b, b, c};
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w, x, y, z} = {a, b, b, c};
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w, x, y, z} = {a, b, b, c};
endmodule
"
"
    assign {w,x,y,z} = {a,b,b,c};
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w,x,y,z} = {a,b,b,c};
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


    assign {w,x,y,z} = {a,b,b,c};
endmodule
"
"
  assign {w, x, y, z} = {a, b, b, c};
endmodule
",1.0,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );


  assign {w, x, y, z} = {a, b, b, c};
endmodule
","module top_module( 
    input a,b,c,
    output w,x,y,z );


  assign {w, x, y, z} = {a, b, b, c};
endmodule
"
"
    assign out = ~(a ^ b);
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);
endmodule
"
"
    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT operators
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT operators
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT operators
endmodule
"
"
    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT
endmodule
"
"
    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and NOT operators
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and NOT operators
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and NOT operators
endmodule
"
"
    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT
endmodule
"
"
    assign out = ~(a ^ b);
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);
endmodule
"
"
    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT
endmodule
"
"
    assign out = ~(a ^ b); // XNOR gate implementation using bitwise XOR and NOT operators
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise XOR and NOT operators
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise XOR and NOT operators
endmodule
"
"
    assign out = ~(a ^ b); // XNOR gate implementation using bitwise XOR and NOT operators
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise XOR and NOT operators
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise XOR and NOT operators
endmodule
"
"
    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT operators
endmodule
",1.0,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT operators
endmodule
","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b); // XNOR gate implementation using bitwise-XOR and bitwise-NOT operators
endmodule
"
"assign zero = 0; 
endmodule
",1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);
assign zero = 0; 
endmodule
","module top_module(
    output zero
);
assign zero = 0; 
endmodule
"
"
assign zero = 0; // Output constant 0
",-1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);

assign zero = 0; // Output constant 0
","module top_module(
    output zero
);

assign zero = 0; // Output constant 0
"
"assign zero = 0; // constant output of 0
",-1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);
assign zero = 0; // constant output of 0
","module top_module(
    output zero
);
assign zero = 0; // constant output of 0
"
"assign zero = 0; // Output constant 0
",-1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);
assign zero = 0; // Output constant 0
","module top_module(
    output zero
);
assign zero = 0; // Output constant 0
"
"assign zero = 0; // assign the output to be constantly 0
",-1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);
assign zero = 0; // assign the output to be constantly 0
","module top_module(
    output zero
);
assign zero = 0; // assign the output to be constantly 0
"
"assign zero = 0; 
endmodule
",1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);
assign zero = 0; 
endmodule
","module top_module(
    output zero
);
assign zero = 0; 
endmodule
"
"assign zero = 0; // Output constant 0
",-1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);
assign zero = 0; // Output constant 0
","module top_module(
    output zero
);
assign zero = 0; // Output constant 0
"
"assign zero = 0; // constant output of 0
",-1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);
assign zero = 0; // constant output of 0
","module top_module(
    output zero
);
assign zero = 0; // constant output of 0
"
"
assign zero = 0; // Output constant 0
",-1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);

assign zero = 0; // Output constant 0
","module top_module(
    output zero
);

assign zero = 0; // Output constant 0
"
"    assign zero = 0;
endmodule
",1.0,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);
    assign zero = 0;
endmodule
","module top_module(
    output zero
);
    assign zero = 0;
endmodule
"
